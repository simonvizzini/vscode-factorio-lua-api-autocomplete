{
  "LuaControlBehavior": {
    "name": "LuaControlBehavior",
    "type": "LuaControlBehavior"
  },
  "LuaBootstrap": {
    "name": "LuaBootstrap",
    "type": "LuaBootstrap",
    "doc": "Entry point for registering event handlers. It is accessible through the global object named script.",
    "properties": {
      "generate_event_name": {
        "name": "generate_event_name() → uint",
        "returns": "uint",
        "args": {},
        "doc": "Generate a new, unique event ID.\nReturn value The new ID",
        "type": "function"
      },
      "get_event_handler": {
        "name": "get_event_handler(event)",
        "args": {
          "event": {
            "doc": "event :: uint: The event identifier to get a handler for",
            "name": "event",
            "type": "uint"
          }
        },
        "doc": "Find the event handler for an event\n\nParameters\n\nevent :: uint: The event identifier to get a handler forReturn value Reference to the function currently registered as the handler.",
        "type": "function"
      },
      "on_configuration_changed": {
        "name": "on_configuration_changed(f)",
        "args": {
          "f": {
            "doc": "f :: function(ConfigurationChangedData): The handler for this event. Passing nil will unregister the handler.",
            "name": "f",
            "type": "function(ConfigurationChangedData)"
          }
        },
        "doc": "Register a function to be run when mod configuration changes. This is called any time the game version changes, prototypes change, startup mod settings change, and any time mod versions change including adding or removing mods. \n\nParameters\n\nf :: function(ConfigurationChangedData): The handler for this event. Passing nil will unregister the handler.",
        "type": "function"
      },
      "on_event": {
        "name": "on_event(event, f)",
        "args": {
          "event": {
            "doc": "event :: defines.events or array of defines.events or string: The events or custom-input name to invoke the handler on",
            "name": "event",
            "type": "defines.events or array of defines.events or string"
          },
          "f": {
            "doc": "f :: function(Event): The handler to run. Passing nil will unregister the handler. The handler will receive a table that contains the key name (of type defines.events) specifying the name of the event it was called to handle, and tick that specifies when the event was created. This table will also contain other fields, depending on the type of the event. See the list of Factorio events for a listing of these additional fields.",
            "name": "f",
            "type": "function(Event)"
          }
        },
        "doc": "Register a handler to run on event or events. \n\nParameters\n\nevent :: defines.events or array of defines.events or string: The events or custom-input name to invoke the handler onf :: function(Event): The handler to run. Passing nil will unregister the handler. The handler will receive a table that contains the key name (of type defines.events) specifying the name of the event it was called to handle, and tick that specifies when the event was created. This table will also contain other fields, depending on the type of the event. See the list of\nFactorio events for a listing of these additional fields.",
        "type": "function"
      },
      "on_init": {
        "name": "on_init(f)",
        "args": {
          "f": {
            "doc": "f :: function(): The function to call. Passing nil will unregister the handler.",
            "name": "f",
            "type": "function()"
          }
        },
        "doc": "Register a callback to be run on mod init. This is called once when a new save game is created or once when a save file is loaded that previously didn't contain the mod. This is always called before other event handlers and is meant for setting up initial values that a mod will use for its lifetime. \n\nParameters\n\nf :: function(): The function to call. Passing nil will unregister the handler.",
        "type": "function"
      },
      "on_load": {
        "name": "on_load(f)",
        "args": {
          "f": {
            "doc": "f :: function(): The function to call. Passing nil will unregister the handler.",
            "name": "f",
            "type": "function()"
          }
        },
        "doc": "Register a function to be run on module load. This is called every time a save file is loaded *except* for the instance when a mod is loaded into a save file that it previously wasn't part of. Additionally this is called when connecting to any other game in a multiplayer session and should never change the game state.\n This is meant for 3 specific reasons and only 3: \n *  re-register conditional event handlers\n *  re-setup meta tables\n *  create local references to tables stored in the global table\n In all other instances the LuaBootstrap::on_init, LuaBootstrap::on_configuration_changed or migration scripts should be used. Doing any other logic when loading a save file can break the replay and cause desync issues if the mod is used in multiplayer. \n\nParameters\n\nf :: function(): The function to call. Passing nil will unregister the handler.",
        "type": "function"
      },
      "raise_event": {
        "name": "raise_event(event, table)",
        "args": {
          "event": {
            "doc": "event :: uint: ID of the event to raise",
            "name": "event",
            "type": "uint"
          },
          "table": {
            "doc": "table: Table with extra data. This table will be passed to the event handler.",
            "name": "table"
          }
        },
        "doc": "Raise an event. \n\nParameters\n\nevent :: uint: ID of the event to raisetable: Table with extra data. This table will be passed to the event handler.",
        "type": "function"
      }
    }
  },
  "LuaBurnerPrototype": {
    "name": "LuaBurnerPrototype",
    "type": "LuaBurnerPrototype",
    "doc": "Prototype of a burner energy source.",
    "properties": {
      "burnt_inventory_size": {
        "name": "burnt_inventory_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "effectivity": {
        "name": "effectivity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "fuel_category": {
        "name": "fuel_category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "fuel_inventory_size": {
        "name": "fuel_inventory_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "light_flicker": {
        "name": "light_flicker",
        "mode": "[Read-only]",
        "doc": "The light flicker definition for this burner prototype if any.",
        "type": "light_flicker"
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": ""
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": ""
      },
      "smoke": {
        "name": "smoke",
        "mode": "[Read-only]",
        "doc": "The smoke sources for this burner prototype if any.",
        "type": "smoke"
      }
    }
  },
  "LuaBurner": {
    "name": "LuaBurner",
    "type": "LuaBurner",
    "doc": "A reference to the burner energy source owned by a specfic LuaEntity or LuaEquipment.",
    "properties": {
      "burnt_result_inventory": {
        "name": "burnt_result_inventory",
        "type": "LuaInventory",
        "mode": "[Read-only]",
        "doc": "The burnt result inventory."
      },
      "currently_burning": {
        "name": "currently_burning",
        "type": "LuaItemPrototype",
        "mode": "[Read-Write]",
        "doc": "Note: Writing automatically handles correcting LuaBurner::remaining_burning_fuel."
      },
      "fuel_category": {
        "name": "fuel_category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The fuel category this burner uses."
      },
      "heat": {
        "name": "heat",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "heat_capacity": {
        "name": "heat_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "inventory": {
        "name": "inventory",
        "type": "LuaInventory",
        "mode": "[Read-only]",
        "doc": "The fuel inventory."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity or LuaEquipment",
        "mode": "[Read-only]",
        "doc": "The owner of this burner energy source"
      },
      "remaining_burning_fuel": {
        "name": "remaining_burning_fuel",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Note: Writing will silently do nothing if there's no LuaBurner::currently_burning set."
      }
    }
  },
  "LuaVirtualSignalPrototype": {
    "name": "LuaVirtualSignalPrototype",
    "type": "LuaVirtualSignalPrototype",
    "doc": "Prototype of a virtual signal.",
    "properties": {
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "special": {
        "name": "special",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this is a special signal"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaUnitGroup": {
    "name": "LuaUnitGroup",
    "type": "LuaUnitGroup",
    "doc": "A collection of units moving and attacking together. The engine creates autonomous unit groups to attack\n polluted areas. The script can create and control such groups as well. Groups can accept commands in the\n same manner as regular units.",
    "properties": {
      "add_member": {
        "name": "add_member(unit)",
        "args": {
          "unit": {
            "doc": "unit :: LuaEntity",
            "name": "unit",
            "type": "LuaEntity"
          }
        },
        "doc": "Make a unit a member of this group. Has the same effect as giving a group_command with this group to the unit\n\nParameters\n\nunit :: LuaEntit\n\nNote: The member must have the same force as the unit group.",
        "type": "function"
      },
      "destroy": {
        "name": "destroy()",
        "args": {},
        "doc": "Dissolve this group. Its members won't be destroyed, they will be merely unlinked from this group.",
        "type": "function"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force of this unit group."
      },
      "members": {
        "name": "members",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Members of this group."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Group position. This can have different meanings depending on the group state. When the group is gathering, the position is the place of gathering. When the group is moving, the position is the expected position of its members along the path. When the group is attacking, it is the average position of its members."
      },
      "set_autonomous": {
        "name": "set_autonomous()",
        "args": {},
        "doc": "Make this group autonomous. Autonomous groups will automatically attack polluted areas.",
        "type": "function"
      },
      "set_command": {
        "name": "set_command(command)",
        "args": {
          "command": {
            "doc": "command :: Command",
            "name": "command",
            "type": "Command"
          }
        },
        "doc": "Give this group a command\n\nParameters\n\ncommand :: CommandSee also * LuaEntity::set_command",
        "type": "function"
      },
      "start_moving": {
        "name": "start_moving()",
        "args": {},
        "doc": "Make the group start moving even if some of its members haven't yet arrived.",
        "type": "function"
      },
      "state": {
        "name": "state",
        "type": "defines.group_state",
        "mode": "[Read-only]",
        "doc": "Whether this group is gathering, moving or attacking."
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[Read-only]",
        "doc": "The surface of this unit group."
      }
    }
  },
  "LuaTransportLine": {
    "name": "LuaTransportLine",
    "type": "LuaTransportLine",
    "doc": "One line on a transport belt.",
    "properties": {
      "can_insert_at_back": {
        "name": "can_insert_at_back() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Can an item be inserted at the back of this line?",
        "type": "function"
      },
      "can_insert_at": {
        "name": "can_insert_at(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: float: Where to insert an item.",
            "name": "position",
            "type": "float"
          }
        },
        "doc": "Can an item be inserted at a given position\n\nParameters\n\nposition :: float: Where to insert an item.",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Remove all items from this transport line.",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get counts of all items on this line.\nReturn value The counts, indexed by item names.See also * LuaInventory::get_contents",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Prototype name of the item to count. If not specified, count all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Count some or all items on this line\n\nParameters\n\nitem :: string (optional): Prototype name of the item to count. If not specified, count all items.See also * LuaInventory::get_item_count",
        "type": "function"
      },
      "insert_at_back": {
        "name": "insert_at_back(items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items at the back of this line\n\nParameters\n\nitems :: SimpleItemStackReturn value Were the items inserted successfully?",
        "type": "function"
      },
      "insert_at": {
        "name": "insert_at(position, items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to insert.",
            "name": "items",
            "type": "SimpleItemStack"
          },
          "position": {
            "doc": "position :: float: Where on the line to insert the items.",
            "name": "position",
            "type": "float"
          }
        },
        "doc": "Insert items at a given position\n\nParameters\n\nposition :: float: Where on the line to insert the items.items :: SimpleItemStack: Items to insert.Return value Were the items inserted successfully?",
        "type": "function"
      },
      "operator []": {
        "name": "operator []",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The indexing operator."
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Get the number of items on this transport line."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity this transport line belongs to."
      },
      "remove_item": {
        "name": "remove_item(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to remove.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove some items from this line\n\nParameters\n\nitems :: SimpleItemStack: Items to remove.Return value Number of items actually removed.",
        "type": "function"
      }
    }
  },
  "LuaTile": {
    "name": "LuaTile",
    "type": "LuaTile",
    "doc": "A single \"square\" on the map.",
    "properties": {
      "collides_with": {
        "name": "collides_with(layer)",
        "args": {
          "layer": {
            "doc": "layer :: string: Possible values:  *  \"ground-tile\"\n *  \"water-tile\"\n *  \"resource-layer\"\n *  \"floor-layer\"\n *  \"object-layer\"\n *  \"player-layer\"\n *  \"train-layer\"\n *  \"layer-11\"\n *  \"layer-12\"\n *  \"layer-13\"\n *  \"layer-14\"\n *  \"layer-15\"",
            "name": "layer",
            "type": "string"
          }
        },
        "doc": "What type of things can collide with this tile\n\nParameters\n\nlayer :: string: Possible values:  *  \"ground-tile\"\n *  \"water-tile\"\n *  \"resource-layer\"\n *  \"floor-layer\"\n *  \"object-layer\"\n *  \"player-layer\"\n *  \"train-layer\"\n *  \"layer-11\"\n *  \"layer-12\"\n *  \"layer-13\"\n *  \"layer-14\"\n *  \"layer-15\"\nExampleCheck if the player would collide with a tile game.player.print(tostring(game.player.surface.get_tile(1, 1).collides_with(\"player-layer\")))",
        "type": "function"
      },
      "hidden_tile": {
        "name": "hidden_tile",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Prototype name of this tile. E.g. \"sand-dark\" or \"grass-dry\"."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "The position this tile references."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaTechnologyPrototype": {
    "name": "LuaTechnologyPrototype",
    "type": "LuaTechnologyPrototype",
    "doc": "A Technology prototype.",
    "properties": {
      "effects": {
        "name": "effects",
        "type": "array of Modifier",
        "mode": "[Read-only]",
        "doc": "Effects applied when this technology is researched."
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this technology prototype is enabled by default (enabled at the begining of a game)."
      },
      "level": {
        "name": "level",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The level of this research."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of this technology."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this technology."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string for this prototype."
      },
      "prerequisites": {
        "name": "prerequisites",
        "type": "dictionary string → LuaTechnologyPrototype",
        "mode": "[Read-only]",
        "doc": "Prerequisites of this technology. The result maps technology name to the LuaTechnologyPrototype object."
      },
      "research_unit_count": {
        "name": "research_unit_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of research units required for this technology. \nSee also * LuaTechnologyPrototype::research_unit_ingredients"
      },
      "research_unit_count_formula": {
        "name": "research_unit_count_formula",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The count forumula used for this infinite research or nil if this isn't an infinite research."
      },
      "research_unit_energy": {
        "name": "research_unit_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of energy required to finish a unit of research."
      },
      "research_unit_ingredients": {
        "name": "research_unit_ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients labs will require to research this technology. \nSee also * LuaTechnologyPrototype::research_unit_count"
      },
      "upgrade": {
        "name": "upgrade",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If the is technology prototype is an upgrade to some other technology."
      }
    }
  },
  "LuaTrain": {
    "name": "LuaTrain",
    "type": "LuaTrain",
    "doc": "A train. Trains are a sequence of connected rolling stocks -- locomotives and wagons.",
    "properties": {
      "back_rail": {
        "name": "back_rail",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The rail at the back end of the train, possibly nil."
      },
      "back_stock": {
        "name": "back_stock",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The back stock of this train or nil."
      },
      "cargo_wagons": {
        "name": "cargo_wagons",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "The cargo carriages the train contains."
      },
      "carriages": {
        "name": "carriages",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Rolling stocks the train is composed of."
      },
      "clear_fluids_inside": {
        "name": "clear_fluids_inside()",
        "args": {},
        "doc": "Clears all fluids in this train.",
        "type": "function"
      },
      "clear_items_inside": {
        "name": "clear_items_inside()",
        "args": {},
        "doc": "Clear all items in this train.",
        "type": "function"
      },
      "fluid_wagons": {
        "name": "fluid_wagons",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "The fluid carriages the train contains."
      },
      "front_rail": {
        "name": "front_rail",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The rail at the front end of the train, possibly nil."
      },
      "front_stock": {
        "name": "front_stock",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The front stock of this train or nil."
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get a mapping of the train's inventory.\nReturn value The counts, indexed by item names.",
        "type": "function"
      },
      "get_fluid_contents": {
        "name": "get_fluid_contents() → dictionary string → double",
        "returns": "dictionary string → double",
        "args": {},
        "doc": "Gets a mapping of the train's fluid inventory. \nReturn value The counts, indexed by fluid names.",
        "type": "function"
      },
      "get_fluid_count": {
        "name": "get_fluid_count(fluid) → double",
        "returns": "double",
        "args": {
          "fluid": {
            "doc": "fluid :: string (optional): Fluid name to count. If not given, counts all fluids.",
            "name": "fluid",
            "type": "string"
          }
        },
        "doc": "Get the amount of a particular fluid stored in the train. \n\nParameters\n\nfluid :: string (optional): Fluid name to count. If not given, counts all fluids.",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Item name to count. If not given, counts all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Get the amount of a particular item stored in the train\n\nParameters\n\nitem :: string (optional): Item name to count. If not given, counts all items.",
        "type": "function"
      },
      "has_path": {
        "name": "has_path",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this train has a path."
      },
      "id": {
        "name": "id",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The unique train ID."
      },
      "insert_fluid": {
        "name": "insert_fluid(fluid) → double",
        "returns": "double",
        "args": {
          "fluid": {
            "name": "fluid",
            "type": "fluid"
          }
        },
        "doc": "Inserts the given fluid into the first available location in this train. \n\nParameters\n\nReturn value The amount inserted.",
        "type": "function"
      },
      "insert": {
        "name": "insert(stack)",
        "args": {
          "stack": {
            "doc": "stack :: SimpleItemStack",
            "name": "stack",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert a stack into the train\n\nParameters\n\nstack :: SimpleItemStack",
        "type": "function"
      },
      "locomotives": {
        "name": "locomotives",
        "type": "dictionary string → array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Arrays of locomotives. The result is two arrays, indexed by \"front_movers\" and \"back_movers\"containing the locomotives. E.g. {front_movers={loco1, loco2}, back_movers={loco3}}."
      },
      "manual_mode": {
        "name": "manual_mode",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When true, the train is explicitly controlled by the player or script. When false, the train moves autonomously according to its schedule."
      },
      "path_end_rail": {
        "name": "path_end_rail",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The destination rail this train is currently pathing to or nil."
      },
      "path_end_stop": {
        "name": "path_end_stop",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The destination train stop this train is currently pathing to or nil."
      },
      "rail_direction_from_back_rail": {
        "name": "rail_direction_from_back_rail",
        "type": "defines.rail_direction",
        "mode": "[Read-only]",
        "doc": ""
      },
      "rail_direction_from_front_rail": {
        "name": "rail_direction_from_front_rail",
        "type": "defines.rail_direction",
        "mode": "[Read-only]",
        "doc": ""
      },
      "recalculate_path": {
        "name": "recalculate_path(force) → boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "doc": "force :: boolean (optional): Forces the train to re-path regardless of the current path being valid or not.",
            "name": "force",
            "type": "boolean"
          }
        },
        "doc": "Checks if the path is invalid and tries to re-path if it isn't. \n\nParameters\n\nforce :: boolean (optional): Forces the train to re-path regardless of the current path being valid or not.Return value If the train has a path after the repath attempt.",
        "type": "function"
      },
      "remove_fluid": {
        "name": "remove_fluid(fluid) → double",
        "returns": "double",
        "args": {
          "fluid": {
            "doc": "fluid: A table with type and amount",
            "name": "fluid"
          }
        },
        "doc": "Remove some fluid from the train. \n\nParameters\n\nfluid: A table with type and amountReturn value The amount of fluid actually removed.",
        "type": "function"
      },
      "remove_item": {
        "name": "remove_item(stack) → uint",
        "returns": "uint",
        "args": {
          "stack": {
            "doc": "stack :: SimpleItemStack: The amount and type of items to remove",
            "name": "stack",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove some items from the train\n\nParameters\n\nstack :: SimpleItemStack: The amount and type of items to removeReturn value Number of items actually removed.",
        "type": "function"
      },
      "schedule": {
        "name": "schedule",
        "type": "TrainSchedule",
        "mode": "[Read-Write]",
        "doc": "The trains current schedule. Set to nil to clear. \n\nNote: The schedule can't be changed by modifying the returned table. Instead, changes must be made by assigning a new table to this attribute."
      },
      "speed": {
        "name": "speed",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Current speed. \n\nNote: Changing the speed of the train is potentially an unsafe operation because train uses the speed for its internal calculations of break distances, etc."
      },
      "state": {
        "name": "state",
        "type": "defines.train_state",
        "mode": "[Read-only]",
        "doc": "This train's current state."
      },
      "station": {
        "name": "station",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The train stop this train is stopped at or nil."
      }
    }
  },
  "LuaTilePrototype": {
    "name": "LuaTilePrototype",
    "type": "LuaTilePrototype",
    "doc": "Prototype of a tile.",
    "properties": {
      "allowed_neighbors": {
        "name": "allowed_neighbors",
        "type": "dictionary string → LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[Read-only]",
        "doc": "Autoplace specification for this prototype. nil if none."
      },
      "can_be_part_of_blueprint": {
        "name": "can_be_part_of_blueprint",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "False if this tile is not allowed in blueprints regardless of the ability to build it."
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "The collison mask this tile uses \n The boolean values for each item are meaningless and will always be true\n\nNote: This is a dictionary of the collision masks this tile uses to allow quick lookup of any value."
      },
      "decorative_removal_probability": {
        "name": "decorative_removal_probability",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The probability that decorative entities will be removed from on top of this tile when this tile is generated."
      },
      "emissions_per_tick": {
        "name": "emissions_per_tick",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of pollution emissions per tick this tile will absorb."
      },
      "items_to_place_this": {
        "name": "items_to_place_this",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Items that when placed will produce this tile. It is a dictionary indexed by the item prototype name."
      },
      "layer": {
        "name": "layer",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "map_color": {
        "name": "map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": ""
      },
      "mineable_properties": {
        "name": "mineable_properties",
        "mode": "[Read-only]",
        "doc": "Table with the following fields:  * minable :: boolean: Is this tile mineable at all?\n * hardness :: double: Mining hardness.\n * miningtime :: double: Energy required to mine a tile.\n * miningparticle :: string (optional): Prototype name of the particle produced when mining this tile. Will only be present if this tile produces any particle during mining.\n * products :: array of Product: Products obtained by mining this tile.",
        "type": "mineable_properties"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "vehicle_friction_modifier": {
        "name": "vehicle_friction_modifier",
        "type": "float",
        "mode": "[Read-only]",
        "doc": ""
      },
      "walking_speed_modifier": {
        "name": "walking_speed_modifier",
        "type": "float",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaTechnology": {
    "name": "LuaTechnology",
    "type": "LuaTechnology",
    "doc": "One research item.",
    "properties": {
      "effects": {
        "name": "effects",
        "type": "array of Modifier",
        "mode": "[Read-only]",
        "doc": "Effects applied when this technology is researched."
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Can this technology be researched?"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force this technology blongs to."
      },
      "level": {
        "name": "level",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The current level of this technology."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of this technology."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this technology."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string for this prototype."
      },
      "prerequisites": {
        "name": "prerequisites",
        "type": "dictionary string → LuaTechnology",
        "mode": "[Read-only]",
        "doc": "Prerequisites of this technology. The result maps technology name to the LuaTechnologyobject."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaTechnologyPrototype",
        "mode": "[Read-only]",
        "doc": "The prototype of this technology."
      },
      "reload": {
        "name": "reload()",
        "args": {},
        "doc": "Reload this technology from its prototype.",
        "type": "function"
      },
      "research_unit_count": {
        "name": "research_unit_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of research units required for this technology. \nSee also * LuaTechnology::research_unit_ingredients"
      },
      "research_unit_count_formula": {
        "name": "research_unit_count_formula",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The count forumula used for this infinite research or nil if this isn't an infinite research."
      },
      "research_unit_energy": {
        "name": "research_unit_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of energy required to finish a unit of research."
      },
      "research_unit_ingredients": {
        "name": "research_unit_ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients labs will require to research this technology. \nSee also * LuaTechnology::research_unit_count"
      },
      "researched": {
        "name": "researched",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Has this technology been researched? Switching from false to true will trigger the technology advancement perks; switching from true to false will reverse them."
      },
      "upgrade": {
        "name": "upgrade",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this an upgrade-type research?"
      }
    }
  },
  "LuaStyle": {
    "name": "LuaStyle",
    "type": "LuaStyle",
    "doc": "Style of a GUI element. All of the attributes listed here may be nil if not available for a\n particular GUI element.",
    "properties": {
      "bottom_padding": {
        "name": "bottom_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "cell_spacing": {
        "name": "cell_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Space between the table cell contents and border. \nCan only be used if this is LuaTableStyle"
      },
      "clicked_font_color": {
        "name": "clicked_font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "column_alignments": {
        "name": "column_alignments",
        "type": "custom array of Alignment",
        "mode": "[Read-only]",
        "doc": "Alignments of columns of the table"
      },
      "diode_count": {
        "name": "diode_count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaProgressBarStyle"
      },
      "disabled_font_color": {
        "name": "disabled_font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "font": {
        "name": "font",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "font_color": {
        "name": "font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[Read-only]",
        "doc": "Gui of the LuaGuiElement of this style."
      },
      "horizontal_scrollbar_spacing": {
        "name": "horizontal_scrollbar_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaScrollPaneStyle"
      },
      "horizontal_spacing": {
        "name": "horizontal_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Horizontal space between individual cells. \nCan only be used if this is LuaTableStyle"
      },
      "hovered_font_color": {
        "name": "hovered_font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "left_padding": {
        "name": "left_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "max_on_row": {
        "name": "max_on_row",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFlowStyle"
      },
      "maximal_height": {
        "name": "maximal_height",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "maximal_width": {
        "name": "maximal_width",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "minimal_height": {
        "name": "minimal_height",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "minimal_width": {
        "name": "minimal_width",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this style."
      },
      "pie_progress_color": {
        "name": "pie_progress_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "resize_row_to_width": {
        "name": "resize_row_to_width",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "resize_to_row_height": {
        "name": "resize_to_row_height",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "right_padding": {
        "name": "right_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "selection_background_color": {
        "name": "selection_background_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The background color when selecting text. \nCan only be used if this is LuaTextFieldStyle"
      },
      "smooth_color": {
        "name": "smooth_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaProgressBarStyle"
      },
      "smooth_size": {
        "name": "smooth_size",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaProgressBarStyle"
      },
      "title_bottom_padding": {
        "name": "title_bottom_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "title_left_padding": {
        "name": "title_left_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "title_right_padding": {
        "name": "title_right_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "title_top_padding": {
        "name": "title_top_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "top_padding": {
        "name": "top_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "vertical_scrollbar_spacing": {
        "name": "vertical_scrollbar_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaScrollPaneStyle"
      },
      "vertical_spacing": {
        "name": "vertical_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Vertical space between individual cells. \nCan only be used if this is LuaTableStyle"
      },
      "visible": {
        "name": "visible",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When not visible the GUI element is hidden completely and takes no space in the layout."
      }
    }
  },
  "LuaSettings": {
    "name": "LuaSettings",
    "type": "LuaSettings",
    "properties": {
      "get_player_settings": {
        "name": "get_player_settings(LuaPlayer)",
        "args": {
          "LuaPlayer": {
            "name": "LuaPlayer",
            "type": "LuaPlayer"
          }
        },
        "doc": "Parameter\n\nNote:",
        "type": "function"
      },
      "global": {
        "name": "global",
        "type": "custom dictionary string → ModSetting",
        "mode": "[Read-only]",
        "doc": ""
      },
      "player": {
        "name": "player",
        "type": "custom dictionary string → ModSetting",
        "mode": "[Read-only]",
        "doc": ""
      },
      "startup": {
        "name": "startup",
        "type": "custom dictionary string → ModSetting",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaSurface": {
    "name": "LuaSurface",
    "type": "LuaSurface",
    "doc": "A \"domain\" of the world. Surfaces can only be created through the API and can not be\n deleted. However, it is planned to allow deletion of a surface in the future. Surfaces\n are uniquely identified by their name. Every game contains at least the surface \"nauvis\".",
    "properties": {
      "always_day": {
        "name": "always_day",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When set to true, the sun will always shine."
      },
      "build_enemy_base": {
        "name": "build_enemy_base(position, unit_count, force)",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce (optional): Force the new base will belong to. Defaults to enemy.",
            "name": "force",
            "type": "string or LuaForce"
          },
          "position": {
            "doc": "position :: Position: Location of the new base.",
            "name": "position",
            "type": "Position"
          },
          "unit_count": {
            "doc": "unit_count :: uint: Number of biters to send for the base-building task.",
            "name": "unit_count",
            "type": "uint"
          }
        },
        "doc": "Send a group to build a new base\n\nParameters\n\nposition :: Position: Location of the new base.unit_count :: uint: Number of biters to send for the base-building task.force :: string or LuaForce (optional): Force the new base will belong to. Defaults to enemy\n\nNote: The specified force must be AI-controlled; i.e. force.ai_controllable must be true.",
        "type": "function"
      },
      "can_place_entity": {
        "name": "can_place_entity{name=…, position=…, direction=…, force=…} → boolean",
        "returns": "boolean",
        "args": {
          "direction=…": {
            "name": "direction=…",
            "type": "direction=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "name": {
            "doc": "Table with the following fields:  * name :: string: Name of the entity to check\n * position :: Position: Where the entity would be placed\n * direction :: defines.direction (optional): Direction the entity would be placed\n * force :: string or LuaForce (optional): The force that would place the entity. If not specified, the enemy force is assumed.",
            "name": "name",
            "type": "string"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Check for collisions with terrain or other entities\n\nParameters\n\n Table with the following fields:  * name :: string: Name of the entity to check\n * position :: Position: Where the entity would be placed\n * direction :: defines.direction (optional): Direction the entity would be placed\n * force :: string or LuaForce (optional): The force that would place the entity. If not specified, the enemy force is assumed.",
        "type": "function"
      },
      "cancel_deconstruct_area": {
        "name": "cancel_deconstruct_area{area=…, force=…}",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox: The are to cancel deconstruction orders in.\n * force :: string or LuaForce: The force whose deconstruction orders to cancel.",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Cancel a deconstruction order. \n\nParameters\n\n Table with the following fields:  * area :: BoundingBox: The are to cancel deconstruction orders in.\n * force :: string or LuaForce: The force whose deconstruction orders to cancel.",
        "type": "function"
      },
      "count_entities_filtered": {
        "name": "count_entities_filtered{area=…, position=…, name=…, type=…, force=…, limit=…} → uint",
        "returns": "uint",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox (optional): Search area. If not given and position is not given then the entire surface is searched.\n * position :: Position (optional): Search position. if not given and area is not given the entire surface is searched. If both area and position are given position is used.\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "limit=…": {
            "name": "limit=…",
            "type": "limit=…"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          }
        },
        "doc": "Count entities of given type or name in a given area. Works just like LuaSurface::find_entities_filtered, except this only returns the count. As it doesn't construct all the wrapper objects, this is more efficient if one is only interested in the number of entities\n\nParameters\n\n Table with the following fields:  * area :: BoundingBox (optional): Search area. If not given and position is not given then the entire surface is searched.\n * position :: Position (optional): Search position. if not given and area is not given the entire surface is searched. If both area and position are given position is used.\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)",
        "type": "function"
      },
      "create_decoratives": {
        "name": "create_decoratives{check_collision=…, decoratives=…}",
        "args": {
          "check_collision": {
            "doc": "Table with the following fields:  * check_collision :: boolean (optional): If collision should be checked against entities/tiles.\n * decoratives :: array of Decorative",
            "name": "check_collision",
            "type": "boolean"
          },
          "check_collision=…": {
            "name": "check_collision=…",
            "type": "check_collision=…"
          },
          "decoratives=…": {
            "name": "decoratives=…",
            "type": "decoratives=…"
          }
        },
        "doc": "Adds the given decoratives to the surface. \n Each Decorative is \n * name :: string\n * position :: Position\n * amount :: uint\n\nParameters\n\n Table with the following fields:  * check_collision :: boolean (optional): If collision should be checked against entities/tiles.\n * decoratives :: array of Decorativ\n\nNote: This will merge decoratives of the same type that alreaday exist effectivly increasing the \"amount\" field.",
        "type": "function"
      },
      "create_entity": {
        "name": "create_entity{name=…, position=…, direction=…, force=…, target=…, source=…, fast_replace=…, player=…, spill=…} → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "direction=…": {
            "name": "direction=…",
            "type": "direction=…"
          },
          "fast_replace=…": {
            "name": "fast_replace=…",
            "type": "fast_replace=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "name": {
            "doc": "Table with the following fields:  * name :: string: The entity prototype name to create.\n * position :: Position: Where to create the entity.\n * direction :: defines.direction (optional): Desired orientation of the entity after creation.\n * force :: string or LuaForce (optional): Force of the entity, default is enemy.\n * target :: LuaEntity (optional): Entity with health for the new entity to target.\n * source :: LuaEntity (optional): Source entity. Used for beams.\n * fast_replace :: boolean (optional): If true, building will attempt to simulate fast-replace building.\n * player :: PlayerSpecification (optional): If given along with fast_replace being true, fast-replace will simulate using this player.\n * spill :: boolean (optional): If false while fast_replace is true any excess items from fast-replacing will be deleted instead of dropped on the ground.\n * Additional entity-specific parameters * assembling-machine * recipe :: string (optional)\n      \n      \n    * container * bar :: uint (optional): Inventory index where the red limiting bar should be set.\n      \n      \n    * flying-text * text :: string: The string to show.\n       * color :: Color: Color of the displayed text.\n      \n      \n    * entity-ghost * inner_name :: string: The prototype name of the entity contained in the ghost.\n       * expires :: boolean (optional): If false the ghost entity will not expire. Default is true.\n      \n      \n    * fire * initial_ground_flame_count :: uint: With how many small flames should the fire on ground be created.\n      \n      \n    * inserter * conditions: Table with the following fields:  * circuit :: CircuitCondition (optional)\n          * logistics :: CircuitCondition (optional)\n         \n         \n       * filters :: array of Filter\n      \n      \n    * item-entity * stack :: SimpleItemStack: The stack of items to create. This must be a table, i.e. a single string is not allowed here.\n      \n      \n    * item-request-proxy * modules :: dictionary string → uint: The stacks of items to be delivered to target entity from logistic network. Each stack must be table. If empty, the item request proxy won't be created.\n      \n      \n    * logistic-container * request_filters :: array of Filter (optional)\n      \n      \n    * particle * movement :: Vector\n       * height :: float\n       * vertical_speed :: float\n       * frame_speed :: float\n      \n      \n    * projectile * speed :: double\n      \n      \n    * resource * amount :: uint\n      \n      \n    * underground-belt * type :: string (optional): \"output\" or \"input\"; default is \"input\".\n      \n      \n    * programmable-speaker * parameters :: ProgrammableSpeakerParameters (optional)\n       * alert_parameters :: ProgrammableSpeakerAlertParameters (optional)\n      \n      \n    * character-corpse * inventory_size :: uint (optional)\n       * player_index :: uint (optional)",
            "name": "name",
            "type": "string"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "player=…": {
            "name": "player=…",
            "type": "player=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "source=…": {
            "name": "source=…",
            "type": "source=…"
          },
          "spill=…": {
            "name": "spill=…",
            "type": "spill=…"
          },
          "target=…": {
            "name": "target=…",
            "type": "target=…"
          }
        },
        "doc": "Create an entity on this surface\n\nParameters\n\n Table with the following fields:  * name :: string: The entity prototype name to create.\n * position :: Position: Where to create the entity.\n * direction :: defines.direction (optional): Desired orientation of the entity after creation.\n * force :: string or LuaForce (optional): Force of the entity, default is enemy.\n * target :: LuaEntity (optional): Entity with health for the new entity to target.\n * source :: LuaEntity (optional): Source entity. Used for beams.\n * fast_replace :: boolean (optional): If true, building will attempt to simulate fast-replace building.\n * player :: PlayerSpecification (optional): If given along with fast_replace being true, fast-replace will simulate using this player.\n * spill :: boolean (optional): If false while fast_replace is true any excess items from fast-replacing will be deleted instead of dropped on the ground.\n * Additional entity-specific parameters * assembling-machine * recipe :: string (optional)\n    * container * bar :: uint (optional): Inventory index where the red limiting bar should be set.\n    * flying-text * text :: string: The string to show.\n       * color :: Color: Color of the displayed text.\n    * entity-ghost * inner_name :: string: The prototype name of the entity contained in the ghost.\n       * expires :: boolean (optional): If false the ghost entity will not expire. Default is true.\n    * fire * initial_ground_flame_count :: uint: With how many small flames should the fire on ground be created.\n    * inserter * conditions: Table with the following fields:  * circuit :: CircuitCondition (optional)\n          * logistics :: CircuitCondition (optional)\n       * filters :: array of Filter\n    * item-entity * stack :: SimpleItemStack: The stack of items to create. This must be a table, i.e. a single string is not allowed here.\n    * item-request-proxy * modules :: dictionary string → uint: The stacks of items to be delivered to target entity from logistic network. Each stack must be table. If empty, the item request proxy won't be created.\n    * logistic-container * request_filters :: array of Filter (optional)\n    * particle * movement :: Vector\n       * height :: float\n       * vertical_speed :: float\n       * frame_speed :: float\n    * projectile * speed :: double\n    * resource * amount :: uint\n    * underground-belt * type :: string (optional): \"output\" or \"input\"; default is \"input\".\n    * programmable-speaker * parameters :: ProgrammableSpeake\n\nParameters\n\n (optional)\n       * alert_parameters :: ProgrammableSpeakerAler\n\nParameters\n\n (optional)\n    * character-corpse * inventory_size :: uint (optional)\n       * player_index :: uint (optional)\nReturn value The created entity or nil if the creation failed.Example asm = game.surfaces[1].create_entity{name = \"assembling-machine-1\", position = {15, 3}, force=game.forces.player, recipe = \"iron-stick\"} ExampleCreates a smart inserter with circuit conditions and a filter game.surfaces[1].create_entity{\nname = \"filter-inserter\", position = {20, 15}, force=game.player.force,\nconditions={red={name=\"wood\", count=3, operator=\">\"},\ngreen={name=\"iron-ore\", count=1, operator=\" logistics={name=\"wood\", count=3, operator=\"=\"}},\nfilters={ {index=1, name=\"iron-ore\"} }\n} ExampleCreates a requester chest already set to request 128 iron plates. game.surfaces[1].create_entity{\nname = \"logistic-chest-requester\", position = {game.player.position.x+3, game.player.position.y},\nforce=game.player.force, request_filters={ {index=1, name=\"iron-plate\", count=128} }\n} Example game.surfaces[1].create_entity{name = \"big-biter\", position= {15, 3}, force = game.forces.player} -- Friendly biter\ngame.surfaces[1].create_entity{name = \"medium-biter\", position= {15, 3}, force = game.forces.enemy} -- Enemy biter ExampleCreates a basic inserter at the player's location facing north game.surfaces[1].create_entity{name = \"inserter\", position = game.player.position, direction = defines.direction.north}",
        "type": "function"
      },
      "create_unit_group": {
        "name": "create_unit_group{position=…, force=…} → LuaUnitGroup",
        "returns": "LuaUnitGroup",
        "args": {
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "position": {
            "doc": "Table with the following fields:  * position :: Position: Initial position of the new unit group.\n * force :: string or LuaForce (optional): Force of the new unit group. Defaults to \"enemy\".",
            "name": "position",
            "type": "Position"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Create a new unit group at a given position\n\nParameters\n\n Table with the following fields:  * position :: Position: Initial position of the new unit group.\n * force :: string or LuaForce (optional): Force of the new unit group. Defaults to \"enemy\".",
        "type": "function"
      },
      "darkness": {
        "name": "darkness",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Amount of darkness at the current time."
      },
      "daytime": {
        "name": "daytime",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Current time of day, as a number in range [0, 1)."
      },
      "deconstruct_area": {
        "name": "deconstruct_area{area=…, force=…}",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox: The area to mark for deconstruction\n * force :: string or LuaForce: The force whose bots should perform the deconstruction.",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Place a deconstruction request. \n\nParameters\n\n Table with the following fields:  * area :: BoundingBox: The area to mark for deconstruction\n * force :: string or LuaForce: The force whose bots should perform the deconstruction.",
        "type": "function"
      },
      "delete_chunk": {
        "name": "delete_chunk(position)",
        "args": {
          "position": {
            "doc": "position :: Position: The chunk position to delete",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Parametersposition :: Position: The chunk position to delet\n\nNote: This won't delete the chunk immediately. Chunks are deleted at the end of the current tick.",
        "type": "function"
      },
      "destroy_decoratives": {
        "name": "destroy_decoratives(area)",
        "args": {
          "area": {
            "doc": "area :: BoundingBox",
            "name": "area",
            "type": "BoundingBox"
          }
        },
        "doc": "Removes all decoratives from the given area. \n\nParameters\n\narea :: BoundingBox",
        "type": "function"
      },
      "find_enemy_units": {
        "name": "find_enemy_units(center, radius, force) → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "center": {
            "doc": "center :: Position: Center of the search area",
            "name": "center",
            "type": "Position"
          },
          "force": {
            "doc": "force :: LuaForce or string (optional): Force to find enemies of. If not given, uses the player force.",
            "name": "force",
            "type": "LuaForce or string"
          },
          "radius": {
            "doc": "radius :: double: Radius of the circular search area",
            "name": "radius",
            "type": "double"
          }
        },
        "doc": "Find units enemy of a given force within an area\n\nParameters\n\ncenter :: Position: Center of the search arearadius :: double: Radius of the circular search areaforce :: LuaForce or string (optional): Force to find enemies of. If not given, uses the player force\n\nNote: This is more efficient than LuaSurface::find_entities.ExampleFind all entities who would be interested to attack the player, within 100-tile area. local enemies = game.player.surface.find_enemy_units(game.player.character.position, 100)",
        "type": "function"
      },
      "find_entities_filtered": {
        "name": "find_entities_filtered{area=…, position=…, name=…, type=…, force=…, limit=…} → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox (optional): Search area. If not given and position is not given then the entire surface is searched.\n * position :: Position (optional): Search position. if not given and area is not given the entire surface is searched. If both area and position are given position is used.\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "limit=…": {
            "name": "limit=…",
            "type": "limit=…"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          }
        },
        "doc": "Find entities of given type or name in a given area.\n If no filters (name, type, or force) are given, returns all entities in the search area. If multiple filters are specified, returns only entities matching all given filters\n\nParameters\n\n Table with the following fields:  * area :: BoundingBox (optional): Search area. If not given and position is not given then the entire surface is searched.\n * position :: Position (optional): Search position. if not given and area is not given the entire surface is searched. If both area and position are given position is used.\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)\nExample game.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, type= \"resource\"} -- gets all resources in the rectangle\ngame.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, name= \"iron-ore\"} -- gets all iron ores in the rectangle\ngame.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, force= \"player\"} -- gets player owned entities in the rectangle\ngame.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, limit= 5} -- gets the first 5 entities in the rectangle",
        "type": "function"
      },
      "find_entities": {
        "name": "find_entities(area) → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "area": {
            "doc": "area :: BoundingBox (optional): Where to search. If not given all entities on the surface are returned.",
            "name": "area",
            "type": "BoundingBox"
          }
        },
        "doc": "Find entities in a given area\n\nParameters\n\narea :: BoundingBox (optional): Where to search. If not given all entities on the surface are returned.ExampleWill evaluate to a list of all entities within given area. game.surfaces[\"nauvis\"].find_entities({{-10, -10}, {10, 10}})",
        "type": "function"
      },
      "find_entity": {
        "name": "find_entity(entity, position) → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "entity": {
            "doc": "entity :: string: Entity to look for",
            "name": "entity",
            "type": "string"
          },
          "position": {
            "doc": "position :: Position: Coordinates to look at",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find a specific entity at a specific position\n\nParameters\n\nentity :: string: Entity to look forposition :: Position: Coordinates to look atReturn value Will be nil if no such entity is found.Example game.player.selected.surface.find_entity('filter-inserter',{0,0})",
        "type": "function"
      },
      "find_logistic_network_by_position": {
        "name": "find_logistic_network_by_position(position, force) → LuaLogisticNetwork",
        "returns": "LuaLogisticNetwork",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: Force the logistic network should belong to.",
            "name": "force",
            "type": "string or LuaForce"
          },
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find the logistic network that covers a given position\n\nParameters\n\nposition :: Positionforce :: string or LuaForce: Force the logistic network should belong to.Return value The found network or nil if no such network was found.",
        "type": "function"
      },
      "find_logistic_networks_by_construction_area": {
        "name": "find_logistic_networks_by_construction_area(position, force) → array of LuaLogisticNetwork",
        "returns": "array of LuaLogisticNetwork",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: Force the logistic networks should belong to.",
            "name": "force",
            "type": "string or LuaForce"
          },
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Finds all of the logistics networks whos construction area intersects with the given position\n\nParameters\n\nposition :: Positionforce :: string or LuaForce: Force the logistic networks should belong to.",
        "type": "function"
      },
      "find_nearest_enemy": {
        "name": "find_nearest_enemy{position=…, max_distance=…, force=…} → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "max_distance=…": {
            "name": "max_distance=…",
            "type": "max_distance=…"
          },
          "position": {
            "doc": "Table with the following fields:  * position :: Position: Center of the search area.\n * max_distance :: double: Radius of the circular search area.\n * force :: string or LuaForce (optional): The force the result will be an enemy of. Uses the player force if not specified.",
            "name": "position",
            "type": "Position"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Find the enemy closest to the given position\n\nParameters\n\n Table with the following fields:  * position :: Position: Center of the search area.\n * max_distance :: double: Radius of the circular search area.\n * force :: string or LuaForce (optional): The force the result will be an enemy of. Uses the player force if not specified.\nReturn value The nearest enemy unit or nil if no enemy could be found within the given area.",
        "type": "function"
      },
      "find_non_colliding_position": {
        "name": "find_non_colliding_position(name, center, radius, precision) → Position",
        "returns": "Position",
        "args": {
          "center": {
            "doc": "center :: Position: Center of the search area.",
            "name": "center",
            "type": "Position"
          },
          "name": {
            "doc": "name :: string: Prototype name of the entity to find a position for. (The bounding box for the collision checking is taken from this prototype.)",
            "name": "name",
            "type": "string"
          },
          "precision": {
            "doc": "precision :: double: The step length from the given position as it searches, in tiles.",
            "name": "precision",
            "type": "double"
          },
          "radius": {
            "doc": "radius :: double: Max distance from center to search in. 0 for infinitely-large search area.",
            "name": "radius",
            "type": "double"
          }
        },
        "doc": "Find a non-colliding possition within a given rectangle\n\nParameters\n\nname :: string: Prototype name of the entity to find a position for. (The bounding box for the collision checking is taken from this prototype.)center :: Position: Center of the search area.radius :: double: Max distance from center to search in. 0 for infinitely-large search area.precision :: double: The step length from the given position as it searches, in tiles.Return value The non-colliding position. May be nil if no suitable position was found.",
        "type": "function"
      },
      "freeze_daytime": {
        "name": "freeze_daytime",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "True if daytime is currently frozen."
      },
      "get_chunks": {
        "name": "get_chunks() → LuaChunkIterator",
        "returns": "LuaChunkIterator",
        "args": {},
        "doc": "Get an iterator going over every chunk on this surface.",
        "type": "function"
      },
      "get_connected_tiles": {
        "name": "get_connected_tiles(position, tiles) → array of Position",
        "returns": "array of Position",
        "args": {
          "position": {
            "doc": "position :: Position: The tile position to start at.",
            "name": "position",
            "type": "Position"
          },
          "tiles": {
            "doc": "tiles :: array of string: The tiles to search for.",
            "name": "tiles",
            "type": "array of string"
          }
        },
        "doc": "Gets all tiles of the given types that are connected horizontally or vertically to the given tile position including the given tile position. \n\nParameters\n\nposition :: Position: The tile position to start at.tiles :: array of string: The tiles to search for.Return value The resulting set of tiles\n\nNote: This won't find tiles in non-generated chunks.",
        "type": "function"
      },
      "get_hidden_tile": {
        "name": "get_hidden_tile(position)",
        "args": {
          "position": {
            "doc": "position :: Position: The tile position.",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "The hidden tile name or nil if there isn't one for the given position\n\nParameters\n\nposition :: Position: The tile position.",
        "type": "function"
      },
      "get_pollution": {
        "name": "get_pollution(position) → double",
        "returns": "double",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Get the pollution for a given position\n\nParameters\n\nposition :: PositionExample game.surfaces[1].get_pollution({1,2})",
        "type": "function"
      },
      "get_tile": {
        "name": "get_tile(x, y) → LuaTile",
        "returns": "LuaTile",
        "args": {
          "x": {
            "doc": "x :: int",
            "name": "x",
            "type": "int"
          },
          "y": {
            "doc": "y :: int",
            "name": "y",
            "type": "int"
          }
        },
        "doc": "Get the tile at a given position\n\nParameters\n\nx :: inty :: in\n\nNote: The input position params can also be a single tile position.",
        "type": "function"
      },
      "get_trains": {
        "name": "get_trains(force) → array of LuaTrain",
        "returns": "array of LuaTrain",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce (optional): If given only trains matching this force are returned.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Parametersforce :: string or LuaForce (optional): If given only trains matching this force are returned.",
        "type": "function"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Unique ID associated with this surface."
      },
      "is_chunk_generated": {
        "name": "is_chunk_generated(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: ChunkPosition: The chunk's position.",
            "name": "position",
            "type": "ChunkPosition"
          }
        },
        "doc": "Is a given chunk generated\n\nParameters\n\nposition :: ChunkPosition: The chunk's position.",
        "type": "function"
      },
      "map_gen_settings": {
        "name": "map_gen_settings",
        "type": "MapGenSettings",
        "mode": "[Read-only]",
        "doc": "Gets the generation settings for the surface."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The name of this surface. Names are unique among surfaces."
      },
      "peaceful_mode": {
        "name": "peaceful_mode",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Is peaceful mode enabled on this surface?"
      },
      "pollute": {
        "name": "pollute(source, amount)",
        "args": {
          "amount": {
            "doc": "amount :: double: How much pollution to add.",
            "name": "amount",
            "type": "double"
          },
          "source": {
            "doc": "source :: Position: Where to spawn the pollution.",
            "name": "source",
            "type": "Position"
          }
        },
        "doc": "Spawn pollution at the given position\n\nParameters\n\nsource :: Position: Where to spawn the pollution.amount :: double: How much pollution to add.",
        "type": "function"
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console of all players on this surface\n\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "regenerate_decorative": {
        "name": "regenerate_decorative(decoratives, chunks)",
        "args": {
          "chunks": {
            "doc": "chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored.",
            "name": "chunks",
            "type": "array of Position"
          },
          "decoratives": {
            "doc": "decoratives :: string or array of string: Prototype names of decorative or decoratives to autoplace.",
            "name": "decoratives",
            "type": "string or array of string"
          }
        },
        "doc": "Regenerate autoplacement of some decoratives on this surface. This can be used to autoplace newly-added decoratives\n\nParameters\n\ndecoratives :: string or array of string: Prototype names of decorative or decoratives to autoplace.chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored\n\nNote: All specified decorative prototypes must be autoplacable.",
        "type": "function"
      },
      "regenerate_entity": {
        "name": "regenerate_entity(entitites, chunks)",
        "args": {
          "chunks": {
            "doc": "chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored.",
            "name": "chunks",
            "type": "array of Position"
          },
          "entitites": {
            "doc": "entitites :: string or array of string: Prototype names of entity or entities to autoplace.",
            "name": "entitites",
            "type": "string or array of string"
          }
        },
        "doc": "Regenerate autoplacement of some entities on this surface. This can be used to autoplace newly-added entities\n\nParameters\n\nentitites :: string or array of string: Prototype names of entity or entities to autoplace.chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored\n\nNote: All specified entity prototypes must be autoplacable.",
        "type": "function"
      },
      "request_to_generate_chunks": {
        "name": "request_to_generate_chunks(position, radius)",
        "args": {
          "position": {
            "doc": "position :: Position: Where to generate the new chunks.",
            "name": "position",
            "type": "Position"
          },
          "radius": {
            "doc": "radius :: uint: Radius from position to generate new chunks in.",
            "name": "radius",
            "type": "uint"
          }
        },
        "doc": "Request that the game's map generator generate chunks at the given position for the given radius on this surface\n\nParameters\n\nposition :: Position: Where to generate the new chunks.radius :: uint: Radius from position to generate new chunks in.",
        "type": "function"
      },
      "set_chunk_generated_status": {
        "name": "set_chunk_generated_status(position, status)",
        "args": {
          "position": {
            "doc": "position :: Position: The chunk's position.",
            "name": "position",
            "type": "Position"
          },
          "status": {
            "doc": "status :: defines.chunk_generated_status: The chunk's new status.",
            "name": "status",
            "type": "defines.chunk_generated_status"
          }
        },
        "doc": "Set generated status of a chunk. Useful when copying chunks\n\nParameters\n\nposition :: Position: The chunk's position.status :: defines.chunk_generated_status: The chunk's new status.",
        "type": "function"
      },
      "set_multi_command": {
        "name": "set_multi_command{command=…, unit_count=…, force=…, unit_search_distance=…} → uint",
        "returns": "uint",
        "args": {
          "command": {
            "doc": "Table with the following fields:  * command :: Command\n * unit_count :: uint: Number of units to give the command to.\n * force :: string or LuaForce (optional): Force of the units this command is to be given to. If not specified, uses the enemy force.\n * unit_search_distance :: uint (optional): Radius to search for units. The search area is centered on the destination of the command.",
            "name": "command",
            "type": "Command"
          },
          "command=…": {
            "name": "command=…",
            "type": "command=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "unit_count=…": {
            "name": "unit_count=…",
            "type": "unit_count=…"
          },
          "unit_search_distance=…": {
            "name": "unit_search_distance=…",
            "type": "unit_search_distance=…"
          }
        },
        "doc": "Give a command to multiple units. This will automatically select suitable units for the task\n\nParameters\n\n Table with the following fields:  * command :: Command\n * unit_count :: uint: Number of units to give the command to.\n * force :: string or LuaForce (optional): Force of the units this command is to be given to. If not specified, uses the enemy force.\n * unit_search_distance :: uint (optional): Radius to search for units. The search area is centered on the destination of the command.\nReturn value Number of units actually sent. May be less than count if not enough units were available.",
        "type": "function"
      },
      "set_tiles": {
        "name": "set_tiles(tiles, correct_tiles)",
        "args": {
          "correct_tiles": {
            "doc": "correct_tiles :: boolean (optional): If false, the correction logic is not done on the changed tiles. Defaults to true.",
            "name": "correct_tiles",
            "type": "boolean"
          },
          "tiles": {
            "doc": "tiles :: array of Tile: Each Tile is a table:  * name :: string\n * position :: Position",
            "name": "tiles",
            "type": "array of Tile"
          }
        },
        "doc": "Set tiles at specified locations. Automatically corrects the edges around modified tiles\n\nParameters\n\ntiles :: array of Tile: Each Tile is a table:  * name :: string\n * position :: Position\ncorrect_tiles :: boolean (optional): If false, the correction logic is not done on the changed tiles. Defaults to true\n\nNote: It is recommended to call this method once for all the tiles you want to change rather than calling it individually for every tile. As the tile correction is used after every step, calling it one by one could cause the tile correction logic to redo some of the changes, and it is also much performance heavy.",
        "type": "function"
      },
      "spill_item_stack": {
        "name": "spill_item_stack(position, items, enable_looted)",
        "args": {
          "enable_looted": {
            "doc": "enable_looted :: boolean (optional): When true, each created item will be flagged with the LuaEntity::to_be_looted flag.",
            "name": "enable_looted",
            "type": "boolean"
          },
          "items": {
            "doc": "items :: LuaItemStack or SimpleItemStack: Items to spill",
            "name": "items",
            "type": "LuaItemStack or SimpleItemStack"
          },
          "position": {
            "doc": "position :: Position: Center of the spillage",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Spill items on the ground centered at a given location\n\nParameters\n\nposition :: Position: Center of the spillageitems :: LuaItemStack or SimpleItemStack: Items to spillenable_looted :: boolean (optional): When true, each created item will be flagged with the LuaEntity::to_be_looted flag.",
        "type": "function"
      },
      "wind_orientation": {
        "name": "wind_orientation",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Current wind direction."
      },
      "wind_orientation_change": {
        "name": "wind_orientation_change",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Change in wind orientation per tick."
      },
      "wind_speed": {
        "name": "wind_speed",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Current wind speed."
      }
    }
  },
  "LuaRecipePrototype": {
    "name": "LuaRecipePrototype",
    "type": "LuaRecipePrototype",
    "doc": "A crafting recipe prototype.",
    "properties": {
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Category of the recipe."
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this recipe prototype is enabled by default (enabled at the begining of a game)."
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Energy required to execute this recipe. This directly affects the crafting time: Recipe's energy is exactly its crafting time in seconds, when crafted in an assembling machine with crafting speed exactly equal to one."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this recipe."
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is the recipe hidden? Hidden recipe don't show up in the crafting menu."
      },
      "ingredients": {
        "name": "ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients for this recipe."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the recipe."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the recipe. This can be different than the name of the result items as there could be more recipes to make the same item."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string. This is used to sort the crafting menu."
      },
      "overload_multiplier": {
        "name": "overload_multiplier",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Used to determine how many extra items are put into an assembling machine before it's considered \"full enough\"."
      },
      "products": {
        "name": "products",
        "type": "array of Product",
        "mode": "[Read-only]",
        "doc": "The results of this recipe."
      },
      "request_paste_multiplier": {
        "name": "request_paste_multiplier",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The multiplier used when this recipe is copied from an assembling machine to a requester chest. For each item in the recipe the item count * this value is set in the requester chest."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this recipe."
      }
    }
  },
  "LuaRemote": {
    "name": "LuaRemote",
    "type": "LuaRemote",
    "doc": "Registry of interfaces between scripts. An interface is simply a dictionary mapping names to functions. A\n script or mod can then register an interface with LuaRemote, after that any script can call the\n registered functions, provided it knows the interface name and the desired function name. An instance of\n LuaRemote is available through the global object named remote.",
    "properties": {
      "add_interface": {
        "name": "add_interface(name, functions)",
        "args": {
          "functions": {
            "doc": "functions :: dictionary string → function: List of functions that are members of the new interface.",
            "name": "functions",
            "type": "dictionary string → function"
          },
          "name": {
            "doc": "name :: string: Name of the interface.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Add a remote interface\n\nParameters\n\nname :: string: Name of the interface.functions :: dictionary string → function: List of functions that are members of the new interface\n\nNote: It is an error if the given interface name is already registered.",
        "type": "function"
      },
      "call": {
        "name": "call(interface, function, ...)",
        "args": {
          "...": {
            "doc": "...: Arguments to pass to the called function.",
            "name": "..."
          },
          "function": {
            "doc": "function :: string: Function name that belongs to interface.",
            "name": "function",
            "type": "string"
          },
          "interface": {
            "doc": "interface :: string: Interface to look up function in.",
            "name": "interface",
            "type": "string"
          }
        },
        "doc": "Call a function of an interface\n\nParameters\n\ninterface :: string: Interface to look up function in.function :: string: Function name that belongs to interface....: Arguments to pass to the called function.",
        "type": "function"
      },
      "interfaces": {
        "name": "interfaces",
        "type": "dictionary string → dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "List of all registered interfaces. For each interface name, remote.interfaces[name] is a dictionary mapping the interface's registered functions to the value true.\nExampleAssuming the \"human interactor\" interface is registered as above game.player.print(tostring(remote.interfaces[\"human interactor\"][\"hello\"])) -- prints true\ngame.player.print(tostring(remote.interfaces[\"human interactor\"][\"nonexistent\"])) -- prints nil"
      },
      "remove_interface": {
        "name": "remove_interface(name) → boolean",
        "returns": "boolean",
        "args": {
          "name": {
            "doc": "name :: string: Name of the interface.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Removes an interface with the given name. \n\nParameters\n\nname :: string: Name of the interface.Return value If the interface was removed. False if the interface didn't exist.",
        "type": "function"
      }
    }
  },
  "LuaRecipe": {
    "name": "LuaRecipe",
    "type": "LuaRecipe",
    "doc": "A crafting recipe. Recipes belong to forces (see LuaForce) because some recipes\n are unlocked by research, and researches are per-force.",
    "properties": {
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Category of the recipe."
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Can the recipe be used?"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Energy required to execute this recipe. This directly affects the crafting time: Recipe's energy is exactly its crafting time in seconds, when crafted in an assembling machine with crafting speed exactly equal to one."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force that owns this recipe."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this recipe."
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is the recipe hidden? Hidden recipe don't show up in the crafting menu."
      },
      "ingredients": {
        "name": "ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients for this recipe. \nExampleWhat the \"steel-chest\" recipe would return { {type=\"item\", name=\"steel-plate\", amount=8} } ExampleWhat the \"advanced-oil-processing\" recipe would return { {type=\"fluid\", name=\"crude-oil\", amount=10}, {type=\"fluid\", name=\"water\", amount=5} }"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the recipe."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the recipe. This can be different than the name of the result items as there could be more recipes to make the same item."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string. This is used to sort the crafting menu."
      },
      "products": {
        "name": "products",
        "type": "array of Product",
        "mode": "[Read-only]",
        "doc": "The results of this recipe."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaRecipePrototype",
        "mode": "[Read-only]",
        "doc": "The prototype for this recipe."
      },
      "reload": {
        "name": "reload()",
        "args": {},
        "doc": "Reload the recipe from the prototype.",
        "type": "function"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this recipe."
      }
    }
  },
  "LuaRandomGenerator": {
    "name": "LuaRandomGenerator",
    "type": "LuaRandomGenerator",
    "doc": "A deterministic random generator independent from the core games random generator that can be seeded and re-seeded at will.\n This random generator can be saved and loaded and will maintain its state.\n Note this is entirely different from calling math.random(...) and you should be sure you actually want to use this over calling math.random(...).\n If you aren't sure if you need to use this over calling math.random(...) then you probably don't need to use this.",
    "properties": {
      "()": {
        "name": "operator ()(lower, upper) → double",
        "returns": "double",
        "args": {
          "lower": {
            "doc": "lower :: double (optional): Inclusive lower bound on the result",
            "name": "lower",
            "type": "double"
          },
          "upper": {
            "doc": "upper :: double (optional): Exclusive upper bound on the result",
            "name": "upper",
            "type": "double"
          }
        },
        "doc": "Generates a random number. If no parameters are given a number in the [0, 1) range is returned. If a single parameter is given a floored number in the [0, N) range is returned. If 2 parameters are given a floored number in the [N1, N2) range is returned. \n\nParameters\n\nlower :: double (optional): Inclusive lower bound on the resultupper :: double (optional): Exclusive upper bound on the result",
        "type": "function"
      },
      "re_seed": {
        "name": "re_seed(seed)",
        "args": {
          "seed": {
            "doc": "seed :: uint",
            "name": "seed",
            "type": "uint"
          }
        },
        "doc": "Re-seeds the random generator with the given value. \n\nParameters\n\nseed :: uint",
        "type": "function"
      }
    }
  },
  "LuaPlayer": {
    "name": "LuaPlayer",
    "type": "LuaPlayer",
    "doc": "A player in the game. Pay attention that a player may or may not have a character, which is the\n LuaEntity of the little guy running around the world doing things.",
    "properties": {
      "add_alert": {
        "name": "add_alert(entity, type)",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          },
          "type": {
            "doc": "type :: defines.alert_type",
            "name": "type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Adds an alert to this player for the given entity of the given alert type. \n\nParameters\n\nentity :: LuaEntitytype :: defines.alert_type",
        "type": "function"
      },
      "add_custom_alert": {
        "name": "add_custom_alert(entity, icon, message, show_on_map)",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          },
          "icon": {
            "doc": "icon :: SignalID",
            "name": "icon",
            "type": "SignalID"
          },
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          },
          "show_on_map": {
            "doc": "show_on_map :: boolean",
            "name": "show_on_map",
            "type": "boolean"
          }
        },
        "doc": "Adds a custom alert to this player. \n\nParameters\n\nentity :: LuaEntityicon :: SignalIDmessage :: LocalisedStringshow_on_map :: boolean",
        "type": "function"
      },
      "admin": {
        "name": "admin",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if the player is an admin."
      },
      "afk_time": {
        "name": "afk_time",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "How many ticks since the last action of this player"
      },
      "character": {
        "name": "character",
        "type": "LuaEntity",
        "mode": "[Read-Write]",
        "doc": "The character attached to this player, or nil if no character\n\nNote: It is not valid to access this attribute when the player is disconnected (see LuaPlayer::connected)."
      },
      "clean_cursor": {
        "name": "clean_cursor() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Invokes the \"clean cursor\" action on the player as if the user pressed it. \nReturn value If the cursor is now empty.",
        "type": "function"
      },
      "clear_console": {
        "name": "clear_console()",
        "args": {},
        "doc": "Clear the chat console.",
        "type": "function"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The colour associated with the player. This will be used to tint the player's character as well as their buildings and vehicles."
      },
      "connected": {
        "name": "connected",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if the player is currently connected to the game."
      },
      "controller_type": {
        "name": "controller_type",
        "type": "defines.controllers",
        "mode": "[Read-only]",
        "doc": ""
      },
      "create_character": {
        "name": "create_character(character)",
        "args": {
          "character": {
            "doc": "character :: string (optional): The character to create else the default is used.",
            "name": "character",
            "type": "string"
          }
        },
        "doc": "Creates and attaches a character entity to this player. \n\nParameters\n\ncharacter :: string (optional): The character to create else the default is used\n\nNote: The player must not have a character already associated and must be online (see LuaPlayer::connected).",
        "type": "function"
      },
      "disable_alert": {
        "name": "disable_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Disables alerts for the given alert category. \n\nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was disabled (false if it was already disabled).",
        "type": "function"
      },
      "disable_recipe_groups": {
        "name": "disable_recipe_groups()",
        "args": {},
        "doc": "Disable recipe groups\n\nNote: There is no way to undo this.",
        "type": "function"
      },
      "disable_recipe_subgroups": {
        "name": "disable_recipe_subgroups()",
        "args": {},
        "doc": "Disable recipe subgroups\n\nNote: There is no way to undo this.",
        "type": "function"
      },
      "enable_alert": {
        "name": "enable_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Enables alerts for the given alert category. \n\nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was enabled (false if it was already enabled).",
        "type": "function"
      },
      "entity_copy_source": {
        "name": "entity_copy_source",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The source entity used during entity settings copy-paste if any. \n nil if there isn't currently a source entity."
      },
      "game_view_settings": {
        "name": "game_view_settings",
        "type": "GameViewSettings",
        "mode": "[Read-Write]",
        "doc": "The player's game view settings."
      },
      "get_alerts": {
        "name": "get_alerts{entity=…, prototype=…, position=…, type=…, surface=…} → dictionary uint → dictionary defines.alert_type → array of alert",
        "returns": "dictionary uint → dictionary defines.alert_type → array of alert",
        "args": {
          "entity": {
            "doc": "Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)",
            "name": "entity",
            "type": "LuaEntity"
          },
          "entity=…": {
            "name": "entity=…",
            "type": "entity=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "prototype=…": {
            "name": "prototype=…",
            "type": "prototype=…"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          }
        },
        "doc": "Gets all alerts matching the given filters or if no filters are given all alerts are returned. \n A mapping of surface index to an array of arrays of alerts indexed by the alert type. An alert is a table: \n * target :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * tick :: uint: The tick this alert was created\n * icon :: SignalID (optional): The SignalID used for a custom alert. Only present for custom alerts.\n * message :: LocalisedString (optional): The message for a custom alert. Only present for custom alerts\n\nParameters\n\n Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)",
        "type": "function"
      },
      "get_goal_description": {
        "name": "get_goal_description() → LocalisedString",
        "returns": "LocalisedString",
        "args": {},
        "doc": "Get the current goal description, as a localised string.",
        "type": "function"
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[Read-only]",
        "doc": ""
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "This player's index in LuaGameScript::players."
      },
      "is_alert_enabled": {
        "name": "is_alert_enabled(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "If the given alert type is currently enabled. \n\nParameters\n\nalert_type :: defines.alert_type",
        "type": "function"
      },
      "is_alert_muted": {
        "name": "is_alert_muted(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "If the given alert type is currently muted. \n\nParameters\n\nalert_type :: defines.alert_type",
        "type": "function"
      },
      "minimap_enabled": {
        "name": "minimap_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "true if the minimap is visible."
      },
      "mod_settings": {
        "name": "mod_settings",
        "mode": "[Read-only]",
        "doc": "Note: This can become invalid if during operation this player becomes invalid.",
        "type": "mod_settings"
      },
      "mute_alert": {
        "name": "mute_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Mutes alerts for the given alert category. \n\nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was muted (false if it was already muted).",
        "type": "function"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The player's username."
      },
      "online_time": {
        "name": "online_time",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "How many ticks did this player spend playing this save (all sessions combined)"
      },
      "opened_self": {
        "name": "opened_self",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if the player opened itself. I.e. if they opened the character or god-controller GUI."
      },
      "permission_group": {
        "name": "permission_group",
        "type": "LuaPermissionGroup",
        "mode": "[Read-Write]",
        "doc": "The permission group this player is part of or nil if not part of any group."
      },
      "print_entity_statistics": {
        "name": "print_entity_statistics(entities)",
        "args": {
          "entities": {
            "doc": "entities :: array of string (optional): Entity prototypes to get statistics for. If not specified or empty, display statistics for all entities.",
            "name": "entities",
            "type": "array of string"
          }
        },
        "doc": "Print entity statistics to the player's console. \n\nParameters\n\nentities :: array of string (optional): Entity prototypes to get statistics for. If not specified or empty, display statistics for all entities.",
        "type": "function"
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console\n\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "remove_alert": {
        "name": "remove_alert{entity=…, prototype=…, position=…, type=…, surface=…, icon=…, message=…}",
        "args": {
          "entity": {
            "doc": "Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)\n * icon :: SignalID (optional)\n * message :: LocalisedString (optional)",
            "name": "entity",
            "type": "LuaEntity"
          },
          "entity=…": {
            "name": "entity=…",
            "type": "entity=…"
          },
          "icon=…": {
            "name": "icon=…",
            "type": "icon=…"
          },
          "message=…": {
            "name": "message=…",
            "type": "message=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "prototype=…": {
            "name": "prototype=…",
            "type": "prototype=…"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          }
        },
        "doc": "Removes all alerts matching the given filters or if an empty filters table is given all alerts are removed. \n\nParameters\n\n Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)\n * icon :: SignalID (optional)\n * message :: LocalisedString (optional)",
        "type": "function"
      },
      "set_controller": {
        "name": "set_controller{type=…, character=…}",
        "args": {
          "character=…": {
            "name": "character=…",
            "type": "character=…"
          },
          "type": {
            "doc": "Table with the following fields:  * type :: defines.controllers: Which controller to use\n * character :: LuaEntity (optional): Entity to control. Mandatory when type is defines.controllers.character, ignored otherwise.",
            "name": "type",
            "type": "defines.controllers"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          }
        },
        "doc": "Set the controller type of the player\n\nParameters\n\n Table with the following fields:  * type :: defines.controllers: Which controller to use\n * character :: LuaEntity (optional): Entity to control. Mandatory when type is defines.controllers.character, ignored otherwise.",
        "type": "function"
      },
      "set_ending_screen_data": {
        "name": "set_ending_screen_data(message, file)",
        "args": {
          "file": {
            "doc": "file :: string (optional): Path to image to be shown.",
            "name": "file",
            "type": "string"
          },
          "message": {
            "doc": "message :: LocalisedString: Message to be shown.",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Setup the screen to be shown when the game is finished\n\nParameters\n\nmessage :: LocalisedString: Message to be shown.file :: string (optional): Path to image to be shown.",
        "type": "function"
      },
      "set_goal_description": {
        "name": "set_goal_description(text, only_update)",
        "args": {
          "only_update": {
            "doc": "only_update :: boolean (optional): When true, won't play the \"goal updated\" sound.",
            "name": "only_update",
            "type": "boolean"
          },
          "text": {
            "doc": "text :: LocalisedString (optional): The text to display. \\n can be used to delimit lines. Passing empty string or omitting this parameter entirely will make the goal window disappear.",
            "name": "text",
            "type": "LocalisedString"
          }
        },
        "doc": "Set the text in the goal window (top left)\n\nParameters\n\ntext :: LocalisedString (optional): The text to display. \\n can be used to delimit lines. Passing empty string or omitting this parameter entirely will make the goal window disappear.only_update :: boolean (optional): When true, won't play the \"goal updated\" sound.",
        "type": "function"
      },
      "tag": {
        "name": "tag",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The tag that is shown after the player in chat and on the map."
      },
      "unlock_achievement": {
        "name": "unlock_achievement(name)",
        "args": {
          "name": {
            "doc": "name :: string: name of the achievement to unlock",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Unlock the achievements of the given player. This has any effect only when this is the local player and the achievement isn't unlocked so far. \n\nParameters\n\nname :: string: name of the achievement to unlock",
        "type": "function"
      },
      "unmute_alert": {
        "name": "unmute_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Unmutes alerts for the given alert category. \n\nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was unmuted (false if it was wasn't muted).",
        "type": "function"
      },
      "zoom": {
        "name": "zoom",
        "type": "double",
        "mode": "[Write-only]",
        "doc": "The player's zoom-level."
      }
    }
  },
  "LuaPermissionGroups": {
    "name": "LuaPermissionGroups",
    "type": "LuaPermissionGroups",
    "doc": "All permission groups.",
    "properties": {
      "create_group": {
        "name": "create_group(name) → LuaPermissionGroup",
        "returns": "LuaPermissionGroup",
        "args": {
          "name": {
            "doc": "name :: string (optional)",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Creates a new permission group. \n\nParameters\n\nname :: string (optional\n\nNote: May return nil if the calling player doesn't have permission to make groups.",
        "type": "function"
      },
      "get_group": {
        "name": "get_group(group) → LuaPermissionGroup",
        "returns": "LuaPermissionGroup",
        "args": {
          "group": {
            "doc": "group :: string or uint",
            "name": "group",
            "type": "string or uint"
          }
        },
        "doc": "Gets the permission group with the given name or group ID or nil if there is no matching group. \n\nParameters\n\ngroup :: string or uint",
        "type": "function"
      },
      "groups": {
        "name": "groups",
        "type": "array of LuaPermissionGroup",
        "mode": "[Read-only]",
        "doc": "All of the permission groups."
      }
    }
  },
  "LuaPermissionGroup": {
    "name": "LuaPermissionGroup",
    "type": "LuaPermissionGroup",
    "doc": "A permission group that defines what players in this group are allowed to do.",
    "properties": {
      "add_player": {
        "name": "add_player(player) → boolean",
        "returns": "boolean",
        "args": {
          "player": {
            "doc": "player :: PlayerSpecification",
            "name": "player",
            "type": "PlayerSpecification"
          }
        },
        "doc": "Adds the given player to this group. \n\nParameters\n\nplayer :: PlayerSpecificationReturn value If the player was added.",
        "type": "function"
      },
      "allows_action": {
        "name": "allows_action(action) → boolean",
        "returns": "boolean",
        "args": {
          "action": {
            "doc": "action: The defines.input_action value.",
            "name": "action"
          }
        },
        "doc": "If this group allows the given action. \n\nParameters\n\naction: The defines.input_action value.",
        "type": "function"
      },
      "destroy": {
        "name": "destroy() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Destroys this group. \nReturn value If the group was destroyed.",
        "type": "function"
      },
      "group_id": {
        "name": "group_id",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The group ID"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The name of this group. \n\nNote: Setting to nil or an empty string sets the name to the default value."
      },
      "players": {
        "name": "players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The players in this group."
      },
      "remove_player": {
        "name": "remove_player(player) → boolean",
        "returns": "boolean",
        "args": {
          "player": {
            "doc": "player :: PlayerSpecification",
            "name": "player",
            "type": "PlayerSpecification"
          }
        },
        "doc": "Removes the given player from this group. \n\nParameters\n\nplayer :: PlayerSpecificationReturn value If the player was removed.",
        "type": "function"
      },
      "set_allows_action": {
        "name": "set_allows_action(action, boolean) → boolean",
        "returns": "boolean",
        "args": {
          "action": {
            "doc": "action: The defines.input_action value.",
            "name": "action"
          },
          "boolean": {
            "name": "boolean",
            "type": "boolean"
          }
        },
        "doc": "Sets if the player is allowed to perform the given action. \n\nParameters\n\naction: The defines.input_action value.Return value If the value was applied.",
        "type": "function"
      }
    }
  },
  "LuaLogisticPoint": {
    "name": "LuaLogisticPoint",
    "type": "LuaLogisticPoint",
    "doc": "Logistic point of a particular LuaEntity. A \"Logistic point\" is the name given for\n settings and properties used by requester, provider, and storage points in a given logistic network.\n These \"points\" don't have to be a logistic container but often are. One other entity that can own several\n points is the \"player\" character type entity.",
    "properties": {
      "exact": {
        "name": "exact",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this logistic point is using the exact mode. In exact mode robots never over-deliver requests."
      },
      "filters": {
        "name": "filters",
        "type": "array of LogisticFilter",
        "mode": "[Read-only]",
        "doc": "The logistic filters for this logistic point or nil if this doesn't use logistic filters. \n\nNote: The returned array will always have an entry for each filter and will be indexed in sequence when not nil."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force of this logistic point. \n\nNote: This will always be the same as the LuaLogisticPoint::owner force."
      },
      "logistic_member_index": {
        "name": "logistic_member_index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The Logistic member index of this logistic point."
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": ""
      },
      "mode": {
        "name": "mode",
        "type": "defines.logistic_mode",
        "mode": "[Read-only]",
        "doc": "The logistic mode."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The LuaEntity owner of this LuaLogisticPoint."
      },
      "targeted_items_deliver": {
        "name": "targeted_items_deliver",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "Items targeted to be dropped off into this logistic point by robots."
      },
      "targeted_items_pickup": {
        "name": "targeted_items_pickup",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "Items targeted to be picked up from this logistic point by robots."
      }
    }
  },
  "LuaLogisticNetwork": {
    "name": "LuaLogisticNetwork",
    "type": "LuaLogisticNetwork",
    "doc": "A single logistic network of a given force on a given surface.",
    "properties": {
      "all_construction_robots": {
        "name": "all_construction_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The total number of construction robots in the network (idle and active + in roboports)."
      },
      "all_logistic_robots": {
        "name": "all_logistic_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The total number of logistic robots in the network (idle and active + in roboports)."
      },
      "available_construction_robots": {
        "name": "available_construction_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of construction robots available for a job."
      },
      "available_logistic_robots": {
        "name": "available_logistic_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of logistic robots available for a job."
      },
      "cells": {
        "name": "cells",
        "type": "array of LuaLogisticCell",
        "mode": "[Read-only]",
        "doc": "All cells in this network."
      },
      "empty_provider_points": {
        "name": "empty_provider_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have empty provider points in this network."
      },
      "empty_providers": {
        "name": "empty_providers",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have empty logistic provider points in this network."
      },
      "find_cell_closest_to": {
        "name": "find_cell_closest_to(position) → LuaLogisticCell",
        "returns": "LuaLogisticCell",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find logistic cell closest to a given position\n\nParameters\n\nposition :: PositionReturn value May be nil if no cell was found.",
        "type": "function"
      },
      "full_or_satisfied_requester_points": {
        "name": "full_or_satisfied_requester_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have full or satisfied requester points in this network."
      },
      "full_or_satisfied_requesters": {
        "name": "full_or_satisfied_requesters",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have full or satisfied logistic requester points in this network."
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get item counts for the entire network. \nReturn value A mapping of item prototype names to the number available in the network.See also * LuaInventory::get_contents",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item, member) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Item name to count. If not given, gives counts of all items in the network.",
            "name": "item",
            "type": "string"
          },
          "member": {
            "doc": "member :: string (optional): Logistic members to check, must be either \"storage\"or \"providers\". If not given, gives count in the entire network.",
            "name": "member",
            "type": "string"
          }
        },
        "doc": "Count given or all items in the network or given members\n\nParameters\n\nitem :: string (optional): Item name to count. If not given, gives counts of all items in the network.member :: string (optional): Logistic members to check, must be either \"storage\"or \"providers\". If not given, gives count in the entire network.",
        "type": "function"
      },
      "insert": {
        "name": "insert(item, members) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: LuaItemStack: What to insert.",
            "name": "item",
            "type": "LuaItemStack"
          },
          "members": {
            "doc": "members :: string (optional): Which logistic members to insert the items to. Must be \"storage\", \"storage-empty\" (storage chests that are completely empty), \"storage-empty-slot\" (storage chests that have an empty slot), or \"requester\". If not specified, inserts items into the logistic network in the usual order.",
            "name": "members",
            "type": "string"
          }
        },
        "doc": "Insert items into the logistic network. This will actually insert the items into some logistic chests\n\nParameters\n\nitem :: LuaItemStack: What to insert.members :: string (optional): Which logistic members to insert the items to. Must be \"storage\", \"storage-empty\" (storage chests that are completely empty), \"storage-empty-slot\" (storage chests that have an empty slot), or \"requester\". If not specified, inserts items into the logistic network in the usual order.Return value Number of items actually inserted.",
        "type": "function"
      },
      "logistic_members": {
        "name": "logistic_members",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All other entities that have logistic points in this network (inserters mostly)."
      },
      "provider_points": {
        "name": "provider_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have provider points in this network."
      },
      "providers": {
        "name": "providers",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have logistic provider points in this network."
      },
      "remove_item": {
        "name": "remove_item(item, members) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: SimpleItemStack: What to remove.",
            "name": "item",
            "type": "SimpleItemStack"
          },
          "members": {
            "doc": "members :: string (optional): Which logistic members to remove from. Must be \"storage\", \"passive-provider\", or \"active-provider\". If not specified, removes from the network in the usual order.",
            "name": "members",
            "type": "string"
          }
        },
        "doc": "Remove items from the logistic network. This will actually remove the items from some logistic chests\n\nParameters\n\nitem :: SimpleItemStack: What to remove.members :: string (optional): Which logistic members to remove from. Must be \"storage\", \"passive-provider\", or \"active-provider\". If not specified, removes from the network in the usual order.Return value Number of items removed.",
        "type": "function"
      },
      "requester_points": {
        "name": "requester_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have requester points in this network."
      },
      "requesters": {
        "name": "requesters",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have logistic requester points in this network."
      },
      "robot_limit": {
        "name": "robot_limit",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Maximum number of robots the network can work with. Currently only used for the personal roboport."
      },
      "storage_points": {
        "name": "storage_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have storage points in this network."
      },
      "storages": {
        "name": "storages",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have logistic storage points in this network."
      }
    }
  },
  "LuaLogisticCell": {
    "name": "LuaLogisticCell",
    "type": "LuaLogisticCell",
    "doc": "Logistic cell of a particular LuaEntity. A \"Logistic Cell\" is the given name for\n settings and properties used by what would normally be seen as a \"Roboport\". A logistic\n cell however doesn't have to be attached to the roboport entity (the player has one for\n the personal roboport).",
    "properties": {
      "charge_approach_distance": {
        "name": "charge_approach_distance",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Radius at which the robots hover when waiting to be charged."
      },
      "charging_robot_count": {
        "name": "charging_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of robots currently charging."
      },
      "charging_robots": {
        "name": "charging_robots",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Robots currently being charged."
      },
      "construction_radius": {
        "name": "construction_radius",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Construction radius of this cell."
      },
      "is_in_construction_range": {
        "name": "is_in_construction_range(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Is a given position within the construction range of this cell\n\nParameters\n\nposition :: Position",
        "type": "function"
      },
      "is_in_logistic_range": {
        "name": "is_in_logistic_range(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Is a given position within the logistic range of this cell\n\nParameters\n\nposition :: Position",
        "type": "function"
      },
      "is_neighbour_with": {
        "name": "is_neighbour_with(other) → boolean",
        "returns": "boolean",
        "args": {
          "other": {
            "doc": "other :: LuaLogisticCell",
            "name": "other",
            "type": "LuaLogisticCell"
          }
        },
        "doc": "Are two cells neighbours\n\nParameters\n\nother :: LuaLogisticCell",
        "type": "function"
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": "The network that owns this cell or nil."
      },
      "logistic_radius": {
        "name": "logistic_radius",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Logistic radius of this cell."
      },
      "mobile": {
        "name": "mobile",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if this is a mobile cell. In vanilla, only the logistic cell created by a player's personal roboport is mobile."
      },
      "neighbours": {
        "name": "neighbours",
        "type": "array of LuaLogisticCell",
        "mode": "[Read-only]",
        "doc": "Neighbouring cells."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "This cell's owner."
      },
      "stationed_construction_robot_count": {
        "name": "stationed_construction_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of stationed construction robots in this cell."
      },
      "stationed_logistic_robot_count": {
        "name": "stationed_logistic_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of stationed logistic robots in this cell."
      },
      "to_charge_robot_count": {
        "name": "to_charge_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of robots waiting to charge."
      },
      "to_charge_robots": {
        "name": "to_charge_robots",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Robots waiting to charge."
      },
      "transmitting": {
        "name": "transmitting",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if this cell is active."
      }
    }
  },
  "LuaItemStack": {
    "name": "LuaItemStack",
    "type": "LuaItemStack",
    "doc": "A reference to an item and count owned by some external entity.",
    "properties": {
      "active_index": {
        "name": "active_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The active blueprint index for this blueprint book. \nCan only be used if this is BlueprintBookItem"
      },
      "add_ammo": {
        "name": "add_ammo(amount)",
        "args": {
          "amount": {
            "doc": "amount :: uint: Amount of ammo to add.",
            "name": "amount",
            "type": "uint"
          }
        },
        "doc": "Add ammo to this ammo item\n\nParameters\n\namount :: uint: Amount of ammo to add.Can only be used if this is AmmoItem",
        "type": "function"
      },
      "add_durability": {
        "name": "add_durability(amount)",
        "args": {
          "amount": {
            "doc": "amount :: double: Amount of durability to add.",
            "name": "amount",
            "type": "double"
          }
        },
        "doc": "Add durability to this tool item\n\nParameters\n\namount :: double: Amount of durability to add.Can only be used if this is ToolItem",
        "type": "function"
      },
      "allow_manual_label_change": {
        "name": "allow_manual_label_change",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If the label for this item can be manually changed. When false the label can only be changed through the API. \nCan only be used if this is ItemWithLabel"
      },
      "ammo": {
        "name": "ammo",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of bullets left in the magazine. \nCan only be used if this is AmmoItem"
      },
      "blueprint_icons": {
        "name": "blueprint_icons",
        "type": "array of Icon",
        "mode": "[Read-Write]",
        "doc": "Icons of a blueprint item. Every entry of this array has the following fields: \n * signal :: SignalID: Slot icon to use. The slot will have the icon of the specified signal. This allows the use of any item icon, as well as virtual signal icons.\n * index :: uint: Index of the icon in the blueprint icons slots. Has to be in {1, 2, 3, 4}.\nCan only be used if this is BlueprintItem"
      },
      "build_blueprint": {
        "name": "build_blueprint{surface=…, force=…, position=…, force_build=…, direction=…} → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "direction=…": {
            "name": "direction=…",
            "type": "direction=…"
          },
          "force_build=…": {
            "name": "force_build=…",
            "type": "force_build=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "surface": {
            "doc": "Table with the following fields:  * surface :: SurfaceSpecification: Surface to build on\n * force :: string or LuaForce: Force to use for the building\n * position :: Position: The position to build at\n * force_build :: boolean (optional): When true, anything that can be built is else nothing is built if any one thing can't be built\n * direction :: defines.direction (optional): The direction to use when building",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          }
        },
        "doc": "Build this blueprin\n\nParameters\n\n Table with the following fields:  * surface :: SurfaceSpecification: Surface to build on\n * force :: string or LuaForce: Force to use for the building\n * position :: Position: The position to build at\n * force_build :: boolean (optional): When true, anything that can be built is else nothing is built if any one thing can't be built\n * direction :: defines.direction (optional): The direction to use when building",
        "type": "function"
      },
      "can_set_stack": {
        "name": "can_set_stack(stack) → boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "doc": "stack :: LuaItemStack or SimpleItemStack (optional): Stack that would be set, possibly nil.",
            "name": "stack",
            "type": "LuaItemStack or SimpleItemStack"
          }
        },
        "doc": "Would a call to LuaItemStack::set_stack succeed\n\nParameters\n\nstack :: LuaItemStack or SimpleItemStack (optional): Stack that would be set, possibly nil.",
        "type": "function"
      },
      "clear_blueprint": {
        "name": "clear_blueprint()",
        "args": {},
        "doc": "Clears this blueprint item. \nCan only be used if this is BlueprintItem",
        "type": "function"
      },
      "clear_deconstruction_item": {
        "name": "clear_deconstruction_item()",
        "args": {},
        "doc": "Clears all settings/filters on this deconstruction item resetting it to default values. \nCan only be used if this is DeconstructionItem",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Clear this item stack.",
        "type": "function"
      },
      "cost_to_build": {
        "name": "cost_to_build",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "Raw materials required to build this blueprint. Result is a dictionary mapping each item prototype name to the required count.\nCan only be used if this is BlueprintItem"
      },
      "count": {
        "name": "count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of items in this stack."
      },
      "create_blueprint": {
        "name": "create_blueprint{surface=…, force=…, area=…, always_include_tiles=…}",
        "args": {
          "always_include_tiles=…": {
            "name": "always_include_tiles=…",
            "type": "always_include_tiles=…"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "surface": {
            "doc": "Table with the following fields:  * surface :: SurfaceSpecification: Surface to create from\n * force :: string or LuaForce: Force to use for the creation\n * area :: BoundingBox: The bounding box\n * always_include_tiles :: boolean (optional): When true, blueprintable tiles are always included in the blueprint. When false they're only included if no entities exist in the setup area.",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          }
        },
        "doc": "Sets up this blueprint using the found blueprintable entities/tiles on the surface\n\nParameters\n\n Table with the following fields:  * surface :: SurfaceSpecification: Surface to create from\n * force :: string or LuaForce: Force to use for the creation\n * area :: BoundingBox: The bounding box\n * always_include_tiles :: boolean (optional): When true, blueprintable tiles are always included in the blueprint. When false they're only included if no entities exist in the setup area.",
        "type": "function"
      },
      "custom_description": {
        "name": "custom_description",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The custom description this item-with-tags. This is shown over the normal item description if this is set to a non-empty value."
      },
      "default_icons": {
        "name": "default_icons",
        "type": "array of Icon",
        "mode": "[Read-only]",
        "doc": "The default icons for a blueprint item. Every entry of this array has the following fields: \n * name :: string: Prototype name of the item whose icon to use\n * index :: uint: Index of the icon in the blueprint icons slots. Has to be in {1, 2, 3, 4}.\nCan only be used if this is BlueprintItem"
      },
      "drain_ammo": {
        "name": "drain_ammo(amount)",
        "args": {
          "amount": {
            "doc": "amount :: uint: Amount of ammo to remove.",
            "name": "amount",
            "type": "uint"
          }
        },
        "doc": "Remove ammo from this ammo item\n\nParameters\n\namount :: uint: Amount of ammo to remove.Can only be used if this is AmmoItem",
        "type": "function"
      },
      "drain_durability": {
        "name": "drain_durability(amount)",
        "args": {
          "amount": {
            "doc": "amount :: double: Amount of durability to remove.",
            "name": "amount",
            "type": "double"
          }
        },
        "doc": "Remove durability from this tool item\n\nParameters\n\namount :: double: Amount of durability to remove.Can only be used if this is ToolItem",
        "type": "function"
      },
      "durability": {
        "name": "durability",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Durability of the contained item. Automatically capped at the item's maximum durability. \n\nNote: When used on a non-tool item, the value of this attribute is nil."
      },
      "entity_filter_count": {
        "name": "entity_filter_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of entity filters this deconstruction item supports. \nCan only be used if this is DeconstructionItem"
      },
      "entity_filter_mode": {
        "name": "entity_filter_mode",
        "type": "defines.deconstruction_item.entity_filter_mode",
        "mode": "[Read-Write]",
        "doc": "The blacklist/whitelist entity filter mode for this deconstruction item. \nCan only be used if this is DeconstructionItem"
      },
      "entity_filters": {
        "name": "entity_filters",
        "type": "array of string",
        "mode": "[Read-Write]",
        "doc": "The entity filters for this deconstruction item."
      },
      "extends_inventory": {
        "name": "extends_inventory",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this item extends the inventory it resides in (provides its contents for counts, crafting, insertion). Only callable on items with inventories. \nCan only be used if this is ItemWithInventory"
      },
      "get_blueprint_entities": {
        "name": "get_blueprint_entities() → array of blueprint entity",
        "returns": "array of blueprint entity",
        "args": {},
        "doc": "Entities in this blueprint.\nReturn value The fields of an entity table depend on the type of the entity. Every entity has at least the following fields:  * entity_number :: uint: Entity's unique identifier in this blueprint\n * name :: string: Prototype name of the entity\n * position :: Position: Position of the entity\n * direction :: defines.direction (optional): The direction the entity is facing. Only present for entities that can face in different directions.\n * other: Entity-specific fields...\nCan only be used if this is BlueprintItem",
        "type": "function"
      },
      "get_blueprint_tiles": {
        "name": "get_blueprint_tiles() → array of blueprint tile",
        "returns": "array of blueprint tile",
        "args": {},
        "doc": "Tiles in this blueprint \nReturn value A blueprint tile is a table:  * position :: Position\n * name :: string: Prototype name of the tile.\nCan only be used if this is BlueprintItem",
        "type": "function"
      },
      "get_entity_filter": {
        "name": "get_entity_filter(index) → string",
        "returns": "string",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the entity filter at the given index for this deconstruction item. \n\nParameters\n\nindex :: uintCan only be used if this is DeconstructionItem",
        "type": "function"
      },
      "get_inventory": {
        "name": "get_inventory(inventory) → LuaInventory",
        "returns": "LuaInventory",
        "args": {
          "inventory": {
            "doc": "inventory :: defines.inventory: Index of the inventory to access -- currently can only be defines.inventory.item_main.",
            "name": "inventory",
            "type": "defines.inventory"
          }
        },
        "doc": "Access the inner inventory of an item\n\nParameters\n\ninventory :: defines.inventory: Index of the inventory to access -- currently can only be defines.inventory.item_main.Return value or nil if there is no inventory with the given index.",
        "type": "function"
      },
      "get_tag": {
        "name": "get_tag(tag_name) → Any",
        "returns": "Any",
        "args": {
          "tag_name": {
            "doc": "tag_name :: string",
            "name": "tag_name",
            "type": "string"
          }
        },
        "doc": "Gets the tag with the given name or returns nil if it doesn't exist. \n\nParameters\n\ntag_name :: stringCan only be used if this is ItemWithTags",
        "type": "function"
      },
      "get_tile_filter": {
        "name": "get_tile_filter(index) → string",
        "returns": "string",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the tile filter at the given index for this deconstruction item. \n\nParameters\n\nindex :: uintCan only be used if this is DeconstructionItem",
        "type": "function"
      },
      "grid": {
        "name": "grid",
        "type": "LuaEquipmentGrid",
        "mode": "[Read-only]",
        "doc": "The equipment grid of this item or nil if this item doesn't have a grid."
      },
      "health": {
        "name": "health",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "How much health the item has, as a number in range [0, 1]."
      },
      "is_blueprint_setup": {
        "name": "is_blueprint_setup() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Is this blueprint item setup? I.e. is it a non-empty blueprint?",
        "type": "function"
      },
      "label": {
        "name": "label",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The current label for this item. Nil when none. \nCan only be used if this is ItemWithLabel"
      },
      "label_color": {
        "name": "label_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The current label color for this item. Nil when none. \nCan only be used if this is ItemWithLabel"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Prototype name of the item held in this stack."
      },
      "prioritize_insertion_mode": {
        "name": "prioritize_insertion_mode",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The insertion mode priority this ItemWithInventory uses when items are inserted into an inventory it resides in. Only callable on items with inventories. \nCan only be used if this is ItemWithInventory"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Prototype of the item held in this stack."
      },
      "remove_tag": {
        "name": "remove_tag() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Removes a tag with the given name. \nReturn value If the tag existed and was removed.Can only be used if this is ItemWithTags",
        "type": "function"
      },
      "set_blueprint_entities": {
        "name": "set_blueprint_entities(entities)",
        "args": {
          "entities": {
            "doc": "entities :: array of blueprint entity: New blueprint entities. The format is the same as in LuaItemStack::get_blueprint_entities.",
            "name": "entities",
            "type": "array of blueprint entity"
          }
        },
        "doc": "Set new entities to be a part of this blueprint\n\nParameters\n\nentities :: array of blueprint entity: New blueprint entities. The format is the same as in LuaItemStack::get_blueprint_entities.Can only be used if this is BlueprintItem",
        "type": "function"
      },
      "set_blueprint_tiles": {
        "name": "set_blueprint_tiles(tiles)",
        "args": {
          "tiles": {
            "doc": "tiles :: array of blueprint tile: Tiles to be a part of the blueprint; the format is the same as is returned from the corresponding get function; see LuaItemStack::get_blueprint_tiles.",
            "name": "tiles",
            "type": "array of blueprint tile"
          }
        },
        "doc": "Set tiles in this blueprint \n\nParameters\n\ntiles :: array of blueprint tile: Tiles to be a part of the blueprint; the format is the same as is returned from the corresponding get function; see LuaItemStack::get_blueprint_tiles.Can only be used if this is BlueprintItem",
        "type": "function"
      },
      "set_entity_filter": {
        "name": "set_entity_filter(index, filter, DeconstructionItem) → boolean",
        "returns": "boolean",
        "args": {
          "DeconstructionItem": {
            "name": "DeconstructionItem",
            "type": "DeconstructionItem"
          },
          "filter": {
            "doc": "filter :: string or LuaEntityPrototype or LuaEntity: Setting to nil erases the filter.",
            "name": "filter",
            "type": "string or LuaEntityPrototype or LuaEntity"
          },
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Sets the entity filter ata the given index for this deconstruction item. \n\nParameters\n\nindex :: uintfilter :: string or LuaEntityPrototype or LuaEntity: Setting to nil erases the filter.Return value If the new filter was set (was valid.)",
        "type": "function"
      },
      "set_stack": {
        "name": "set_stack(stack) → boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "doc": "stack :: LuaItemStack or SimpleItemStack (optional): Item stack to set this one to. Omitting this parameter or passing nil will clear this item stack, as if by calling LuaItemStack::clear.",
            "name": "stack",
            "type": "LuaItemStack or SimpleItemStack"
          }
        },
        "doc": "Set this item stack to another item stack\n\nParameters\n\nstack :: LuaItemStack or SimpleItemStack (optional): Item stack to set this one to. Omitting this parameter or passing nil will clear this item stack, as if by calling LuaItemStack::clear.Return value Was the stack set successfully?",
        "type": "function"
      },
      "set_tag": {
        "name": "set_tag(tag_name, tag) → Any",
        "returns": "Any",
        "args": {
          "tag": {
            "doc": "tag :: Any",
            "name": "tag",
            "type": "Any"
          },
          "tag_name": {
            "doc": "tag_name :: string",
            "name": "tag_name",
            "type": "string"
          }
        },
        "doc": "Sets the tag with the given name and value. \n\nParameters\n\ntag_name :: stringtag :: AnyCan only be used if this is ItemWithTags",
        "type": "function"
      },
      "set_tile_filter": {
        "name": "set_tile_filter(index, filter, DeconstructionItem) → boolean",
        "returns": "boolean",
        "args": {
          "DeconstructionItem": {
            "name": "DeconstructionItem",
            "type": "DeconstructionItem"
          },
          "filter": {
            "doc": "filter :: string or LuaTilePrototype or LuaTile: Setting to nil erases the filter.",
            "name": "filter",
            "type": "string or LuaTilePrototype or LuaTile"
          },
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Sets the tile filter ata the given index for this deconstruction item. \n\nParameters\n\nindex :: uintfilter :: string or LuaTilePrototype or LuaTile: Setting to nil erases the filter.Return value If the new filter was set (was valid.)",
        "type": "function"
      },
      "tags": {
        "name": "tags",
        "type": "dictionary string → Any",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is ItemWithTags"
      },
      "tile_filter_count": {
        "name": "tile_filter_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of tile filters this deconstruction item supports. \nCan only be used if this is DeconstructionItem"
      },
      "tile_filter_mode": {
        "name": "tile_filter_mode",
        "type": "defines.deconstruction_item.tile_filter_mode",
        "mode": "[Read-Write]",
        "doc": "The blacklist/whitelist tile filter mode for this deconstruction item. \nCan only be used if this is DeconstructionItem"
      },
      "tile_filters": {
        "name": "tile_filters",
        "type": "array of string",
        "mode": "[Read-Write]",
        "doc": "The tile filters for this deconstruction item."
      },
      "tile_selection_mode": {
        "name": "tile_selection_mode",
        "type": "defines.deconstruction_item.tile_filter_mode",
        "mode": "[Read-Write]",
        "doc": "The tile selection mode for this deconstruction item. \nCan only be used if this is DeconstructionItem"
      },
      "trees_and_rocks_only": {
        "name": "trees_and_rocks_only",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this deconstruction item is set to allow trees and rocks only. \nCan only be used if this is DeconstructionItem"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of the item prototype."
      },
      "valid_for_read": {
        "name": "valid_for_read",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this valid for reading? Differs from the usual valid in that valid will be true even if the item stack is blank but the entity that holds it is still valid."
      }
    }
  },
  "LuaItemPrototype": {
    "name": "LuaItemPrototype",
    "type": "LuaItemPrototype",
    "doc": "Prototype of an item.",
    "properties": {
      "alt_selection_border_color": {
        "name": "alt_selection_border_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The color used when doing alt selection with this selection tool prototype. \nCan only be used if this is SelectionTool"
      },
      "alt_selection_cursor_box_type": {
        "name": "alt_selection_cursor_box_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is SelectionTool"
      },
      "alt_selection_mode_flags": {
        "name": "alt_selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[Read-only]",
        "doc": "Flags that affect which entities will be selected during alternate selection.\nCan only be used if this is SelectionTool"
      },
      "always_include_tiles": {
        "name": "always_include_tiles",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If tiles area always included when doing selection with this selection tool prototype. \nCan only be used if this is SelectionTool"
      },
      "attack_parameters": {
        "name": "attack_parameters",
        "type": "AttackParameters",
        "mode": "[Read-only]",
        "doc": "The gun attack parameters or nil if not a gun item prototype."
      },
      "attack_range": {
        "name": "attack_range",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The attack range of this mining tool or nil if not a mining tool. \nCan only be used if this is Miningtool"
      },
      "attack_result": {
        "name": "attack_result",
        "type": "array of TriggerItem",
        "mode": "[Read-only]",
        "doc": "The attack result of this mining tool prototype. \nCan only be used if this is MiningTool"
      },
      "burnt_result": {
        "name": "burnt_result",
        "type": "LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "The result of burning this item as fuel or nil."
      },
      "capsule_action": {
        "name": "capsule_action",
        "type": "CapsuleAction",
        "mode": "[Read-only]",
        "doc": "The capsule action for this capsule item prototype or nil if this isn't a capsule item prototype."
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The module category name \nCan only be used if this is ModuleItem"
      },
      "curved_rail": {
        "name": "curved_rail",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The curved rail prototype used for this rail planner prototype. \nCan only be used if this is RailPlanner"
      },
      "default_label_color": {
        "name": "default_label_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The default label color used for this item with label. nil if not defined or if this isn't an item with label. \nCan only be used if this is ItemWithLabel"
      },
      "default_request_amount": {
        "name": "default_request_amount",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The default request value."
      },
      "draw_label_for_cursor_render": {
        "name": "draw_label_for_cursor_render",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If true, and this item with label has a label it is drawn in place of the normal number when held in the cursor. \nCan only be used if this is ItemWithLabel"
      },
      "durability": {
        "name": "durability",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The durability of this tool item or nil if not a tool item."
      },
      "durability_description_key": {
        "name": "durability_description_key",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The durability message key used when displaying the durability of this tool. \nCan only be used if this is ToolItem"
      },
      "entity_filter_slots": {
        "name": "entity_filter_slots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of entity filters this deconstruction item has or nil if this isn't a deconstruction item prototype. \nCan only be used if this is DeconstructionItem"
      },
      "equipment_grid": {
        "name": "equipment_grid",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[Read-only]",
        "doc": "The prototype of this armor equipment grid or nil if none or this is not an armor item."
      },
      "extend_inventory_by_default": {
        "name": "extend_inventory_by_default",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this item with inventory extends the inventory it resides in by default. \nCan only be used if this is ItemWithInventory"
      },
      "filter_mode": {
        "name": "filter_mode",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The filter mode used by this item with inventory. \nCan only be used if this is ItemWithInventory"
      },
      "flags": {
        "name": "flags",
        "type": "dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "The item prototype flags for this item prototype. It is a dictionary where the keys are the set flags and the value is always true -- if a flag is unset, it isn't present in the dictionary at all.\n The possible flags are: \n *  \"goes-to-main-inventory\": If true, the item will prefer to go to the player's main inventory\n *  \"goes-to-quickbar\": If true, the item will prefer to go to the player's quickbar.\n *  \"hidden\": If true, the item will be hidden from all crafting menus."
      },
      "fuel_acceleration_multiplier": {
        "name": "fuel_acceleration_multiplier",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The acceleration multiplier when this item is used as fuel in a vehicle."
      },
      "fuel_category": {
        "name": "fuel_category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The fuel category or nil."
      },
      "fuel_top_speed_multiplier": {
        "name": "fuel_top_speed_multiplier",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The fuel top speed multiplier when this item is used as fuel in a vehicle."
      },
      "fuel_value": {
        "name": "fuel_value",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Fuel value when burned."
      },
      "get_ammo_type": {
        "name": "get_ammo_type(ammo_source_type)",
        "args": {
          "ammo_source_type": {
            "doc": "ammo_source_type :: string (optional): \"default\", \"player\", \"turret\", or \"vehicle\"",
            "name": "ammo_source_type",
            "type": "string"
          }
        },
        "doc": "Type of this ammo prototype or nil if this is not an ammo prototype. \n\nParameters\n\nammo_source_type :: string (optional): \"default\", \"player\", \"turret\", or \"vehicle\"",
        "type": "function"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "The group this prototype belongs to."
      },
      "group_filters": {
        "name": "group_filters",
        "type": "dictionary string → LuaGroup",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemWithInventory"
      },
      "has_flag": {
        "name": "has_flag(flag) → boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "doc": "flag :: string: The flag to check. Can be either \"goes-to-main-inventory\", \"goes-to-quickbar\" or \"hidden\". Any other value will cause an error.",
            "name": "flag",
            "type": "string"
          }
        },
        "doc": "Does this prototype have a flag enabled? \n\nParameters\n\nflag :: string: The flag to check. Can be either \"goes-to-main-inventory\", \"goes-to-quickbar\" or \"hidden\". Any other value will cause an error.",
        "type": "function"
      },
      "insertion_priority_mode": {
        "name": "insertion_priority_mode",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The insertion priority mode used by this item with inventory. \nCan only be used if this is ItemWithInventory"
      },
      "inventory_size": {
        "name": "inventory_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The main inventory size for item-with-inventory-prototype. nil if not an item-with-inventory-prototype. \nCan only be used if this is ItemWithInventoryPrototype"
      },
      "inventory_size_bonus": {
        "name": "inventory_size_bonus",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The invntory size bonus for this armor prototype. nil if this isn't an armor prototype. \nCan only be used if this is ArmorPrototype"
      },
      "item_filters": {
        "name": "item_filters",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemWithInventory"
      },
      "limitation_message_key": {
        "name": "limitation_message_key",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The limitation message key used when the player attempts to use this modules in some place it's not allowed. \nCan only be used if this is ModuleItem"
      },
      "limitations": {
        "name": "limitations",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "An array of recipe names this module is allowed to work with. \nCan only be used if this is ModuleItem"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_filter_message": {
        "name": "localised_filter_message",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "The localised string used when the player attempts to put items into this item with inventory that aren't allowed. \nCan only be used if this is ItemWithInventory"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "magazine_size": {
        "name": "magazine_size",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Size of full magazine; nil if this is not an ammo item."
      },
      "module_effects": {
        "name": "module_effects",
        "type": "dictionary string → EffectValue",
        "mode": "[Read-only]",
        "doc": "Effects of this module; nil if this is not a module. It is a dictionary indexed by the effect type. \nExampleThese are the effects of the vanilla Productivity Module 3 (up to floating point impresicions): {consumption={bonus=0.6},\nspeed={bonus=-0.15},\nproductivity={bonus=0.06},\npollution={bonus=0.075}} Can only be used if this is ModuleItem"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string."
      },
      "place_as_equipment_result": {
        "name": "place_as_equipment_result",
        "type": "LuaEquipmentPrototype",
        "mode": "[Read-only]",
        "doc": "Prototype of the equipment that will be created by placing this item in an equipment grid or nil if there is no equipment defined."
      },
      "place_as_tile_result": {
        "name": "place_as_tile_result",
        "mode": "[Read-only]",
        "doc": "The place as tile result if one is defined else nil.",
        "type": "place_as_tile_result"
      },
      "place_result": {
        "name": "place_result",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "Prototype of the entity that will be created by placing this item, or nil if there is no such entity."
      },
      "repair_result": {
        "name": "repair_result",
        "type": "array of TriggerItem",
        "mode": "[Read-only]",
        "doc": "The repair result of this repair tool prototype or nil if this isn't a repair tool prototype. \nCan only be used if this is RepairTool"
      },
      "resistances": {
        "name": "resistances",
        "type": "Resistances",
        "mode": "[Read-only]",
        "doc": "Resistances of this armour item; nil if not an armor or or the armor has no resistances."
      },
      "selection_border_color": {
        "name": "selection_border_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The color used when doing normal selection with this selection tool prototype. \nCan only be used if this is SelectionTool"
      },
      "selection_cursor_box_type": {
        "name": "selection_cursor_box_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is SelectionTool"
      },
      "selection_mode_flags": {
        "name": "selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[Read-only]",
        "doc": "Flags that affect which entities will be selected.\nCan only be used if this is SelectionTool"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Mining or repairing speed if this is a mining or repairing tool; otherwise nil."
      },
      "stack_size": {
        "name": "stack_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Maximum stack size of the item specified by this prototype."
      },
      "stackable": {
        "name": "stackable",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this item allowed to stack at all?"
      },
      "straight_rail": {
        "name": "straight_rail",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The straight rail prototype used for this rail planner prototype. \nCan only be used if this is RailPlanner"
      },
      "sub_group_filters": {
        "name": "sub_group_filters",
        "type": "dictionary string → LuaGroup",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemWithInventory"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "The subgroup this prototype belongs to."
      },
      "tier": {
        "name": "tier",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The module tier \nCan only be used if this is ModuleItem"
      },
      "tile_filter_slots": {
        "name": "tile_filter_slots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of tile filters this deconstruction item has or nil if this isn't a deconstruction item prototype. \nCan only be used if this is DeconstructionItem"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this prototype. E.g. \"gun\" or \"mining-tool\"."
      }
    }
  },
  "LuaInventory": {
    "name": "LuaInventory",
    "type": "LuaInventory",
    "doc": "A storage of item stacks.",
    "properties": {
      "can_insert": {
        "name": "can_insert(items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items that would be inserted.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Can at least some items be inserted\n\nParameters\n\nitems :: SimpleItemStack: Items that would be inserted.Return value true if at least a part of the given items could be inserted into this inventory.",
        "type": "function"
      },
      "can_set_filter": {
        "name": "can_set_filter(index, filter) → boolean",
        "returns": "boolean",
        "args": {
          "filter": {
            "doc": "filter :: string: The item name of the filter",
            "name": "filter",
            "type": "string"
          },
          "index": {
            "doc": "index :: uint: The item stack index",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "If the given inventory slot filter can be set to the given filter\n\nParameters\n\nindex :: uint: The item stack indexfilter :: string: The item name of the filter",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Make this inventory empty.",
        "type": "function"
      },
      "entity_owner": {
        "name": "entity_owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity that owns this inventory or nil if this isn't owned by an entity."
      },
      "equipment_owner": {
        "name": "equipment_owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The equipment that owns this inventory or nil if this isn't owned by an equipment."
      },
      "find_item_stack": {
        "name": "find_item_stack(item) → LuaItemStack",
        "returns": "LuaItemStack",
        "args": {
          "item": {
            "doc": "item :: string: The item name to find",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Gets the first LuaItemStack in the inventory that matches the given item name. \n\nParameters\n\nitem :: string: The item name to findReturn value or nil.",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get counts of all items in this inventory.\nReturn value The counts, indexed by item names.",
        "type": "function"
      },
      "get_filter": {
        "name": "get_filter(index) → string",
        "returns": "string",
        "args": {
          "index": {
            "doc": "index :: uint: The item stack index",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the filter for the given item stack index\n\nParameters\n\nindex :: uint: The item stack indexReturn value The current filter or nil if none.",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Prototype name of the item to count. If not specified, count all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Get the number of all or some items in this inventory\n\nParameters\n\nitem :: string (optional): Prototype name of the item to count. If not specified, count all items.",
        "type": "function"
      },
      "getbar": {
        "name": "getbar() → uint",
        "returns": "uint",
        "args": {},
        "doc": "Get the current bar. This is the index at which the red area starts\n\nNote: Only useable if this inventory has a bar.",
        "type": "function"
      },
      "hasbar": {
        "name": "hasbar() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Does this inventory have a bar? Bar is the draggable red thing, found for example on chests, that limits the portion of the inventory that may be manipulated by machines\n\nNote: \"Having a bar\" doesn't mean that the bar is set to some nontrivial value. Having a bar means the inventory supports having this limit at all. The character's inventory is an example of an inventory without a bar; the wooden chest's inventory is an example of one with a bar.",
        "type": "function"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The inventory index this inventory uses."
      },
      "insert": {
        "name": "insert(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to insert.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items into this inventory\n\nParameters\n\nitems :: SimpleItemStack: Items to insert.Return value Number of items actually inserted.",
        "type": "function"
      },
      "is_empty": {
        "name": "is_empty() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Does this inventory contain nothing?",
        "type": "function"
      },
      "is_filtered": {
        "name": "is_filtered() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "If this inventory supports filters and has at least 1 filter set.",
        "type": "function"
      },
      "operator []": {
        "name": "operator []",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The indexing operator.\nExampleWill get the first item in the player's quickbar. game.player.get_inventory(defines.inventory.player_quickbar)[1]"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Get the number of slots in this inventory.\nExampleWill print the number of slots in the player's main inventory. game.player.print(#game.player.get_inventory(defines.inventory.player_main))"
      },
      "player_owner": {
        "name": "player_owner",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player that owns this inventory or nil if this isn't owned by a player."
      },
      "remove": {
        "name": "remove(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to remove.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove items from this inventory\n\nParameters\n\nitems :: SimpleItemStack: Items to remove.Return value Number of items actually removed.",
        "type": "function"
      },
      "set_filter": {
        "name": "set_filter(index, filter) → boolean",
        "returns": "boolean",
        "args": {
          "filter": {
            "doc": "filter :: string: The new filter or nil to erase the filter",
            "name": "filter",
            "type": "string"
          },
          "index": {
            "doc": "index :: uint: The item stack index",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Sets the filter for the given item stack index\n\nParameters\n\nindex :: uint: The item stack indexfilter :: string: The new filter or nil to erase the filterReturn value If the filter was allowed to be set\n\nNote: Some inventory slots don't allow some filters (gun ammo can't be filtered for non-ammo).",
        "type": "function"
      },
      "setbar": {
        "name": "setbar(bar)",
        "args": {
          "bar": {
            "doc": "bar :: uint (optional): The new limit. Ommitting this parameter will clear the limit.",
            "name": "bar",
            "type": "uint"
          }
        },
        "doc": "Set the current bar\n\nParameters\n\nbar :: uint (optional): The new limit. Ommitting this parameter will clear the limit\n\nNote: Only useable if this inventory has a bar.",
        "type": "function"
      },
      "supports_filters": {
        "name": "supports_filters() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "If this inventory supports filters.",
        "type": "function"
      }
    }
  },
  "LuaGuiElement": {
    "name": "LuaGuiElement",
    "type": "LuaGuiElement",
    "doc": "An element of the custom GUI. This type is used to represent any kind of a GUI element -- labels as well\n as buttons as well as frames are all instances of this type. Just like LuaEntity, different kinds\n of elements support different attributes; attempting to access an attribute on an element that doesn't support\n it (for instance, trying to access the value of a text field) will result in a run-time error.",
    "properties": {
      "add_item": {
        "name": "add_item(LocalisedString, index)",
        "args": {
          "index": {
            "doc": "index :: uint (optional): The index",
            "name": "index",
            "type": "uint"
          },
          "LocalisedString": {
            "doc": "LocalisedString: The item.",
            "name": "LocalisedString"
          }
        },
        "doc": "Adds an item at the end or at the given index in this dropdown. \n\nParameters\n\nLocalisedString: The item.index :: uint (optional): The indexCan only be used if this is drop-down",
        "type": "function"
      },
      "add": {
        "name": "add{type=…, name=…, style=…} → LuaGuiElement",
        "returns": "LuaGuiElement",
        "args": {
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "style=…": {
            "name": "style=…",
            "type": "style=…"
          },
          "type": {
            "doc": "Table with the following fields:  * type :: string: The kind of the element to add. Has to be one of \"button\", \"sprite-button\", \"checkbox\", \"flow\", \"frame\", \"label\", \"table\", \"progressbar\", \"textfield\", \"radio-button\", \"sprite\", \"scroll-pane\", \"camera\", \"drop-down\", or \"text-box\".\n * name :: string: Name of the child element.\n * style :: string (optional): Style of the new element.\n *  Other attributes may have to be specified, depending on type * sprite-button * sprite :: SpritePath (optional): Path to the image to display on the button.\n      \n      \n    * checkbox * state :: boolean: Whether the checkbox should be checked by default.\n      \n      \n    * radio-button * state :: boolean: Whether the radio-button should be checked by default.\n      \n      \n    * frame * direction :: string: The initial direction of the frame's layout. See LuaGuiElement::direction.\n      \n      \n    * label * caption :: string (optional): Initial text to display on the label.\n       * single_line :: boolean (optional): If text should be shown on a single line or wrapped based off the max width of the label.\n       * want_ellipsis :: boolean (optional): If text beyond the widget width should be shown as \"...\" instead of clipped. Can't be used with single_line==false\n      \n      \n    * progressbar * size :: uint: Width of the progressbar.\n       * value :: double (optional): Initial value of the progressbar, in range [0, 1]. Defaults to 0 if not given.\n      \n      \n    * table * colspan :: uint: Number of columns\n      \n      \n    * drop-down * items :: array of LocalisedString (optional): The initial items in the dropdown.\n       * selected_index :: uint (optional): The initial selected index.\n      \n      \n    * camera * position :: Position: The position the camera centers on.\n       * surface_index :: uint (optional): The surface the camera will render else if not given the players surface is used.\n       * zoom :: double (optional): The camera zoom - defaults to 0.75.\n      \n      \n    * choose-elem-button * elem_type :: string: \"item\", \"tile\", \"entity\", or \"signal\"\n       * item :: string (optional): If type is \"item\" - the default value for the button\n       * entity :: string (optional): If type is \"entity\" - the default value for the button\n       * tile :: string (optional): If type is \"tile\" - the default value for the button\n       * signal :: SignalID (optional): If type is \"signal\" - the default value for the button",
            "name": "type",
            "type": "string"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          }
        },
        "doc": "Add a child element\n\nParameters\n\n Table with the following fields:  * type :: string: The kind of the element to add. Has to be one of \"button\", \"sprite-button\", \"checkbox\", \"flow\", \"frame\", \"label\", \"table\", \"progressbar\", \"textfield\", \"radio-button\", \"sprite\", \"scroll-pane\", \"camera\", \"drop-down\", or \"text-box\".\n * name :: string: Name of the child element.\n * style :: string (optional): Style of the new element.\n *  Other attributes may have to be specified, depending on type * sprite-button * sprite :: SpritePath (optional): Path to the image to display on the button.\n    * checkbox * state :: boolean: Whether the checkbox should be checked by default.\n    * radio-button * state :: boolean: Whether the radio-button should be checked by default.\n    * frame * direction :: string: The initial direction of the frame's layout. See LuaGuiElement::direction.\n    * label * caption :: string (optional): Initial text to display on the label.\n       * single_line :: boolean (optional): If text should be shown on a single line or wrapped based off the max width of the label.\n       * want_ellipsis :: boolean (optional): If text beyond the widget width should be shown as \"...\" instead of clipped. Can't be used with single_line==false\n    * progressbar * size :: uint: Width of the progressbar.\n       * value :: double (optional): Initial value of the progressbar, in range [0, 1]. Defaults to 0 if not given.\n    * table * colspan :: uint: Number of columns\n    * drop-down * items :: array of LocalisedString (optional): The initial items in the dropdown.\n       * selected_index :: uint (optional): The initial selected index.\n    * camera * position :: Position: The position the camera centers on.\n       * surface_index :: uint (optional): The surface the camera will render else if not given the players surface is used.\n       * zoom :: double (optional): The camera zoom - defaults to 0.75.\n    * choose-elem-button * elem_type :: string: \"item\", \"tile\", \"entity\", or \"signal\"\n       * item :: string (optional): If type is \"item\" - the default value for the button\n       * entity :: string (optional): If type is \"entity\" - the default value for the button\n       * tile :: string (optional): If type is \"tile\" - the default value for the button\n       * signal :: SignalID (optional): If type is \"signal\" - the default value for the button\nReturn value The added GUI element.",
        "type": "function"
      },
      "caption": {
        "name": "caption",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The text displayed on the element. For frames, this is the \"heading\". For other elements, like buttons or labels, this is the content\n\nNote: Whilst this attribute may be used on all elements without producing an error, it doesn't make sense for tables and flows as they won't display it."
      },
      "children": {
        "name": "children",
        "type": "array of LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The children elements"
      },
      "children_names": {
        "name": "children_names",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "Names of all the children of this element. These are the identifiers that can be used to access the child as an attribute of this element."
      },
      "clear_items": {
        "name": "clear_items()",
        "args": {},
        "doc": "Clears the items in this dropdown. \nCan only be used if this is drop-down",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Remove children of this element. Any LuaGuiElement objects referring to the destroyed elements become invalid after this operation.\nExample game.player.gui.top.clear()",
        "type": "function"
      },
      "destroy": {
        "name": "destroy()",
        "args": {},
        "doc": "Remove this element, along with its children. Any LuaGuiElement objects referring to the destroyed elements become invalid after this operation\n\nNote: The top-level GUI elements -- LuaGui::top, LuaGui::left, LuaGui::center -- can't be destroyed.Example game.player.gui.top.greeting.destroy()",
        "type": "function"
      },
      "direction": {
        "name": "direction",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "Direction of the layout. May be either \"horizontal\" or \"vertical\".\nCan only be used if this is frame"
      },
      "elem_type": {
        "name": "elem_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The elem type of this choose-elem-button. \nCan only be used if this is choose-elem-button"
      },
      "elem_value": {
        "name": "elem_value",
        "type": "string or SignalID",
        "mode": "[Read-Write]",
        "doc": "The elem value of this choose-elem-button or nil if there is no value. \n\nNote: Types \"item\", \"entity\", and \"tile\" operate with strings. Type \"signal\" operates with SignalID.Can only be used if this is choose-elem-button"
      },
      "get_item": {
        "name": "get_item(index) → LocalisedString",
        "returns": "LocalisedString",
        "args": {
          "index": {
            "doc": "index :: uint: The index to get.",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets an item at the given index from this dropdown. \n\nParameters\n\nindex :: uint: The index to get.Can only be used if this is drop-down",
        "type": "function"
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[Read-only]",
        "doc": "The GUI this element is a part of."
      },
      "horizontal_scroll_policy": {
        "name": "horizontal_scroll_policy",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "Allowed values are: \"always\", \"never\", or \"auto\" \nCan only be used if this is scroll-pane"
      },
      "items": {
        "name": "items",
        "type": "array of LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The items in this dropdown. \nCan only be used if this is drop-down"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The name of this element.\nExample game.player.gui.top.greeting.name == \"greeting\""
      },
      "parent": {
        "name": "parent",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The direct parent of this element; nil if this is a top-level element."
      },
      "player_index": {
        "name": "player_index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Index into LuaGameScript::players specifying the player who owns this element."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-Write]",
        "doc": "The position this camera is focused on. \nCan only be used if this is camera"
      },
      "read_only": {
        "name": "read_only",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this text-box is read-only. \nCan only be used if this is text-box"
      },
      "selectable": {
        "name": "selectable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If the contents of this text-box are selectable. \nCan only be used if this is text-box"
      },
      "selected_index": {
        "name": "selected_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The selected index for this dropdown. 0 if none."
      },
      "set_item": {
        "name": "set_item(index, LocalisedString)",
        "args": {
          "index": {
            "doc": "index :: uint: The index",
            "name": "index",
            "type": "uint"
          },
          "LocalisedString": {
            "doc": "LocalisedString: The item.",
            "name": "LocalisedString"
          }
        },
        "doc": "Sets an item at the given index in this dropdown. \n\nParameters\n\nindex :: uint: The indexLocalisedString: The item.Can only be used if this is drop-down",
        "type": "function"
      },
      "single_line": {
        "name": "single_line",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this label should render its contents on single line or multiple based off the max width of the label."
      },
      "sprite": {
        "name": "sprite",
        "type": "SpritePath",
        "mode": "[Read-Write]",
        "doc": "Path the the image to display on this sprite-button. \nCan only be used if this is sprite-button"
      },
      "state": {
        "name": "state",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Is this checkbox checked?\nCan only be used if this is checkbox"
      },
      "style": {
        "name": "style",
        "type": "LuaStyle or string",
        "mode": "[Read-Write]",
        "doc": "The style of this element. When read, this evaluates to a LuaStyle. For writing, it only accepts a string that specifies the textual identifier of the desired style."
      },
      "surface_index": {
        "name": "surface_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The surface index this camera is using. \nCan only be used if this is camera"
      },
      "text": {
        "name": "text",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The text contained in a textfield or text-box."
      },
      "tooltip": {
        "name": "tooltip",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The type of this GUI element."
      },
      "value": {
        "name": "value",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "How much this progress bar is filled. It is a value in range [0, 1].\nCan only be used if this is progressbar"
      },
      "vertical_scroll_policy": {
        "name": "vertical_scroll_policy",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "Allowed values are: \"always\", \"never\", or \"auto\" \nCan only be used if this is scroll-pane"
      },
      "want_ellipsis": {
        "name": "want_ellipsis",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this label text should render text outside the label area as \"...\"."
      },
      "word_wrap": {
        "name": "word_wrap",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this text-box will word-wrap automatically. \nCan only be used if this is text-box"
      },
      "zoom": {
        "name": "zoom",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The zoom this camera is using. \nCan only be used if this is camera"
      }
    }
  },
  "LuaGui": {
    "name": "LuaGui",
    "type": "LuaGui",
    "doc": "The root of the GUI. This type houses the root elements, top, left, center and goal, to which\n other elements can be added to be displayed on screen.",
    "properties": {
      "center": {
        "name": "center",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The center part of the GUI. It is a flow element."
      },
      "children": {
        "name": "children",
        "type": "dictionary string → LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The children GUI elements mapped by name <> element."
      },
      "goal": {
        "name": "goal",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The flow used in the objectives window. It is a flow element. The objectives window is only visible when the flow is not empty or the objective text is set."
      },
      "is_valid_sprite_path": {
        "name": "is_valid_sprite_path(sprite_path) → boolean",
        "returns": "boolean",
        "args": {
          "sprite_path": {
            "doc": "sprite_path :: SpritePath: Path to a image.",
            "name": "sprite_path",
            "type": "SpritePath"
          }
        },
        "doc": "Returns true if sprite_path is valid and contains loaded sprite, otherwise false. \n\nParameters\n\nsprite_path :: SpritePath: Path to a image.",
        "type": "function"
      },
      "left": {
        "name": "left",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The left part of the GUI. It is a flow element."
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player who owns this gui."
      },
      "top": {
        "name": "top",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The top part of the GUI. It is a flow element."
      }
    }
  },
  "LuaGroup": {
    "name": "LuaGroup",
    "type": "LuaGroup",
    "doc": "Item group or subgroup.",
    "properties": {
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "The parent group if any; nil if none."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "subgroups": {
        "name": "subgroups",
        "type": "array of LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroups of this group\n\nNote: Can only be used on groups, not on subgroups."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaGameScript": {
    "name": "LuaGameScript",
    "type": "LuaGameScript",
    "doc": "Main toplevel type, provides access to most of the API though its members. An instance\n of LuaGameScript is available as the global object named game.",
    "properties": {
      "active_mods": {
        "name": "active_mods",
        "type": "dictionary string → string",
        "mode": "[Read-only]",
        "doc": "The active mods versions. The keys are mod names, the values are the versions. \nExampleThis will print the names and versions of active mods to player p's console. for name, version in pairs(game.active_mods) do\np.print(name .. \" version \" .. version)\nend"
      },
      "check_consistency": {
        "name": "check_consistency()",
        "args": {},
        "doc": "Run internal consistency checks. Allegedly prints any errors it finds\n\nNote: Exists mainly for debugging reasons.",
        "type": "function"
      },
      "check_prototype_translations": {
        "name": "check_prototype_translations() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Goes over all items, entities, tiles, recipes, technologies among other things and logs if the locale is incorrect. \nReturn value If all prototype translations are correct to the best of the games knowledge\n\nNote: Also prints true/false if called from the console.",
        "type": "function"
      },
      "connected_players": {
        "name": "connected_players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The online players \n This is primarally useful when you want to do some action against all online players\n\nNote: This does *not* index using player index. See LuaPlayer::index on each player instance for the player index."
      },
      "create_force": {
        "name": "create_force(force) → LuaForce",
        "returns": "LuaForce",
        "args": {
          "force": {
            "doc": "force :: string: Name of the new force",
            "name": "force",
            "type": "string"
          }
        },
        "doc": "Create a new force\n\nParameters\n\nforce :: string: Name of the new forceReturn value The force that was just create\n\nNote: The game currently supports a maximum of 64 forces, including the three built-in forces. This means that a maximum of 61 new forces may be created\n\nNote: Force names must be unique.",
        "type": "function"
      },
      "create_random_generator": {
        "name": "create_random_generator(seed) → LuaRandomGenerator",
        "returns": "LuaRandomGenerator",
        "args": {
          "seed": {
            "doc": "seed :: uint (optional)",
            "name": "seed",
            "type": "uint"
          }
        },
        "doc": "Creates a deterministic standalone random generator with the given seed or if a seed is not provided the initial map seed is used. \n\nParameters\n\nseed :: uint (optional\n\nNote: *Make sure* you actually want to use this over math.random(...) as this provides entirely different functionality over math.random(...).",
        "type": "function"
      },
      "create_surface": {
        "name": "create_surface(name, settings) → LuaSurface",
        "returns": "LuaSurface",
        "args": {
          "name": {
            "doc": "name :: string: Name of the new surface",
            "name": "name",
            "type": "string"
          },
          "settings": {
            "doc": "settings :: MapGenSettings (optional): Map generation settings",
            "name": "settings",
            "type": "MapGenSettings"
          }
        },
        "doc": "Create a new surfac\n\nParameters\n\nname :: string: Name of the new surfacesettings :: MapGenSettings (optional): Map generation settingsReturn value The surface that was just created",
        "type": "function"
      },
      "damage_prototypes": {
        "name": "damage_prototypes",
        "type": "custom dictionary string → LuaDamagePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "decorative_prototypes": {
        "name": "decorative_prototypes",
        "type": "custom dictionary string → LuaDecorativePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "delete_surface": {
        "name": "delete_surface(surface)",
        "args": {
          "surface": {
            "doc": "surface :: string or LuaSurface: The surface to be deleted. Currently the primary surface (0, 'nauvis') cannot be deleted.",
            "name": "surface",
            "type": "string or LuaSurface"
          }
        },
        "doc": "Deletes the given surface and all entities on it. \n\nParameters\n\nsurface :: string or LuaSurface: The surface to be deleted. Currently the primary surface (0, 'nauvis') cannot be deleted.",
        "type": "function"
      },
      "difficulty": {
        "name": "difficulty",
        "type": "defines.difficulty",
        "mode": "[Read-only]",
        "doc": "Current scenario difficulty."
      },
      "difficulty_settings": {
        "name": "difficulty_settings",
        "type": "DifficultySettings",
        "mode": "[Read-only]",
        "doc": "Although it can be done; because different difficulties can have different technology or recipe trees it's not recomended to change difficulty settings mid-game."
      },
      "direction_to_string": {
        "name": "direction_to_string(direction)",
        "args": {
          "direction": {
            "doc": "direction :: defines.direction",
            "name": "direction",
            "type": "defines.direction"
          }
        },
        "doc": "Converts the given direction into the string version of the direction. \n\nParameters\n\ndirection :: defines.direction",
        "type": "function"
      },
      "disable_replay": {
        "name": "disable_replay()",
        "args": {},
        "doc": "Disables replay saving for the current save file. Once done there's no way to re-enable replay saving for the save file without loading an old save.",
        "type": "function"
      },
      "disable_tips_and_tricks": {
        "name": "disable_tips_and_tricks()",
        "args": {},
        "doc": "Disable showing tips and tricks.",
        "type": "function"
      },
      "entity_prototypes": {
        "name": "entity_prototypes",
        "type": "custom dictionary string → LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "equipment_grid_prototypes": {
        "name": "equipment_grid_prototypes",
        "type": "custom dictionary string → LuaEquipmentGridPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "equipment_prototypes": {
        "name": "equipment_prototypes",
        "type": "custom dictionary string → LuaEquipmentPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "finished": {
        "name": "finished",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is the scenario finished?"
      },
      "fluid_prototypes": {
        "name": "fluid_prototypes",
        "type": "custom dictionary string → LuaFluidPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "force_crc": {
        "name": "force_crc()",
        "args": {},
        "doc": "Force a CRC check. Tells all peers to calculate their current map CRC; these CRC are then compared against each other. If a mismatch is detected, the game is desynced and some peers are forced to reconnect.",
        "type": "function"
      },
      "forces": {
        "name": "forces",
        "type": "custom dictionary string → LuaForce",
        "mode": "[Read-only]",
        "doc": ""
      },
      "get_entity_by_tag": {
        "name": "get_entity_by_tag(tag) → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "tag": {
            "doc": "tag :: string",
            "name": "tag",
            "type": "string"
          }
        },
        "doc": "Parameterstag :: string",
        "type": "function"
      },
      "help": {
        "name": "help()",
        "args": {},
        "doc": "Internal",
        "type": "function"
      },
      "is_demo": {
        "name": "is_demo() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Is this the demo version of Factorio?",
        "type": "function"
      },
      "item_prototypes": {
        "name": "item_prototypes",
        "type": "custom dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "map_settings": {
        "name": "map_settings",
        "type": "MapSettings",
        "mode": "[Read-only]",
        "doc": ""
      },
      "merge_forces": {
        "name": "merge_forces(source, destination)",
        "args": {
          "destination": {
            "doc": "destination :: string or LuaForce: The force to reassign all entities to",
            "name": "destination",
            "type": "string or LuaForce"
          },
          "source": {
            "doc": "source :: string or LuaForce: The force to remove",
            "name": "source",
            "type": "string or LuaForce"
          }
        },
        "doc": "Merge two forces together. All entities in the source force will be reassigned to the target force. The source force will then be destroyed\n\nParameters\n\nsource :: string or LuaForce: The force to removedestination :: string or LuaForce: The force to reassign all entities t\n\nNote: The three built-in forces -- player, enemy and neutral -- can't be destroyed. I.e. they can't be used as the source argument to this function.",
        "type": "function"
      },
      "permissions": {
        "name": "permissions",
        "type": "LuaPermissionGroups",
        "mode": "[Read-only]",
        "doc": ""
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player typing at the console - nil in all other instances. See LuaGameScript::players for accessing all players."
      },
      "players": {
        "name": "players",
        "type": "custom dictionary uint or string → LuaPlayer",
        "mode": "[Read-only]",
        "doc": "Note: This is a sparse table so pairs(), a known player index, or player name should be used to access elements."
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console all players\n\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "recipe_prototypes": {
        "name": "recipe_prototypes",
        "type": "custom dictionary string → LuaRecipePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "regenerate_entity": {
        "name": "regenerate_entity(entitites)",
        "args": {
          "entitites": {
            "doc": "entitites :: string or array of string: Prototype names of entity or entities to autoplace.",
            "name": "entitites",
            "type": "string or array of string"
          }
        },
        "doc": "Regenerate autoplacement of some entities on all surfaces. This can be used to autoplace newly-added entities\n\nParameters\n\nentitites :: string or array of string: Prototype names of entity or entities to autoplace\n\nNote: All specified entity prototypes must be autoplacable.",
        "type": "function"
      },
      "reload_script": {
        "name": "reload_script()",
        "args": {},
        "doc": "Forces a reload of the scenario script when the save game without the migration is loaded. \n\nNote: Useable only in migration scripts.",
        "type": "function"
      },
      "remove_offline_players": {
        "name": "remove_offline_players(players)",
        "args": {
          "players": {
            "doc": "players :: array of LuaPlayer or string (optional): List of players to remove. If not specified, remove all offline players.",
            "name": "players",
            "type": "array of LuaPlayer or string"
          }
        },
        "doc": "Remove players who are currently not connected from the map. \n\nParameters\n\nplayers :: array of LuaPlayer or string (optional): List of players to remove. If not specified, remove all offline players.",
        "type": "function"
      },
      "remove_path": {
        "name": "remove_path(path)",
        "args": {
          "path": {
            "doc": "path :: string: Path to remove, relative to the script output directory",
            "name": "path",
            "type": "string"
          }
        },
        "doc": "Remove file or directory. Given path is taken relative to the script output directory. Can be used to remove files created by LuaGameScript::write_file\n\nParameters\n\npath :: string: Path to remove, relative to the script output directory",
        "type": "function"
      },
      "save_atlas": {
        "name": "save_atlas()",
        "args": {},
        "doc": "Saves the current configuration of Atlas to a file. This will result in huge file containing all of the game graphics moved to as small space as possible\n\nNote: Exists mainly for debugging reasons.",
        "type": "function"
      },
      "server_save": {
        "name": "server_save(name)",
        "args": {
          "name": {
            "doc": "name :: string (optional): Save name. If not specified, writes into the currently-running save.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Instruct the server to save the map. \n\nParameters\n\nname :: string (optional): Save name. If not specified, writes into the currently-running save.",
        "type": "function"
      },
      "set_game_state": {
        "name": "set_game_state{game_finished=…, player_won=…, next_level=…, can_continue=…}",
        "args": {
          "can_continue=…": {
            "name": "can_continue=…",
            "type": "can_continue=…"
          },
          "game_finished": {
            "doc": "Table with the following fields:  * game_finished :: boolean\n * player_won :: boolean\n * next_level :: string\n * can_continue :: boolean",
            "name": "game_finished",
            "type": "boolean"
          },
          "game_finished=…": {
            "name": "game_finished=…",
            "type": "game_finished=…"
          },
          "next_level=…": {
            "name": "next_level=…",
            "type": "next_level=…"
          },
          "player_won=…": {
            "name": "player_won=…",
            "type": "player_won=…"
          }
        },
        "doc": "Set scenario state. \n\nParameters\n\n Table with the following fields:  * game_finished :: boolean\n * player_won :: boolean\n * next_level :: string\n * can_continue :: boolean",
        "type": "function"
      },
      "show_message_dialog": {
        "name": "show_message_dialog{text=…, image=…, point_to=…}",
        "args": {
          "image=…": {
            "name": "image=…",
            "type": "image=…"
          },
          "point_to=…": {
            "name": "point_to=…",
            "type": "point_to=…"
          },
          "text": {
            "doc": "Table with the following fields:  * text :: LocalisedString: What the dialog should say\n * image :: string (optional): Path to an image to show on the dialog\n * point_to :: GuiArrowSpecification (optional): If specified, dialog will show an arrow pointing to this place. When not specified, the arrow will point to the player's position. (Use point_to={type=\"nowhere\"} to remove the arrow entirely.) The dialog itself will be placed near the arrow's target.",
            "name": "text",
            "type": "LocalisedString"
          },
          "text=…": {
            "name": "text=…",
            "type": "text=…"
          }
        },
        "doc": "Show an in-game message dialog. \n\nParameters\n\n Table with the following fields:  * text :: LocalisedString: What the dialog should say\n * image :: string (optional): Path to an image to show on the dialog\n * point_to :: GuiArrowSpecification (optional): If specified, dialog will show an arrow pointing to this place. When not specified, the arrow will point to the player's position. (Use point_to={type=\"nowhere\"} to remove the arrow entirely.) The dialog itself will be placed near the arrow's target\n\nNote: Can only be used when the map contains exactly one player.",
        "type": "function"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Speed to update the map at. 1.0 is normal speed -- 60 UPS. \n\nNote: Minimum value is 0.1."
      },
      "surfaces": {
        "name": "surfaces",
        "type": "custom dictionary string → LuaSurface",
        "mode": "[Read-only]",
        "doc": ""
      },
      "take_screenshot": {
        "name": "take_screenshot{player=…, by_player=…, position=…, resolution=…, zoom=…, path=…, show_gui=…, show_entity_info=…, anti_alias=…}",
        "args": {
          "anti_alias=…": {
            "name": "anti_alias=…",
            "type": "anti_alias=…"
          },
          "by_player=…": {
            "name": "by_player=…",
            "type": "by_player=…"
          },
          "path=…": {
            "name": "path=…",
            "type": "path=…"
          },
          "player": {
            "doc": "Table with the following fields:  * player :: PlayerSpecification (optional)\n * by_player :: PlayerSpecification (optional): If defined, the screenshot will only be taken for this player.\n * position :: Position (optional)\n * resolution :: Position (optional): Maximum allowed resolution is 16384x16384 (resp. 8192x8192 when anti_alias is true), but maximum recommended resolution is 4096x4096 (resp. 2048x2048).\n * zoom :: double (optional)\n * path :: string (optional): Path to save the screenshot in\n * show_gui :: boolean (optional): Include game GUI in the screenshot?\n * show_entity_info :: boolean (optional): Include entity info (alt-mode)?\n * anti_alias :: boolean (optional): Render in double resolution and scale down (including GUI)?",
            "name": "player",
            "type": "PlayerSpecification"
          },
          "player=…": {
            "name": "player=…",
            "type": "player=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "resolution=…": {
            "name": "resolution=…",
            "type": "resolution=…"
          },
          "show_entity_info=…": {
            "name": "show_entity_info=…",
            "type": "show_entity_info=…"
          },
          "show_gui=…": {
            "name": "show_gui=…",
            "type": "show_gui=…"
          },
          "zoom=…": {
            "name": "zoom=…",
            "type": "zoom=…"
          }
        },
        "doc": "Take a screenshot and save it to a file\n\nParameters\n\n Table with the following fields:  * player :: PlayerSpecification (optional)\n * by_player :: PlayerSpecification (optional): If defined, the screenshot will only be taken for this player.\n * position :: Position (optional)\n * resolution :: Position (optional): Maximum allowed resolution is 16384x16384 (resp. 8192x8192 when anti_alias is true), but maximum recommended resolution is 4096x4096 (resp. 2048x2048).\n * zoom :: double (optional)\n * path :: string (optional): Path to save the screenshot in\n * show_gui :: boolean (optional): Include game GUI in the screenshot?\n * show_entity_info :: boolean (optional): Include entity info (alt-mode)?\n * anti_alias :: boolean (optional): Render in double resolution and scale down (including GUI)\n\nNote: If Factorio is running headless, this function will do nothing.",
        "type": "function"
      },
      "technology_prototypes": {
        "name": "technology_prototypes",
        "type": "custom dictionary string → LuaTechnologyPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "tick": {
        "name": "tick",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Current map tick."
      },
      "tile_prototypes": {
        "name": "tile_prototypes",
        "type": "custom dictionary string → LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "virtual_signal_prototypes": {
        "name": "virtual_signal_prototypes",
        "type": "custom dictionary string → LuaVirtualSignalPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "write_file": {
        "name": "write_file(filename, data, append, for_player)",
        "args": {
          "append": {
            "doc": "append :: boolean (optional): When true, this will append to the end of the file. Defaults to false,",
            "name": "append",
            "type": "boolean"
          },
          "data": {
            "doc": "data :: string: File content",
            "name": "data",
            "type": "string"
          },
          "filename": {
            "doc": "filename :: string: Path to the file to write to",
            "name": "filename",
            "type": "string"
          },
          "for_player": {
            "doc": "for_player :: uint (optional): If given, the file will only be written for this player_index. 0 means only the server if one exists. which will overwrite any pre-existing file with the new data.",
            "name": "for_player",
            "type": "uint"
          }
        },
        "doc": "Write a string to a file\n\nParameters\n\nfilename :: string: Path to the file to write todata :: string: File contentappend :: boolean (optional): When true, this will append to the end of the file. Defaults to false,for_player :: uint (optional): If given, the file will only be written for this player_index. 0 means only the server if one exists. which will overwrite any pre-existing file with the new data.",
        "type": "function"
      }
    }
  },
  "LuaForce": {
    "name": "LuaForce",
    "type": "LuaForce",
    "doc": "LuaForce encapsulates data local to each \"force\" or \"faction\" of the game.\n Default forces are player, enemy and neutral. Players and mods can create\n additional forces (up to 64 total).",
    "properties": {
      "add_chart_tag": {
        "name": "add_chart_tag(surface, tag) → LuaCustomChartTag",
        "returns": "LuaCustomChartTag",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification: Which surface to add the tag to.",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "tag": {
            "doc": "tag: Table with the following fields:  * icon :: SignalID (optional): )\n * position :: Position\n * text :: string (optional)\n * last_user :: PlayerSpecification (optional)\n * orientation :: float (optional)\n * target :: LuaEntity (optional)",
            "name": "tag",
            "type": "SignalID"
          }
        },
        "doc": "Adds a custom chart tag to the given surface and returns the new tag or nil if the given position isn't valid for a chart tag. \n\nParameters\n\nsurface :: SurfaceSpecification: Which surface to add the tag to.tag: Table with the following fields:  * icon :: SignalID (optional): )\n * position :: Position\n * text :: string (optional)\n * last_user :: PlayerSpecification (optional)\n * orientation :: float (optional)\n * target :: LuaEntity (optional\n\nNote: The chunk must be charted for a tag to be valid at that location\n\nNote: The icon, text, or both must be provided.",
        "type": "function"
      },
      "ai_controllable": {
        "name": "ai_controllable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Enables some higher-level AI behaviour for this force. When set to true, biters belonging to this force will automatically expand into new territories, build new spawners, and form unit groups. By default, this value is true for the enemy force and false for all others\n\nNote: Setting this to false does not turn off biters' AI. They will still move around and attack players who come close\n\nNote: It is necessary for a force to be AI controllable in order to be able to create unit groups or build bases from scripts."
      },
      "auto_character_trash_slots": {
        "name": "auto_character_trash_slots",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "true if auto character trash slots are enabled. Character trash slots must be > 0 as well for this to actually be used."
      },
      "character_build_distance_bonus": {
        "name": "character_build_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_health_bonus": {
        "name": "character_health_bonus",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_inventory_slots_bonus": {
        "name": "character_inventory_slots_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "the number of additional inventory slots the character main inventory has."
      },
      "character_item_drop_distance_bonus": {
        "name": "character_item_drop_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_item_pickup_distance_bonus": {
        "name": "character_item_pickup_distance_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_logistic_slot_count": {
        "name": "character_logistic_slot_count",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Number of character logistic slots."
      },
      "character_loot_pickup_distance_bonus": {
        "name": "character_loot_pickup_distance_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_reach_distance_bonus": {
        "name": "character_reach_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_resource_reach_distance_bonus": {
        "name": "character_resource_reach_distance_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_running_speed_modifier": {
        "name": "character_running_speed_modifier",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_trash_slot_count": {
        "name": "character_trash_slot_count",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Number of character trash slots."
      },
      "chart_all": {
        "name": "chart_all(surface)",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): Which surface to chart or all if not given.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Chart all generated chunks. \n\nParameters\n\nsurface :: SurfaceSpecification (optional): Which surface to chart or all if not given.",
        "type": "function"
      },
      "chart": {
        "name": "chart(surface, area)",
        "args": {
          "area": {
            "doc": "area :: BoundingBox: The area on the given surface to chart.",
            "name": "area",
            "type": "BoundingBox"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Chart a portion of the map. The chart for the given area is refreshed; it creates chart for any parts of the given area that haven't been charted yet\n\nParameters\n\nsurface :: SurfaceSpecificationarea :: BoundingBox: The area on the given surface to chart.ExampleCharts a 2048x2048 rectangle centered around the origin. game.player.force.chart(game.player.surface,\n{{x = -1024, y = -1024}, {x = 1024, y = 1024}})",
        "type": "function"
      },
      "clear_chart": {
        "name": "clear_chart(surface)",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): Which surface to erase chart data for or if not provided all surfaces charts are erased.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Erases chart data for this force. \n\nParameters\n\nsurface :: SurfaceSpecification (optional): Which surface to erase chart data for or if not provided all surfaces charts are erased.",
        "type": "function"
      },
      "connected_players": {
        "name": "connected_players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The connected players belonging to this force. \n This is primarally useful when you want to do some action against all online players of this force\n\nNote: This does *not* index using player index. See LuaPlayer::index on each player instance for the player index."
      },
      "current_research": {
        "name": "current_research",
        "type": "LuaTechnology or string",
        "mode": "[Read-Write]",
        "doc": "The current research in progress. Reading this attribute gives a LuaTechnology of the current technology in research, or nil if no research is currently ongoing. Writing this attribute expects a string specifying a technology name or nil to stop any research in progress; writing will start a research of the specified technology."
      },
      "deconstruction_time_to_live": {
        "name": "deconstruction_time_to_live",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The time, in ticks, before a deconstruction order is removed."
      },
      "disable_all_prototypes": {
        "name": "disable_all_prototypes()",
        "args": {},
        "doc": "Disable all recipes and technologies. Only recipes and technologies enabled explicitly will be useable from this point.",
        "type": "function"
      },
      "disable_research": {
        "name": "disable_research()",
        "args": {},
        "doc": "Disable research for this force.",
        "type": "function"
      },
      "enable_all_recipes": {
        "name": "enable_all_recipes()",
        "args": {},
        "doc": "Unlock all recipes.",
        "type": "function"
      },
      "enable_all_technologies": {
        "name": "enable_all_technologies()",
        "args": {},
        "doc": "Unlock all technologies.",
        "type": "function"
      },
      "enable_research": {
        "name": "enable_research()",
        "args": {},
        "doc": "Enable research for this force.",
        "type": "function"
      },
      "entity_build_count_statistics": {
        "name": "entity_build_count_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The entity build statistics for this force (built and mined)"
      },
      "evolution_factor": {
        "name": "evolution_factor",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Evolution factor of this force."
      },
      "find_chart_tags": {
        "name": "find_chart_tags(surface, area) → array of LuaCustomChartTag",
        "returns": "array of LuaCustomChartTag",
        "args": {
          "area": {
            "doc": "area :: BoundingBox (optional)",
            "name": "area",
            "type": "BoundingBox"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Finds all custom chart tags within the given bounding box on the given surface. \n\nParameters\n\nsurface :: SurfaceSpecificationarea :: BoundingBox (optional)",
        "type": "function"
      },
      "find_logistic_network_by_position": {
        "name": "find_logistic_network_by_position(position, surface) → LuaLogisticNetwork",
        "returns": "LuaLogisticNetwork",
        "args": {
          "position": {
            "doc": "position :: Position: Position to find a network for",
            "name": "position",
            "type": "Position"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification: Surface to search on",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parametersposition :: Position: Position to find a network forsurface :: SurfaceSpecification: Surface to search onReturn value The found network or nil.",
        "type": "function"
      },
      "fluid_production_statistics": {
        "name": "fluid_production_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The fluid production statistics for this force."
      },
      "friendly_fire": {
        "name": "friendly_fire",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If friendly fire is enabled for this force."
      },
      "get_ammo_damage_modifier": {
        "name": "get_ammo_damage_modifier(ammo) → double",
        "returns": "double",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          }
        },
        "doc": "Parametersammo :: string: Ammo category",
        "type": "function"
      },
      "get_cease_fire": {
        "name": "get_cease_fire(other) → boolean",
        "returns": "boolean",
        "args": {
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          }
        },
        "doc": "Will this force attack members of another force\n\nParameters\n\nother :: string or LuaForce",
        "type": "function"
      },
      "get_entity_count": {
        "name": "get_entity_count(name) → uint",
        "returns": "uint",
        "args": {
          "name": {
            "doc": "name :: string: Prototype name of the entity.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Count entities of given type\n\nParameters\n\nname :: string: Prototype name of the entity.Return value Number of entities of given prototype belonging to this force\n\nNote: This function has O(1) time complexity as entity counts are kept and maintained in the game engine.",
        "type": "function"
      },
      "get_friend": {
        "name": "get_friend(other) → boolean",
        "returns": "boolean",
        "args": {
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          }
        },
        "doc": "Is this force a friend\n\nParameters\n\nother :: string or LuaForce",
        "type": "function"
      },
      "get_gun_speed_modifier": {
        "name": "get_gun_speed_modifier(ammo) → double",
        "returns": "double",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          }
        },
        "doc": "Parametersammo :: string: Ammo category",
        "type": "function"
      },
      "get_item_launched": {
        "name": "get_item_launched(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string: The item to get",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Gets the count of a given item launched in rockets. \n\nParameters\n\nitem :: string: The item to getReturn value The count of the item that has been launched.",
        "type": "function"
      },
      "get_saved_technology_progress": {
        "name": "get_saved_technology_progress(technology) → double",
        "returns": "double",
        "args": {
          "technology": {
            "doc": "technology :: string or LuaTechnology: The technology",
            "name": "technology",
            "type": "string or LuaTechnology"
          }
        },
        "doc": "Gets the saved progress for the given technology or nil if there is no saved progress. \n\nParameters\n\ntechnology :: string or LuaTechnology: The technologyReturn value The progress as a percent.",
        "type": "function"
      },
      "get_spawn_position": {
        "name": "get_spawn_position(surface) → Position",
        "returns": "Position",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameterssurface :: SurfaceSpecification",
        "type": "function"
      },
      "get_trains": {
        "name": "get_trains(surface) → array of LuaTrain",
        "returns": "array of LuaTrain",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): If given only trains on the surface are returned.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameterssurface :: SurfaceSpecification (optional): If given only trains on the surface are returned.",
        "type": "function"
      },
      "get_turret_attack_modifier": {
        "name": "get_turret_attack_modifier(turret) → double",
        "returns": "double",
        "args": {
          "turret": {
            "doc": "turret :: string: Turret prototype name",
            "name": "turret",
            "type": "string"
          }
        },
        "doc": "Parametersturret :: string: Turret prototype name",
        "type": "function"
      },
      "ghost_time_to_live": {
        "name": "ghost_time_to_live",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The time, in ticks, before a placed ghost disappears."
      },
      "inserter_stack_size_bonus": {
        "name": "inserter_stack_size_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The inserter stack size bonus for non stack inserters"
      },
      "is_chunk_charted": {
        "name": "is_chunk_charted(surface, position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: ChunkPosition: Position of the chunk.",
            "name": "position",
            "type": "ChunkPosition"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Has a chunk been charted\n\nParameters\n\nsurface :: SurfaceSpecificationposition :: ChunkPosition: Position of the chunk.",
        "type": "function"
      },
      "is_chunk_visible": {
        "name": "is_chunk_visible(surface, position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: ChunkPosition",
            "name": "position",
            "type": "ChunkPosition"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Is the given chunk currently charted and visible (not covered by fogg of war) on the map. \n\nParameters\n\nsurface :: SurfaceSpecificationposition :: ChunkPosition",
        "type": "function"
      },
      "is_pathfinder_busy": {
        "name": "is_pathfinder_busy() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Is pathfinder busy? When the pathfinder is busy, it won't accept any more pathfinding requests.",
        "type": "function"
      },
      "item_production_statistics": {
        "name": "item_production_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The item production statistics for this force."
      },
      "items_launched": {
        "name": "items_launched",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "All of the items that have been launched in rockets."
      },
      "kill_all_units": {
        "name": "kill_all_units()",
        "args": {},
        "doc": "Kill all units and flush the pathfinder.",
        "type": "function"
      },
      "kill_count_statistics": {
        "name": "kill_count_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The kill counter statistics for this force."
      },
      "laboratory_speed_modifier": {
        "name": "laboratory_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "logistic_networks": {
        "name": "logistic_networks",
        "type": "dictionary string → array of LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": "List of logistic networks, grouped by surface."
      },
      "manual_crafting_speed_modifier": {
        "name": "manual_crafting_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Multiplier of the manual crafting speed. Default value is 0. The actual crafting speed will be multiplied by 1 + manual_crafting_speed_modifier.\nExampleDouble the player's crafting speed game.player.force.manual_crafting_speed_modifier = 1"
      },
      "manual_mining_speed_modifier": {
        "name": "manual_mining_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Multiplier of the manual mining speed. Default value is 0. The actual mining speed will be multiplied by 1 + manual_mining_speed_modifier.\nExampleDouble the player's mining speed game.player.force.manual_mining_speed_modifier = 1"
      },
      "maximum_following_robot_count": {
        "name": "maximum_following_robot_count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Maximum number of follower robots."
      },
      "mining_drill_productivity_bonus": {
        "name": "mining_drill_productivity_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the force.\nExamplePrints \"player\" game.player.print(game.player.force.name)"
      },
      "players": {
        "name": "players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "Players belonging to this force."
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console of all players on this force\n\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "quickbar_count": {
        "name": "quickbar_count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of character quick bars."
      },
      "rechart": {
        "name": "rechart()",
        "args": {},
        "doc": "Force a rechart of the whole chart.",
        "type": "function"
      },
      "recipes": {
        "name": "recipes",
        "type": "custom dictionary string → LuaRecipe",
        "mode": "[Read-only]",
        "doc": "Recipes available to this force, indexed by their name.\nExamplePrints the category of the given recipe game.player.print(game.player.force.recipes[\"transport-belt\"].category)"
      },
      "research_all_technologies": {
        "name": "research_all_technologies(include_disabled_prototypes)",
        "args": {
          "include_disabled_prototypes": {
            "doc": "include_disabled_prototypes (optional): If technologies that are explicitly disabled in the prototype are also researched. This defaults to false.",
            "name": "include_disabled_prototypes"
          }
        },
        "doc": "Research all technologies. \n\nParameters\n\ninclude_disabled_prototypes (optional): If technologies that are explicitly disabled in the prototype are also researched. This defaults to false.",
        "type": "function"
      },
      "research_progress": {
        "name": "research_progress",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Progress of current research, as a number in range [0, 1]."
      },
      "reset_recipes": {
        "name": "reset_recipes()",
        "args": {},
        "doc": "Load the original version of all recipes from the prototypes.",
        "type": "function"
      },
      "reset_technologies": {
        "name": "reset_technologies()",
        "args": {},
        "doc": "Load the original versions of technologies from prototypes. Preserves research state of technologies.",
        "type": "function"
      },
      "reset_technology_effects": {
        "name": "reset_technology_effects()",
        "args": {},
        "doc": "Reapplies all possible research effects, including unlocked recipes. Any custom chages are lost. Preserves research state of technologies.",
        "type": "function"
      },
      "reset": {
        "name": "reset()",
        "args": {},
        "doc": "Reset everything. All technologies are set to not researched, all modifiers are set to default values.",
        "type": "function"
      },
      "rockets_launched": {
        "name": "rockets_launched",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The number of rockets launched."
      },
      "set_ammo_damage_modifier": {
        "name": "set_ammo_damage_modifier(ammo, modifier)",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          },
          "modifier": {
            "doc": "modifier :: double",
            "name": "modifier",
            "type": "double"
          }
        },
        "doc": "Parametersammo :: string: Ammo categorymodifier :: double",
        "type": "function"
      },
      "set_cease_fire": {
        "name": "set_cease_fire(other, cease_fire)",
        "args": {
          "cease_fire": {
            "doc": "cease_fire :: boolean: When true, this force won't attack other; otherwise it will.",
            "name": "cease_fire",
            "type": "boolean"
          },
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          }
        },
        "doc": "Stop attacking members of a given force\n\nParameters\n\nother :: string or LuaForcecease_fire :: boolean: When true, this force won't attack other; otherwise it will.",
        "type": "function"
      },
      "set_friend": {
        "name": "set_friend(other, cease_fire)",
        "args": {
          "cease_fire": {
            "doc": "cease_fire :: boolean",
            "name": "cease_fire",
            "type": "boolean"
          },
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          }
        },
        "doc": "Friends have unrestricted access to buildings and turrets won't fire at them\n\nParameters\n\nother :: string or LuaForcecease_fire :: boolean",
        "type": "function"
      },
      "set_gun_speed_modifier": {
        "name": "set_gun_speed_modifier(ammo, modifier)",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          },
          "modifier": {
            "doc": "modifier :: double",
            "name": "modifier",
            "type": "double"
          }
        },
        "doc": "Parametersammo :: string: Ammo categorymodifier :: double",
        "type": "function"
      },
      "set_item_launched": {
        "name": "set_item_launched(item, count)",
        "args": {
          "count": {
            "doc": "count :: uint: The count to set",
            "name": "count",
            "type": "uint"
          },
          "item": {
            "doc": "item :: string: The item to set",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Sets the count of a given item launched in rockets. \n\nParameters\n\nitem :: string: The item to setcount :: uint: The count to set",
        "type": "function"
      },
      "set_saved_technology_progress": {
        "name": "set_saved_technology_progress(technology, double)",
        "args": {
          "double": {
            "doc": "double: Progress as a percent. Set to nil to remove the saved progress.",
            "name": "double"
          },
          "technology": {
            "doc": "technology :: string or LuaTechnology: The technology",
            "name": "technology",
            "type": "string or LuaTechnology"
          }
        },
        "doc": "Sets the saved progress for the given technology. The technology must not be in progress, must not be completed, and the new progress must be < 100%. \n\nParameters\n\ntechnology :: string or LuaTechnology: The technologydouble: Progress as a percent. Set to nil to remove the saved progress.",
        "type": "function"
      },
      "set_spawn_position": {
        "name": "set_spawn_position(position, surface)",
        "args": {
          "position": {
            "doc": "position :: Position: The new position on the given surface.",
            "name": "position",
            "type": "Position"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification: Surface to set the spawn position for.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parametersposition :: Position: The new position on the given surface.surface :: SurfaceSpecification: Surface to set the spawn position for.",
        "type": "function"
      },
      "set_turret_attack_modifier": {
        "name": "set_turret_attack_modifier(turret, modifier)",
        "args": {
          "modifier": {
            "doc": "modifier :: double",
            "name": "modifier",
            "type": "double"
          },
          "turret": {
            "doc": "turret :: string: Turret prototype name",
            "name": "turret",
            "type": "string"
          }
        },
        "doc": "Parametersturret :: string: Turret prototype namemodifier :: double",
        "type": "function"
      },
      "stack_inserter_capacity_bonus": {
        "name": "stack_inserter_capacity_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of items that can be transferred by stack inserters"
      },
      "technologies": {
        "name": "technologies",
        "type": "custom dictionary string → LuaTechnology",
        "mode": "[Read-only]",
        "doc": "Technologies owned by this force, indexed by their name.\nExampleResearches the technology for the player's force game.player.force.technologies[\"iron-working\"].researched = true"
      },
      "train_braking_force_bonus": {
        "name": "train_braking_force_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "unchart_chunk": {
        "name": "unchart_chunk(position, surface)",
        "args": {
          "position": {
            "doc": "position :: ChunkPosition: The chunk position to unchart.",
            "name": "position",
            "type": "ChunkPosition"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification: Surface to unchart on.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parametersposition :: ChunkPosition: The chunk position to unchart.surface :: SurfaceSpecification: Surface to unchart on.",
        "type": "function"
      },
      "worker_robots_speed_modifier": {
        "name": "worker_robots_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "worker_robots_storage_bonus": {
        "name": "worker_robots_storage_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "zoom_to_world_blueprint_enabled": {
        "name": "zoom_to_world_blueprint_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to create new blueprints using empty blueprint item when using zoom-to-world."
      },
      "zoom_to_world_deconstruction_planner_enabled": {
        "name": "zoom_to_world_deconstruction_planner_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to use deconstruction planner when using zoom-to-world."
      },
      "zoom_to_world_enabled": {
        "name": "zoom_to_world_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to use zoom-to-world on map."
      },
      "zoom_to_world_ghost_building_enabled": {
        "name": "zoom_to_world_ghost_building_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to build ghosts through blueprint or direct ghost placement, or \"mine\" ghosts when using zoom-to-world."
      },
      "zoom_to_world_selection_tool_enabled": {
        "name": "zoom_to_world_selection_tool_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to use custom selection tools when using zoom-to-world."
      }
    }
  },
  "LuaFluidPrototype": {
    "name": "LuaFluidPrototype",
    "type": "LuaFluidPrototype",
    "doc": "Prototype of a fluid.",
    "properties": {
      "base_color": {
        "name": "base_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": ""
      },
      "default_temperature": {
        "name": "default_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Default temperature of the fluid."
      },
      "flow_color": {
        "name": "flow_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": ""
      },
      "flow_to_energy_ratio": {
        "name": "flow_to_energy_ratio",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "How much will a volume of fluid transferred be converted to energy."
      },
      "gas_temperature": {
        "name": "gas_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this prototype."
      },
      "heat_capacity": {
        "name": "heat_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "How much energy the fluid will generate at max temperature assuming 100% efficiency steam engine."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "max_push_amount": {
        "name": "max_push_amount",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "max_temperature": {
        "name": "max_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum temperature the fluid can reach."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string for this prototype."
      },
      "pressure_to_speed_ratio": {
        "name": "pressure_to_speed_ratio",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "How much pressure -- difference in fluid levels -- will be converted to speed."
      },
      "ratio_to_push": {
        "name": "ratio_to_push",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this prototype."
      }
    }
  },
  "LuaFluidBox": {
    "name": "LuaFluidBox",
    "type": "LuaFluidBox",
    "doc": "An array of fluid boxes. Entities may contain more than one fluid box, and some can change the number\n of fluid boxes -- for instance, an assembling machine will change its number of fluid boxes depending\n on its active recipe.",
    "properties": {
      "get_capacity": {
        "name": "get_capacity(index) → double",
        "returns": "double",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "The capacity of the given fluidbox index. \n\nParameters\n\nindex :: uint",
        "type": "function"
      },
      "get_connections": {
        "name": "get_connections() → array of LuaFluidBox",
        "returns": "array of LuaFluidBox",
        "args": {},
        "doc": "The fluidbox connections for the given fluidbox index.",
        "type": "function"
      },
      "operator []": {
        "name": "operator []",
        "mode": "[Read-only]",
        "doc": "Access, set or clear a fluid box. The index must always be in bounds (see LuaFluidBox::operator #); new fluidboxes may not be added or removed using this operator. If the given fluid box doesn't contain any fluid, nil is returned. Similarly, nil can be written to a fluid box to remove all fluid from it.",
        "type": "operator []"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of fluid boxes."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity that owns this fluidbox."
      }
    }
  },
  "LuaFlowStatistics": {
    "name": "LuaFlowStatistics",
    "type": "LuaFlowStatistics",
    "doc": "Encapsulates statistic data for different parts of the game.",
    "properties": {
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force these statistics belong to."
      },
      "get_input_count": {
        "name": "get_input_count(string)",
        "args": {
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Gets the total input count for a given prototype\n\nParameters\n\nstring: The prototype name.",
        "type": "function"
      },
      "get_output_count": {
        "name": "get_output_count(string)",
        "args": {
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Gets the total output count for a given prototype\n\nParameters\n\nstring: The prototype name.",
        "type": "function"
      },
      "input_counts": {
        "name": "input_counts",
        "type": "dictionary string → array of uint64 or double",
        "mode": "[Read-only]",
        "doc": "List of input counts indexed by name <> value."
      },
      "on_flow": {
        "name": "on_flow(string, count)",
        "args": {
          "count": {
            "doc": "count :: float: The count: positive or negative determines if the value goes in the input or output statistics.",
            "name": "count",
            "type": "float"
          },
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Adds a value to this flow statistics. \n\nParameters\n\nstring: The prototype name.count :: float: The count: positive or negative determines if the value goes in the input or output statistics.",
        "type": "function"
      },
      "output_counts": {
        "name": "output_counts",
        "type": "dictionary string → array of uint64 or double",
        "mode": "[Read-only]",
        "doc": "List of output counts indexed by name <> value."
      },
      "set_input_count": {
        "name": "set_input_count(string, count)",
        "args": {
          "count": {
            "doc": "count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
            "name": "count",
            "type": "uint64 or double"
          },
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Sets the total input count for a given prototype\n\nParameters\n\nstring: The prototype name.count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
        "type": "function"
      },
      "set_output_count": {
        "name": "set_output_count(string, count)",
        "args": {
          "count": {
            "doc": "count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
            "name": "count",
            "type": "uint64 or double"
          },
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Sets the total output count for a given prototype\n\nParameters\n\nstring: The prototype name.count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
        "type": "function"
      }
    }
  },
  "LuaEquipmentPrototype": {
    "name": "LuaEquipmentPrototype",
    "type": "LuaEquipmentPrototype",
    "doc": "Prototype of a modular equipment.",
    "properties": {
      "burner_prototype": {
        "name": "burner_prototype",
        "type": "LuaBurnerPrototype",
        "mode": "[Read-only]",
        "doc": "The burner energy source prototype this equpment uses or nil."
      },
      "electric_energy_source_prototype": {
        "name": "electric_energy_source_prototype",
        "type": "LuaElectricEnergySourcePrototype",
        "mode": "[Read-only]",
        "doc": "The electric energy source prototype this equipment uses or nil."
      },
      "energy_consumption": {
        "name": "energy_consumption",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "energy_per_shield": {
        "name": "energy_per_shield",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The energy per shield point restored. 0 for non-shield equipment."
      },
      "energy_production": {
        "name": "energy_production",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The max power generated by this equipment."
      },
      "energy_source": {
        "name": "energy_source",
        "mode": "[Read-only]",
        "doc": "The energy source prototype for the equipment.",
        "type": "energy_source"
      },
      "equipment_categories": {
        "name": "equipment_categories",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "Category names for this equipment. These categories will be used to determine whether this equpiment is allowed in a particular equpiment grid. \nSee also * LuaEquipmentGridPrototype::equipment_categories"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "logistic_parameters": {
        "name": "logistic_parameters",
        "mode": "[Read-only]",
        "doc": "The logistic parameters for roboport equipment",
        "type": "logistic_parameters"
      },
      "movement_bonus": {
        "name": "movement_bonus",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is MovementBonusEquipmentPrototype"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "night_vision_tint": {
        "name": "night_vision_tint",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is NightVisionEquipmentPrototype"
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "shape": {
        "name": "shape",
        "mode": "[Read-only]",
        "doc": "Shape of this equipment prototype. It is a table: \n * width :: uint\n * height :: uint",
        "type": "shape"
      },
      "shield": {
        "name": "shield",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The shield value of this equipment. 0 for non-shield equipment."
      },
      "take_result": {
        "name": "take_result",
        "type": "LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "The result item when taking this equipment out of an equipment grid. nil if there is no result item."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this equipment prototype."
      }
    }
  },
  "LuaEquipmentGridPrototype": {
    "name": "LuaEquipmentGridPrototype",
    "type": "LuaEquipmentGridPrototype",
    "doc": "Prototype of a virtual signal.",
    "properties": {
      "equipment_categories": {
        "name": "equipment_categories",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "Equipment category names for the categories that may be inserted into this equipment grid. The grid will accept any equipment that has at least one category in this list. \nSee also * LuaEquipmentPrototype::equipment_categories"
      },
      "height": {
        "name": "height",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "width": {
        "name": "width",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaEquipmentGrid": {
    "name": "LuaEquipmentGrid",
    "type": "LuaEquipmentGrid",
    "doc": "An equipment grid is the inside of a power armour.",
    "properties": {
      "available_in_batteries": {
        "name": "available_in_batteries",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The total energy stored in all batteries in the equipment grid."
      },
      "battery_capacity": {
        "name": "battery_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Total energy storage capacity of all batteries in the equipment grid."
      },
      "can_move": {
        "name": "can_move{equipment=…, position=…} → boolean",
        "returns": "boolean",
        "args": {
          "equipment": {
            "doc": "Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it",
            "name": "equipment",
            "type": "LuaEquipment"
          },
          "equipment=…": {
            "name": "equipment=…",
            "type": "equipment=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Check whether moving an equipment would succeed\n\nParameters\n\n Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Clear all equipment from the grid. I.e. remove it without actually returning it.",
        "type": "function"
      },
      "equipment": {
        "name": "equipment",
        "type": "array of LuaEquipment",
        "mode": "[Read-only]",
        "doc": "All the equipment in this grid."
      },
      "generator_energy": {
        "name": "generator_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Total energy per tick generated by the equipment inside this grid."
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get counts of all equipment in this grid.\nReturn value The counts, indexed by equipment names.",
        "type": "function"
      },
      "get": {
        "name": "get(position) → LuaEquipment",
        "returns": "LuaEquipment",
        "args": {
          "position": {
            "doc": "position :: Position: The position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find equipment in the Equipment Grid based off a position\n\nParameters\n\nposition :: Position: The positionReturn value The found equipment, or nil if equipment could not be found at the given position.",
        "type": "function"
      },
      "height": {
        "name": "height",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Height of the equipment grid."
      },
      "max_shield": {
        "name": "max_shield",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The maximum amount of shields this equipment grid has."
      },
      "max_solar_energy": {
        "name": "max_solar_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum energy per tick that can be created by any solar panels in the equipment grid. Actual generated energy varies depending on the daylight levels."
      },
      "move": {
        "name": "move{equipment=…, position=…} → boolean",
        "returns": "boolean",
        "args": {
          "equipment": {
            "doc": "Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it",
            "name": "equipment",
            "type": "LuaEquipment"
          },
          "equipment=…": {
            "name": "equipment=…",
            "type": "equipment=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Move an equipment within this grid\n\nParameters\n\n Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it\nReturn value true if the equipment was successfully moved.",
        "type": "function"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "put": {
        "name": "put{name=…, position=…} → LuaEquipment",
        "returns": "LuaEquipment",
        "args": {
          "name": {
            "doc": "Table with the following fields:  * name :: string: Equipment prototype name\n * position :: Position (optional): Grid position to put the equipment in.",
            "name": "name",
            "type": "string"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Insert an equipment into the grid\n\nParameters\n\n Table with the following fields:  * name :: string: Equipment prototype name\n * position :: Position (optional): Grid position to put the equipment in.\nReturn value The newly-added equipment, or nil if the equipment could not be added.",
        "type": "function"
      },
      "shield": {
        "name": "shield",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The amount of shields this equipment grid has."
      },
      "take_all": {
        "name": "take_all() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Remove all equipment from the grid.\nReturn value Count of each removed equipment, indexed by their prototype names.",
        "type": "function"
      },
      "take": {
        "name": "take{position=…, equipment=…} → SimpleItemStack",
        "returns": "SimpleItemStack",
        "args": {
          "equipment=…": {
            "name": "equipment=…",
            "type": "equipment=…"
          },
          "position": {
            "doc": "Table with the following fields:  * position :: Position (optional): Take the equipment that contains this position in the grid.\n * equipment :: LuaEquipment (optional): Take this exact equipment.\n\nEither position or equipment must be specified.",
            "name": "position",
            "type": "Position"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Remove an equipment from the grid\n\nParameters\n\n Table with the following fields:  * position :: Position (optional): Take the equipment that contains this position in the grid.\n * equipment :: LuaEquipment (optional): Take this exact equipment.\nEither position or equipment must be specified.Return value The removed equipment, or nil if no equipment was removed.",
        "type": "function"
      },
      "width": {
        "name": "width",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Width of the equipment grid."
      }
    }
  },
  "LuaEquipment": {
    "name": "LuaEquipment",
    "type": "LuaEquipment",
    "doc": "An item in one's power armour.",
    "properties": {
      "burner": {
        "name": "burner",
        "type": "LuaBurner",
        "mode": "[Read-only]",
        "doc": "The burner energy source for this equipment or nil if there isn't one."
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Current available energy."
      },
      "generator_power": {
        "name": "generator_power",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Energy generated per tick."
      },
      "max_energy": {
        "name": "max_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum amount of energy that can be stored in this equipment."
      },
      "max_shield": {
        "name": "max_shield",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum shield value."
      },
      "max_solar_power": {
        "name": "max_solar_power",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum solar power generated."
      },
      "movement_bonus": {
        "name": "movement_bonus",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Movement speed bonus."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this equipment."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Position of this equipment in the equipment grid."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEquipmentPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "shape": {
        "name": "shape",
        "mode": "[Read-only]",
        "doc": "Shape of this equipment. It is a table: \n * width :: uint\n * height :: uint",
        "type": "shape"
      },
      "shield": {
        "name": "shield",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Current shield value of the equipment. \n\nNote: Can't be set higher than LuaEquipment::max_shield."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this equipment."
      }
    }
  },
  "LuaEntityPrototype": {
    "name": "LuaEntityPrototype",
    "type": "LuaEntityPrototype",
    "doc": "Prototype of an entity.",
    "properties": {
      "additional_pastable_entities": {
        "name": "additional_pastable_entities",
        "type": "array of LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "Entities this entity can be pasted onto in addition to the normal allowed ones."
      },
      "allow_copy_paste": {
        "name": "allow_copy_paste",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "When false copy-paste is not allowed for this entity."
      },
      "attack_parameters": {
        "name": "attack_parameters",
        "mode": "[Read-only]",
        "doc": "The attack parameters for this entity or nil if the entity doesn't use attack parameters.",
        "type": "attack_parameters"
      },
      "attack_result": {
        "name": "attack_result",
        "mode": "[Read-only]",
        "doc": "The attack result of this entity if the entity has one else nil.",
        "type": "attack_result"
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[Read-only]",
        "doc": "Autoplace specification for this entity prototype. nil if none."
      },
      "belt_speed": {
        "name": "belt_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The speed of this transport belt or nil if this isn't a transport belt related prototype."
      },
      "braking_force": {
        "name": "braking_force",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The braking force of this vehicle prototype or nil if not a vehicle prototype."
      },
      "build_base_evolution_requirement": {
        "name": "build_base_evolution_requirement",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The evolution requirement to build this entity as a base when expanding enemy bases."
      },
      "building_grid_bit_shift": {
        "name": "building_grid_bit_shift",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The log2 of grid size of the building"
      },
      "burner_prototype": {
        "name": "burner_prototype",
        "type": "LuaBurnerPrototype",
        "mode": "[Read-only]",
        "doc": "The burner energy source prototype this entity uses or nil."
      },
      "collision_box": {
        "name": "collision_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for collision checking."
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "The collison masks this entity uses"
      },
      "consumption": {
        "name": "consumption",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The energy consumption of this car prototype or nil if not a car prototype."
      },
      "corpses": {
        "name": "corpses",
        "type": "dictionary string → LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "Corpses used when this entity is destroyed. It is a dictionary indexed by the corpse's prototype name."
      },
      "crafting_categories": {
        "name": "crafting_categories",
        "type": "dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "The crafting categories this entity supports. Only meaningful when this is a crafting-machine or player entity type. \n\nNote: The value in the dictionary is meaningless and exists just to allow the dictionary type for easy lookup."
      },
      "crafting_speed": {
        "name": "crafting_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The crafting speed of this crafting-machine or nil."
      },
      "created_effect": {
        "name": "created_effect",
        "mode": "[Read-only]",
        "doc": "The trigger run when this entity is created or nil.",
        "type": "created_effect"
      },
      "created_smoke": {
        "name": "created_smoke",
        "mode": "[Read-only]",
        "doc": "The smoke trigger run when this entity is built or nil.",
        "type": "created_smoke"
      },
      "drawing_box": {
        "name": "drawing_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for drawing the entity icon."
      },
      "effectivity": {
        "name": "effectivity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The effectivity of this car prototype, generator prototype or nil."
      },
      "electric_energy_source_prototype": {
        "name": "electric_energy_source_prototype",
        "type": "LuaElectricEnergySourcePrototype",
        "mode": "[Read-only]",
        "doc": "The electric energy source prototype this entity uses or nil."
      },
      "emissions_per_tick": {
        "name": "emissions_per_tick",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of pollution emissions per tick this entity will create."
      },
      "enemy_map_color": {
        "name": "enemy_map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The enemy map color used when charting this entity."
      },
      "energy_per_move": {
        "name": "energy_per_move",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The energy consumed per tile moved for this flying robot or nil."
      },
      "energy_per_tick": {
        "name": "energy_per_tick",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The energy consumed per tick for this flying robot or nil."
      },
      "energy_usage": {
        "name": "energy_usage",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The direct energy usage of this entity or nil if this entity doesn't have a direct energy usage."
      },
      "fast_replaceable_group": {
        "name": "fast_replaceable_group",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The group of mutually fast-replaceable entities. Possibly nil."
      },
      "final_attack_result": {
        "name": "final_attack_result",
        "mode": "[Read-only]",
        "doc": "The final attack result for projectiles nil if not a projectile",
        "type": "final_attack_result"
      },
      "flags": {
        "name": "flags",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "The entity prototype flags for this entitiy."
      },
      "fluid_usage_per_tick": {
        "name": "fluid_usage_per_tick",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The fluid usage of this generator prototype or nil."
      },
      "friction_force": {
        "name": "friction_force",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The friction of this vehicle prototype or nil if not a vehicle prototype."
      },
      "friendly_map_color": {
        "name": "friendly_map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The friendly map color used when charting this entity."
      },
      "get_inventory_size": {
        "name": "get_inventory_size(index) → uint",
        "returns": "uint",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the base size of the given inventory on this entity or nil if the given inventory doesn't exist. \n\nParameters\n\nindex :: uint",
        "type": "function"
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this entity."
      },
      "guns": {
        "name": "guns",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "The guns this car prototype uses or nil if not a car prototype."
      },
      "has_flag": {
        "name": "has_flag(flag) → boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "doc": "flag :: string: The flag to check. Must be one of  *  \"pushable\"\n *  \"placeable-neutral\"\n *  \"placeable-player\"\n *  \"placeable-enemy\"\n *  \"placeable-off-grid\"\n *  \"player-creation\"\n *  \"building-direction-8-way\"\n *  \"filter-directions\"\n *  \"fast-replaceable-no-build-while-moving\"\n *  \"breaths-air\"\n *  \"not-repairable\"\n *  \"not-on-map\"\n *  \"not-blueprintable\"\n *  \"not-deconstructable\"",
            "name": "flag",
            "type": "string"
          }
        },
        "doc": "Does this prototype have a flag enabled\n\nParameters\n\nflag :: string: The flag to check. Must be one of  *  \"pushable\"\n *  \"placeable-neutral\"\n *  \"placeable-player\"\n *  \"placeable-enemy\"\n *  \"placeable-off-grid\"\n *  \"player-creation\"\n *  \"building-direction-8-way\"\n *  \"filter-directions\"\n *  \"fast-replaceable-no-build-while-moving\"\n *  \"breaths-air\"\n *  \"not-repairable\"\n *  \"not-on-map\"\n *  \"not-blueprintable\"\n *  \"not-deconstructable\"",
        "type": "function"
      },
      "healing_per_tick": {
        "name": "healing_per_tick",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Amount this entity can heal per tick."
      },
      "infinite_depletion_resource_amount": {
        "name": "infinite_depletion_resource_amount",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Every time this infinite resource 'ticks' down it is reduced by this amount. nil when not a resource. Meaningless if this isn't an infinite type resource."
      },
      "infinite_resource": {
        "name": "infinite_resource",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this resource infinite? Will be nil when used on a non-resource."
      },
      "ingredient_count": {
        "name": "ingredient_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The max number of ingredients this crafting-machine prototype supports or nil if this isn't a crafting-machine prototype."
      },
      "instruments": {
        "name": "instruments",
        "type": "array of ProgrammableSpeakerInstrument",
        "mode": "[Read-only]",
        "doc": "The instruments for this programmable speaker or nil."
      },
      "items_to_place_this": {
        "name": "items_to_place_this",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Items that when placed will produce this entity. It is a dictionary indexed by the item prototype name."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "logistic_mode": {
        "name": "logistic_mode",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The logistic mode of this logistic container or nil if this isn't a logistic container prototype."
      },
      "loot": {
        "name": "loot",
        "type": "Loot",
        "mode": "[Read-only]",
        "doc": "Loot that will be dropped when this entity is killed. nil if there is no loot."
      },
      "map_color": {
        "name": "map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The map color used when charting this entity if a friendly or enemy color isn't defined or nil."
      },
      "max_circuit_wire_distance": {
        "name": "max_circuit_wire_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The maximum circuit wire distance for this entity. 0 when the entity doesn't support circuit wires."
      },
      "max_energy": {
        "name": "max_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The max energy for this flying robot or nil."
      },
      "max_energy_usage": {
        "name": "max_energy_usage",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The theoretical maximum energy usage for this entity."
      },
      "max_health": {
        "name": "max_health",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Max health of this entity. Will be 0 if this is not an entity with health."
      },
      "max_payload_size": {
        "name": "max_payload_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The max payload size of this logistics or construction robot or nil."
      },
      "max_polyphony": {
        "name": "max_polyphony",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The maximum polyphony for this programmable speaker or nil."
      },
      "max_to_charge": {
        "name": "max_to_charge",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The maximum energy for this flying robot above which it won't try to recharge when stationing or nil."
      },
      "max_underground_distance": {
        "name": "max_underground_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The max underground distance for underground belts and underground pipes or nil if this isn't one of those prototypes."
      },
      "max_wire_distance": {
        "name": "max_wire_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The maximum wire distance for this electric pole/power switch or nil if this isn't an electric pole/power switch."
      },
      "maximum_temperature": {
        "name": "maximum_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The maximum fluid temperature of this generator prototype or nil."
      },
      "min_to_charge": {
        "name": "min_to_charge",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The minimum energy for this flying robot before it tries to recharge or nil."
      },
      "mineable_properties": {
        "name": "mineable_properties",
        "mode": "[Read-only]",
        "doc": "Table with the following fields:  * minable :: boolean: Is this entity mineable at all?\n * hardness :: double: Mining hardness.\n * mining_time :: double: Energy required to mine an entity.\n * mining_particle :: string (optional): Prototype name of the particle produced when mining this entity. Will only be present if this entity produces any particle during mining.\n * products :: array of Product: Products obtained by mining this entity.\n * fluid_amount :: double (optional): The required fluid amount if any.\n * required_fluid :: string (optional): The prototype name of the required fluid if any.\n * mining_trigger (optional): The mining trigger if any.",
        "type": "mineable_properties"
      },
      "minimum_resource_amount": {
        "name": "minimum_resource_amount",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Minimum amount of this resource. Will be nil when used on a non-resource."
      },
      "mining_drill_radius": {
        "name": "mining_drill_radius",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The mining radius of this mining drill prototype or nil if this isn't a mining drill prototype."
      },
      "mining_power": {
        "name": "mining_power",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The mining power of this mining drill prototype or nil if this isn't a mining drill prototype."
      },
      "mining_speed": {
        "name": "mining_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The mining speed of this mining drill/character prototype or nil."
      },
      "module_inventory_size": {
        "name": "module_inventory_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The module inventory size or nil if this entity doesn't suport modules."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "normal_resource_amount": {
        "name": "normal_resource_amount",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The normal amount for this resource. nil when not a resource."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "remains_when_mined": {
        "name": "remains_when_mined",
        "type": "array of LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The remains left behind when this entity is mined."
      },
      "repair_speed_modifier": {
        "name": "repair_speed_modifier",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Repair-speed modifier for this entity. Actual repair speed will be tool_repair_speed * entity_repair_speed_modifier. May be nil."
      },
      "resistances": {
        "name": "resistances",
        "type": "Resistances",
        "mode": "[Read-only]",
        "doc": ""
      },
      "resource_category": {
        "name": "resource_category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Category of this resource. \"basic-solid\", \"basic-fluid\" or nil (when not a resource)."
      },
      "result_units": {
        "name": "result_units",
        "type": "array of UnitSpawnDefinition",
        "mode": "[Read-only]",
        "doc": "The result units and spawn points with weight and evolution factor for a biter spawner entity.\n Each UnitSpawnDefinition is a table: \n * unit :: string: Prototype name of the unit that would be spawned\n * spawn_points :: array of SpawnPoint: Each SpawnPoint is a table:  * evolution_factor :: double: Evolution factor for which this weight applies.\n    * weight :: double: Probability of spawning this unit at this evolution factor."
      },
      "rotation_speed": {
        "name": "rotation_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The rotation speed of this car prototype or nil if not a car prototype."
      },
      "selectable_in_game": {
        "name": "selectable_in_game",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this entity selectable?"
      },
      "selection_box": {
        "name": "selection_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for drawing selection."
      },
      "shooting_cursor_size": {
        "name": "shooting_cursor_size",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The cursor size used when shooting at this entity."
      },
      "spawn_cooldown": {
        "name": "spawn_cooldown",
        "mode": "[Read-only]",
        "doc": "The spawning cooldown for this enemy spawner prototype or nil. \nTable with the following fields:  * min :: double\n * max :: double",
        "type": "spawn_cooldown"
      },
      "speed": {
        "name": "speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The default speed of this flying robot or nil."
      },
      "speed_multiplier_when_out_of_energy": {
        "name": "speed_multiplier_when_out_of_energy",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The speed multiplier when this flying robot is out of energy or nil."
      },
      "sticker_box": {
        "name": "sticker_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used to attach sticker type entities."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this entity."
      },
      "supply_area_distance": {
        "name": "supply_area_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The supply area of this electric pole, beacon, or nil if this is neither."
      },
      "tank_driving": {
        "name": "tank_driving",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this car prototype uses tank controls to drive or nil if this is not a car prototype."
      },
      "target_temperature": {
        "name": "target_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The target temperature of this boiler prototyper or nil."
      },
      "turret_range": {
        "name": "turret_range",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "turret_rotation_speed": {
        "name": "turret_rotation_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The turret rotation speed of this car prototype or nil if not a car prototype."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this prototype."
      },
      "weight": {
        "name": "weight",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The weight of this vehicle prototype or nil if not a vehicle prototype."
      }
    }
  },
  "LuaEntity": {
    "name": "LuaEntity",
    "type": "LuaEntity",
    "doc": "The primary interface for interacting with entities through the Lua API.\n Entity is everything on the map except tiles.",
    "properties": {
      "active": {
        "name": "active",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Deactivating an entity will stop all its operations (car will stop moving, inserters will stop working, fish will stop moving etc)\n\nNote: Entities that are are not active naturally can't be set to be active (setting it to be active will do nothing\n\nNote: Ghosts, simple smoke, and corpses can't be modified at this time\n\nNote: It is even possible to set the player to not be active, so he can't move and perform most of the tasks."
      },
      "add_market_item": {
        "name": "add_market_item{price=…, offer=…}",
        "args": {
          "offer=…": {
            "name": "offer=…",
            "type": "offer=…"
          },
          "price": {
            "doc": "Table with the following fields:  * price: list of prices, every element is 2 item table, first is the item name, the second is count.\n * offer :: Modifier: The action that will take place when a player accepts the offer. Usuallly a \"give-item\" modifier.",
            "name": "price",
            "type": "Modifier"
          },
          "price=…": {
            "name": "price=…",
            "type": "price=…"
          }
        },
        "doc": "Offer a thing on the market. \n\nParameters\n\n Table with the following fields:  * price: list of prices, every element is 2 item table, first is the item name, the second is count.\n * offer :: Modifier: The action that will take place when a player accepts the offer. Usuallly a \"give-item\" modifier.\nExampleAdds market offer, 1 copper ore for 10 iron ore. market.add_market_item{price={{\"iron-ore\", 10}}, offer={type=\"give-item\", item=\"copper-ore\"}} ExampleAdds market offer, 1 copper ore for 5 iron ore and 5 stone ore. market.add_market_item{price={{\"iron-ore\", 5}, {\"stone\", 5}}, offer={type=\"give-item\", item=\"copper-ore\"}} Can only be used if this is Market",
        "type": "function"
      },
      "alert_parameters": {
        "name": "alert_parameters",
        "type": "ProgrammableSpeakerAlertParameters",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is ProgrammableSpeaker"
      },
      "amount": {
        "name": "amount",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Count of resource units contained. \nCan only be used if this is ResourceEntity"
      },
      "backer_name": {
        "name": "backer_name",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The name of a backer (of Factorio) assigned to a lab or train station / stop. \n\nNote: Only useable on entities that support backer names. Returns nil when the entity doesn't support a backer name."
      },
      "belt_to_ground_type": {
        "name": "belt_to_ground_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "\"input\" or \"output\", depending on whether this underground belt goes down or up. \nCan only be used if this is TransportBeltToGround"
      },
      "bonus_mining_progress": {
        "name": "bonus_mining_progress",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The bonus mining progress for this mining drill or nil if this isn't a mining drill."
      },
      "bonus_progress": {
        "name": "bonus_progress",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The current productivity bonus progress, as a number in range [0, 1]. \nCan only be used if this is CraftingMachine"
      },
      "bounding_box": {
        "name": "bounding_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": ""
      },
      "burner": {
        "name": "burner",
        "type": "LuaBurner",
        "mode": "[Read-only]",
        "doc": "The burner energy source for this entity or nil if there isn't one."
      },
      "cancel_deconstruction": {
        "name": "cancel_deconstruction(force)",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force who did the deconstruction order.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Cancels deconstruction if it is scheduled, does nothing otherwise. \n\nParameters\n\nforce :: string or LuaForce: The force who did the deconstruction order.",
        "type": "function"
      },
      "chain_signal_state": {
        "name": "chain_signal_state",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The state of this chain signal. \nCan only be used if this is RailChainSignal"
      },
      "circuit_connected_entities": {
        "name": "circuit_connected_entities",
        "mode": "[Read-only]",
        "doc": "Entities connected to this entity via the circuit network. It is a table: \n * red :: array of LuaEntity: Entities connected via the red wire.\n * green :: array of LuaEntity: Entities connected via the green wire.",
        "type": "circuit_connected_entities"
      },
      "circuit_connection_definitions": {
        "name": "circuit_connection_definitions",
        "type": "array of CircuitConnectionDefinition",
        "mode": "[Read-only]",
        "doc": "The connection definition for entities connected to this entity via the circuit network. \n Each CircuitConnectionDefinition is a table: \n * wire :: defines.wire_type: Wire color, either defines.wire_type.red or defines.wire_type.green.\n * target_entity :: LuaEntity\n * source_circuit_id :: uint\n * target_circuit_id :: uint"
      },
      "clear_request_slot": {
        "name": "clear_request_slot(slot)",
        "args": {
          "slot": {
            "doc": "slot :: uint: The slot index.",
            "name": "slot",
            "type": "uint"
          }
        },
        "doc": "Clear a logistic requester slot\n\nParameters\n\nslot :: uint: The slot index\n\nNote: Useable only on entities that have requester slots.",
        "type": "function"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The character or rolling stock color."
      },
      "connect_neighbour": {
        "name": "connect_neighbour(target)",
        "args": {
          "target": {
            "doc": "target :: LuaEntity or table:  *  To connect two electric poles, target has to be a LuaEntity specifying another electric pole. This will connect them with copper cable.\n *  To connect two devices with wire, this parameter is a table:  * wire :: defines.wire_type: Wire colour, either defines.wire_type.red or defines.wire_type.green.\n    * target_entity :: LuaEntity: The entity to connect the wire to\n    * source_circuit_id :: uint (optional): Mandatory if the source entity has more than one circuit connector.\n    * target_circuit_id :: uint (optional): Mandatory if the target entity has more than one circuit connector.",
            "name": "target",
            "type": "LuaEntity or table"
          }
        },
        "doc": "Connect two devices with wire or cable\n\nParameters\n\ntarget :: LuaEntity or table:  *  To connect two electric poles, target has to be a LuaEntity specifying another electric pole. This will connect them with copper cable.\n *  To connect two devices with wire, this parameter is a table:  * wire :: defines.wire_type: Wire colour, either defines.wire_type.red or defines.wire_type.green.\n    * target_entity :: LuaEntity: The entity to connect the wire to\n    * source_circuit_id :: uint (optional): Mandatory if the source entity has more than one circuit connector.\n    * target_circuit_id :: uint (optional): Mandatory if the target entity has more than one circuit connector.",
        "type": "function"
      },
      "connect_rolling_stock": {
        "name": "connect_rolling_stock(direction) → boolean",
        "returns": "boolean",
        "args": {
          "direction": {
            "doc": "direction :: defines.rail_direction",
            "name": "direction",
            "type": "defines.rail_direction"
          }
        },
        "doc": "Connects the rolling stock in the given direction. \n\nParameters\n\ndirection :: defines.rail_directionReturn value If any connection was made",
        "type": "function"
      },
      "consumption_modifier": {
        "name": "consumption_modifier",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Multiplies the the energy consumption. \nCan only be used if this is Car"
      },
      "copy_settings": {
        "name": "copy_settings(entity) → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          }
        },
        "doc": "Copies settings from the given entity onto this entity. \n\nParameters\n\nentity :: LuaEntityReturn value Any items removed from this entity as a result of copying the settings.",
        "type": "function"
      },
      "crafting_progress": {
        "name": "crafting_progress",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The current crafting progress, as a number in range [0, 1]. \nCan only be used if this is CraftingMachine"
      },
      "damage_dealt": {
        "name": "damage_dealt",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The damage dealt by this turret. \nCan only be used if this is Turret"
      },
      "damage": {
        "name": "damage(damage, force, type) → float",
        "returns": "float",
        "args": {
          "damage": {
            "doc": "damage :: float: The amount of damage to be done",
            "name": "damage",
            "type": "float"
          },
          "force": {
            "doc": "force :: string or LuaForce: The force that will be doing the damage.",
            "name": "force",
            "type": "string or LuaForce"
          },
          "type": {
            "doc": "type :: string (optional): The type of damage to be done.",
            "name": "type",
            "type": "string"
          }
        },
        "doc": "Damages the entity. \n\nParameters\n\ndamage :: float: The amount of damage to be doneforce :: string or LuaForce: The force that will be doing the damage.type :: string (optional): The type of damage to be done.Return value the total damage actually applied after resistances.Can only be used if this is EntityWithHealth",
        "type": "function"
      },
      "destroy": {
        "name": "destroy() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Destroys the entity. \nReturn value if the entity was actually destroyed\n\nNote: Not all entities can be destroyed - things such as rails under trains cannot be destroyed until the train is moved or destroyed.",
        "type": "function"
      },
      "destructible": {
        "name": "destructible",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When the entity is not destructible it can't be damaged\n\nNote: An indestructible entity can still be mined\n\nNote: Entities that are indestructible naturally (they have no health, like smoke, resource etc) can't be set to be destructible."
      },
      "die": {
        "name": "die()",
        "args": {},
        "doc": "Immediately kills the entity. Doesn't attribute the kill to any force. Doesn't care whether the entity is destroyable or damageable. Error is thrown when called on entity that doesn't have health. Unlike LuaEntity::destroy, die will trigger on_entity_diedand the entity will drop loot and corpse if it have any.",
        "type": "function"
      },
      "direction": {
        "name": "direction",
        "type": "defines.direction",
        "mode": "[Read-Write]",
        "doc": "The current direction this entity is facing."
      },
      "disconnect_neighbour": {
        "name": "disconnect_neighbour(target)",
        "args": {
          "target": {
            "doc": "target :: defines.wire_type or LuaEntity or table (optional):  *  To remove all copper cables, leave this parameter out: pole.disconnect_neighbour()\n *  To remove all wires of a specific colour, pass defines.wire_type.red or defines.wire_type.green.\n *  To remove a specific copper cable between two poles, target can be a LuaEntityspecifying the other pole. E.g. pole1.disconnect_neighbour(pole2).\n *  To remove a specific red or green wire, pass a table in the same format as for LuaEntity::connect_neighbour:  * wire :: defines.wire_type: Wire colour\n    * target_entity :: LuaEntity\n    * source_circuit_id :: uint (optional)\n    * target_circuit_id :: uint (optional)",
            "name": "target",
            "type": "defines.wire_type or LuaEntity or table"
          }
        },
        "doc": "Disconnect wires or cables\n\nParameters\n\ntarget :: defines.wire_type or LuaEntity or table (optional):  *  To remove all copper cables, leave this parameter out: pole.disconnect_neighbour()\n *  To remove all wires of a specific colour, pass defines.wire_type.red or defines.wire_type.green.\n *  To remove a specific copper cable between two poles, target can be a LuaEntityspecifying the other pole. E.g. pole1.disconnect_neighbour(pole2).\n *  To remove a specific red or green wire, pass a table in the same format as for LuaEntity::connect_neighbour:  * wire :: defines.wire_type: Wire colour\n    * target_entity :: LuaEntity\n    * source_circuit_id :: uint (optional)\n    * target_circuit_id :: uint (optional)",
        "type": "function"
      },
      "disconnect_rolling_stock": {
        "name": "disconnect_rolling_stock(direction) → boolean",
        "returns": "boolean",
        "args": {
          "direction": {
            "doc": "direction :: defines.rail_direction",
            "name": "direction",
            "type": "defines.rail_direction"
          }
        },
        "doc": "Tries to disconnect this rolling stock in the given direction. \n\nParameters\n\ndirection :: defines.rail_directionReturn value If anything was disconnected",
        "type": "function"
      },
      "drop_position": {
        "name": "drop_position",
        "type": "Position",
        "mode": "[Read-Write]",
        "doc": "Position where the entity puts its stuff. \n\nNote: Meaningful only for entities that put stuff somewhere, such as mining drills or inserters. Mining drills can't have their drop position changed."
      },
      "drop_target": {
        "name": "drop_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity this entity is putting its stuff to or nil if there is no such entity. \n\nNote: Meaningful only for entities that put stuff somewhere, such as mining drills or inserters."
      },
      "effectivity_modifier": {
        "name": "effectivity_modifier",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Multiplies the acceleration the vehicle can create for one unit of energy. By default is 1.\nCan only be used if this is Car"
      },
      "electric_buffer_size": {
        "name": "electric_buffer_size",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The buffer size for the electric energy source or nil if the entity doesn't have an electric energy source\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_drain": {
        "name": "electric_drain",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The electric drain for the electric energy source or nil if the entity doesn't have an electric energy source\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_emissions": {
        "name": "electric_emissions",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The emissions size for the electric energy source or nil if the entity doesn't have an electric energy source\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_input_flow_limit": {
        "name": "electric_input_flow_limit",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The input flow limit for the electric energy source or nil if the entity doesn't have an electric energy source\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_network_statistics": {
        "name": "electric_network_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The electric network statitiscs for this electric pole."
      },
      "electric_output_flow_limit": {
        "name": "electric_output_flow_limit",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The output flow limit for the electric energy source or nil if the entity doesn't have an electric energy source\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Energy stored in the entity (heat in furnace, energy stored in electrical devices etc.). always 0 for entities that don't have the concept of energy stored inside.\nExample game.player.print(\"Machine energy: \" .. game.player.selected.energy .. \"J\")\ngame.player.selected.energy = 3000"
      },
      "filter_slot_count": {
        "name": "filter_slot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of filter slots this inserter or loader has. 0 if not an inserter or loader."
      },
      "fluidbox": {
        "name": "fluidbox",
        "type": "LuaFluidBox",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "friction_modifier": {
        "name": "friction_modifier",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Multiplies the car friction rate.\nExampleThis will allow the car to go much faster game.player.vehicle.friction_modifier = 0.5Can only be used if this is Car"
      },
      "get_burnt_result_inventory": {
        "name": "get_burnt_result_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "The burnt result inventory for this entity or nil if this entity doesn't have a burnt result inventory.",
        "type": "function"
      },
      "get_circuit_network": {
        "name": "get_circuit_network(wire, circuit_connector) → LuaCircuitNetwork",
        "returns": "LuaCircuitNetwork",
        "args": {
          "circuit_connector": {
            "doc": "circuit_connector :: defines.circuit_connector_id (optional): The connector to get circuit network for. Must be specified for entities with more than one circuit network connector.",
            "name": "circuit_connector",
            "type": "defines.circuit_connector_id"
          },
          "wire": {
            "doc": "wire :: defines.wire_type: Wire colour of the network connected to this entity.",
            "name": "wire",
            "type": "defines.wire_type"
          }
        },
        "doc": "Parameterswire :: defines.wire_type: Wire colour of the network connected to this entity.circuit_connector :: defines.circuit_connector_id (optional): The connector to get circuit network for. Must be specified for entities with more than one circuit network connector.Return value The circuit network or nil.",
        "type": "function"
      },
      "get_connected_rail": {
        "name": "get_connected_rail{rail_direction=…, rail_connection_direction=…} → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "rail_connection_direction=…": {
            "name": "rail_connection_direction=…",
            "type": "rail_connection_direction=…"
          },
          "rail_direction": {
            "doc": "Table with the following fields:  * rail_direction :: defines.rail_direction\n * rail_connection_direction :: defines.rail_connection_direction",
            "name": "rail_direction",
            "type": "defines.rail_direction"
          },
          "rail_direction=…": {
            "name": "rail_direction=…",
            "type": "rail_direction=…"
          }
        },
        "doc": "Parameters Table with the following fields:  * rail_direction :: defines.rail_direction\n * rail_connection_direction :: defines.rail_connection_direction\nReturn value Rail connected in the specified manner to this one.Can only be used if this is Rail",
        "type": "function"
      },
      "get_control_behavior": {
        "name": "get_control_behavior() → LuaControlBehavior",
        "returns": "LuaControlBehavior",
        "args": {},
        "doc": "Gets the control behavior of the entity (if any).\nReturn value The control behavior or nil.",
        "type": "function"
      },
      "get_filter": {
        "name": "get_filter(uint) → string",
        "returns": "string",
        "args": {
          "uint": {
            "doc": "uint: Slot to get the filter of.",
            "name": "uint"
          }
        },
        "doc": "Get the filter for a slot in an inserter or a loader\n\nParameters\n\nuint: Slot to get the filter of.Return value Prototype name of the entity being filtered; nil if the given slot has no filter\n\nNote: The inserter/loader must allow filters.",
        "type": "function"
      },
      "get_fuel_inventory": {
        "name": "get_fuel_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "The fuel inventory for this entity or nil if this entity doesn't have a fuel inventory.",
        "type": "function"
      },
      "get_logistic_point": {
        "name": "get_logistic_point(defines.logistic_member_index) → LuaLogisticPoint or array of LuaLogisticPoint",
        "returns": "LuaLogisticPoint or array of LuaLogisticPoint",
        "args": {
          "defines.logistic_member_index": {
            "doc": "defines.logistic_member_index (optional)",
            "name": "defines.logistic_member_index"
          }
        },
        "doc": "Gets the LuaLogisticPoint specified by the given index or if not given returns all of the points this entity owns. \n\nParameters\n\ndefines.logistic_member_index (optional\n\nNote: When the index is not given for most entities this will be a single entry. For some (such as the player character) this can be zero or more.",
        "type": "function"
      },
      "get_market_items": {
        "name": "get_market_items() → array of Offer",
        "returns": "array of Offer",
        "args": {},
        "doc": "Get all offers in a market as an array. \nReturn value See LuaEntity::add_market_item for the format of an Offer.Can only be used if this is Market",
        "type": "function"
      },
      "get_module_inventory": {
        "name": "get_module_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "Return value Inventory for storing modules of this entity; nil if this entity has no module inventory.",
        "type": "function"
      },
      "get_or_create_control_behavior": {
        "name": "get_or_create_control_behavior() → LuaControlBehavior",
        "returns": "LuaControlBehavior",
        "args": {},
        "doc": "Gets (and or creates if needed) the control behavior of the entity.\nReturn value The control behavior or nil.",
        "type": "function"
      },
      "get_output_inventory": {
        "name": "get_output_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "Gets the entities output inventory if it has one. \nReturn value a reference to the entities output inventory.",
        "type": "function"
      },
      "get_request_slot": {
        "name": "get_request_slot(slot) → SimpleItemStack",
        "returns": "SimpleItemStack",
        "args": {
          "slot": {
            "doc": "slot :: uint: The slot index.",
            "name": "slot",
            "type": "uint"
          }
        },
        "doc": "Get a logistic requester slot\n\nParameters\n\nslot :: uint: The slot index.Return value Contents of the specified slot; nil if the given slot contains no request\n\nNote: Useable only on entities that have requester slots.",
        "type": "function"
      },
      "get_transport_line": {
        "name": "get_transport_line(index) → LuaTransportLine",
        "returns": "LuaTransportLine",
        "args": {
          "index": {
            "doc": "index :: uint: Index of the requested transport line.",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Get a transport line of a belt\n\nParameters\n\nindex :: uint: Index of the requested transport line.Can only be used if this is TransportBeltConnectable",
        "type": "function"
      },
      "ghost_localised_description": {
        "name": "ghost_localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is Ghost"
      },
      "ghost_localised_name": {
        "name": "ghost_localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the entity or tile contained in this ghost. \nCan only be used if this is Ghost"
      },
      "ghost_name": {
        "name": "ghost_name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the entity or tile contained in this ghost \nCan only be used if this is Ghost"
      },
      "ghost_prototype": {
        "name": "ghost_prototype",
        "type": "LuaEntityPrototype or LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": "The prototype of the entity or tile contained in this ghost. \nCan only be used if this is Ghost"
      },
      "ghost_type": {
        "name": "ghost_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The prototype type of the entity or tile contained in this ghost. \nCan only be used if this is Ghost"
      },
      "graphics_variation": {
        "name": "graphics_variation",
        "type": "uint8",
        "mode": "[Read-Write]",
        "doc": "The graphics variation for this entity or nil if this entity doesn't use graphics varaitions."
      },
      "grid": {
        "name": "grid",
        "type": "LuaEquipmentGrid",
        "mode": "[Read-only]",
        "doc": "The equipment grid or nil if this entity doesn't have an equipment grid."
      },
      "has_command": {
        "name": "has_command() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Has this unit been assigned a command? \nCan only be used if this is Unit",
        "type": "function"
      },
      "has_flag": {
        "name": "has_flag(flag) → boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "doc": "flag :: string: The flag to test",
            "name": "flag",
            "type": "string"
          }
        },
        "doc": "Test whether this entity's prototype has a flag set\n\nParameters\n\nflag :: string: The flag to testReturn value true if the entity has the given flag set\n\nNote: entity.has_flag(f) is a shortcut for entity.prototype.has_flag(f).",
        "type": "function"
      },
      "health": {
        "name": "health",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Health of the entity. Setting health to less than 0 will set health to 0, entities with 0 health can not be attacked. Setting health to higher than max health will set health to max health\n\nNote: If used on an entity that doesn't support health, this field will be nil."
      },
      "held_stack": {
        "name": "held_stack",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The item stack currently held in an inserter's hand. \nCan only be used if this is Inserter"
      },
      "held_stack_position": {
        "name": "held_stack_position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Current position of the inserter's \"hand\". \nCan only be used if this is Inserter"
      },
      "initial_amount": {
        "name": "initial_amount",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Count of initial resource units contained. \n\nNote: If this is not an infinite resource reading will give nil and writing will give an error.Can only be used if this is ResourceEntity"
      },
      "inserter_stack_size_override": {
        "name": "inserter_stack_size_override",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Sets the stack size limit on this inserter. If the stack size is > than the force stack size limit the value is ignored. \n\nNote: Set to 0 to reset."
      },
      "is_closed": {
        "name": "is_closed() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently closed.Can only be used if this is Gate",
        "type": "function"
      },
      "is_closing": {
        "name": "is_closing() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently closingCan only be used if this is Gate",
        "type": "function"
      },
      "is_crafting": {
        "name": "is_crafting() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this machine is currently crafting.Can only be used if this is CraftingMachine",
        "type": "function"
      },
      "is_opened": {
        "name": "is_opened() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently opened.Can only be used if this is Gate",
        "type": "function"
      },
      "is_opening": {
        "name": "is_opening() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently opening.Can only be used if this is Gate",
        "type": "function"
      },
      "item_requests": {
        "name": "item_requests",
        "type": "dictionary string → uint",
        "mode": "[Read-Write]",
        "doc": "Items this ghost will request when revived or items this item request proxy is reqeusting. Result is a dictionary mapping each item prototype name to the required count."
      },
      "kills": {
        "name": "kills",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The number of units killed by this turret. \nCan only be used if this is Turret"
      },
      "last_user": {
        "name": "last_user",
        "type": "LuaPlayer",
        "mode": "[Read-Write]",
        "doc": "The player who built the entity \nCan only be used if this is EntityWithOwner"
      },
      "launch_rocket": {
        "name": "launch_rocket() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if the rocket was successfully launched. Return value of falsemeans the silo is not ready for launch.Can only be used if this is RocketSilo",
        "type": "function"
      },
      "loader_type": {
        "name": "loader_type",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "\"input\" or \"output\", depending on whether this loader puts to or gets from a container. \nCan only be used if this is Loader"
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the entity."
      },
      "logistic_cell": {
        "name": "logistic_cell",
        "type": "LuaLogisticCell",
        "mode": "[Read-only]",
        "doc": "The logistic cell this entity is a part of. Will be nil if this entity is not a part of any logistic cell."
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": "The logistic network this entity is a part of."
      },
      "minable": {
        "name": "minable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Note: Not minable entities can still be destroyed\n\nNote: Entities that are not minable naturally (like smoke, player, enemy units etc) can't be set to minable."
      },
      "mining_progress": {
        "name": "mining_progress",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The mining progress for this mining drill or nil if this isn't a mining drill."
      },
      "mining_target": {
        "name": "mining_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The mining target or nil if none \nCan only be used if this is MiningDrill"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the entity prototype. E.g. \"inserter\" or \"filter-inserter\"."
      },
      "neighbours": {
        "name": "neighbours",
        "type": "dictionary string → array of LuaEntity or array of LuaEntity or LuaEntity",
        "mode": "[Read-only]",
        "doc": "*  When called on an electric pole, this is a dictionary of all connections, indexed by the strings \"copper\", \"red\", and \"green\".\n *  When called on a pipe-connectable entity, this is an array of all entities this pipe is connected to.\n *  When called on an underground transport belt, this is the other end of the underground belt connection, or nil if none."
      },
      "operable": {
        "name": "operable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Player can't open gui of this entity and he can't quick insert/input stuff in to the entity when it is not operable."
      },
      "order_deconstruction": {
        "name": "order_deconstruction(force) → boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force whose robots are supposed to do the deconstruction.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Sets the entity to be deconstructed by construction robots. \n\nParameters\n\nforce :: string or LuaForce: The force whose robots are supposed to do the deconstruction.Return value if the entity was marked for deconstruction.",
        "type": "function"
      },
      "orientation": {
        "name": "orientation",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The smooth orientation."
      },
      "parameters": {
        "name": "parameters",
        "type": "ProgrammableSpeakerParameters",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is ProgrammableSpeaker"
      },
      "passenger": {
        "name": "passenger",
        "type": "LuaEntity or LuaPlayer",
        "mode": "[Read-Write]",
        "doc": "Setting to nil forces the character/player out of the vehicle, setting to a new character/player forces any existing passenger out and the given character/player becomes the new passenger\n\nNote: May be nil if the car contains no passenger.Can only be used if this is Vehicle"
      },
      "pickup_position": {
        "name": "pickup_position",
        "type": "Position",
        "mode": "[Read-Write]",
        "doc": "Where the inserter will pick up items from. \nCan only be used if this is Inserter"
      },
      "pickup_target": {
        "name": "pickup_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity the inserter will attempt to pick up from. For example, this can be a transport belt or a storage chest. \nCan only be used if this is Inserter"
      },
      "play_note": {
        "name": "play_note(instrument, note) → boolean",
        "returns": "boolean",
        "args": {
          "instrument": {
            "doc": "instrument :: uint",
            "name": "instrument",
            "type": "uint"
          },
          "note": {
            "doc": "note :: uint",
            "name": "note",
            "type": "uint"
          }
        },
        "doc": "Plays a note with the given instrument and note. \n\nParameters\n\ninstrument :: uintnote :: uintReturn value If the request was successful.Can only be used if this is ProgrammableSpeaker",
        "type": "function"
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player connected to this character. \nCan only be used if this is Character"
      },
      "power_production": {
        "name": "power_production",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The power production specific to the ElectricEnergyInterface entity type. \nCan only be used if this is ElectricEnergyInterface"
      },
      "power_usage": {
        "name": "power_usage",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The power usage specific to the ElectricEnergyInterface entity type. \nCan only be used if this is ElectricEnergyInterface"
      },
      "products_finished": {
        "name": "products_finished",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is CraftingMachine"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The entity prototype of this entity."
      },
      "proxy_target": {
        "name": "proxy_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The target entity for this item-request-proxy or nil"
      },
      "recipe": {
        "name": "recipe",
        "type": "LuaRecipe",
        "mode": "[Read-Write]",
        "doc": "Current recipe being assembled by this machine. \nCan only be used if this is CraftingMachine"
      },
      "remove_market_item": {
        "name": "remove_market_item(offer) → boolean",
        "returns": "boolean",
        "args": {
          "offer": {
            "doc": "offer :: uint: Index of offer to remove.",
            "name": "offer",
            "type": "uint"
          }
        },
        "doc": "Remove an offer from a market. \n\nParameters\n\noffer :: uint: Index of offer to remove.Return value true if the offer was successfully removed; false when the given index was not valid.Can only be used if this is Market",
        "type": "function"
      },
      "request_slot_count": {
        "name": "request_slot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of request slots this entity has."
      },
      "request_to_close": {
        "name": "request_to_close(force)",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force that requests the gate to be closed.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Parametersforce :: string or LuaForce: The force that requests the gate to be closed.Can only be used if this is Gate",
        "type": "function"
      },
      "request_to_open": {
        "name": "request_to_open(force, extra_time)",
        "args": {
          "extra_time": {
            "doc": "extra_time :: uint (optional): Extra ticks to stay open.",
            "name": "extra_time",
            "type": "uint"
          },
          "force": {
            "doc": "force :: string or LuaForce: The force that requests the gate to be open.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Parametersforce :: string or LuaForce: The force that requests the gate to be open.extra_time :: uint (optional): Extra ticks to stay open.Can only be used if this is Gate",
        "type": "function"
      },
      "revive": {
        "name": "revive(return_item_request_proxy) → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {
          "return_item_request_proxy": {
            "doc": "return_item_request_proxy :: boolean (optional): If true the function will return item request proxy as the third parameter.",
            "name": "return_item_request_proxy",
            "type": "boolean"
          }
        },
        "doc": "Revive a ghost. I.e. turn it from a ghost to a real entity or tile\n\nParameters\n\nreturn_item_request_proxy :: boolean (optional): If true the function will return item request proxy as the third parameter.Return value Any items the new real entity collided with or nil if the ghost could not be revived\n\nNote: If this is an entity ghost and it is successfully revived this will also return the revived entity or nil as a second return value and possibly item request proxy as the third parameter depending on value of return_item_request_proxy.",
        "type": "function"
      },
      "rocket_parts": {
        "name": "rocket_parts",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of rocket parts in the silo. \nCan only be used if this is RocketSilo"
      },
      "rotatable": {
        "name": "rotatable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When entity is not to be rotatable (inserter, transport belt etc), it can't be rotated by player using the R key\n\nNote: Entities that are not rotatable naturally (like chest or furnace) can't be set to be rotatable."
      },
      "selected_gun_index": {
        "name": "selected_gun_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Index of the currently selected weapon slot of this character. \nCan only be used if this is Character"
      },
      "set_command": {
        "name": "set_command(command)",
        "args": {
          "command": {
            "doc": "command :: Command",
            "name": "command",
            "type": "Command"
          }
        },
        "doc": "Give the entity a command. \n\nParameters\n\ncommand :: CommandCan only be used if this is Unit",
        "type": "function"
      },
      "set_filter": {
        "name": "set_filter(uint, string)",
        "args": {
          "string": {
            "doc": "string: Prototype name of the entity to filter.",
            "name": "string"
          },
          "uint": {
            "doc": "uint: Slot to set the filter of.",
            "name": "uint"
          }
        },
        "doc": "Set the filter for a slot in an inserter or a loade\n\nParameters\n\nuint: Slot to set the filter of.string: Prototype name of the entity to filter\n\nNote: The inserter/loader must allow filters.",
        "type": "function"
      },
      "set_request_slot": {
        "name": "set_request_slot(request, slot)",
        "args": {
          "request": {
            "doc": "request :: SimpleItemStack: What to request.",
            "name": "request",
            "type": "SimpleItemStack"
          },
          "slot": {
            "doc": "slot :: uint: The slot index.",
            "name": "slot",
            "type": "uint"
          }
        },
        "doc": "Set a logistic requester slot\n\nParameters\n\nrequest :: SimpleItemStack: What to request.slot :: uint: The slot index\n\nNote: Useable only on entities that have requester slots.",
        "type": "function"
      },
      "shooting_target": {
        "name": "shooting_target",
        "type": "LuaEntity",
        "mode": "[Read-Write]",
        "doc": "The shooting target for this turret or nil."
      },
      "signal_state": {
        "name": "signal_state",
        "type": "defines.signal_state",
        "mode": "[Read-only]",
        "doc": "The state of this rail signal. \nCan only be used if this is RailSignal"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The current speed of the car. \nCan only be used if this is Car"
      },
      "stack": {
        "name": "stack",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemEntity"
      },
      "stickers": {
        "name": "stickers",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "The sticker entities attached to this entity."
      },
      "supports_backer_name": {
        "name": "supports_backer_name() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this entity supports a backer name.",
        "type": "function"
      },
      "supports_direction": {
        "name": "supports_direction",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Whether the entity has direction. When it is false for this entity, it will always return north direction when asked for."
      },
      "temperature": {
        "name": "temperature",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The temperature of this entities heat energy source if this entity uses a heat energy source or nil."
      },
      "text": {
        "name": "text",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The text of this flying-text entity. \nCan only be used if this is FlyingText"
      },
      "time_to_live": {
        "name": "time_to_live",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The ticks left for a ghost before it's destroyed. Cannot be set higher than LuaForce::ghost_time_to_live of the entity's force\n\nNote: set to uint32 max (4,294,967,295) to never expire.Can only be used if this is Ghost"
      },
      "to_be_deconstructed": {
        "name": "to_be_deconstructed(force) → boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force which ordered the deconstruction. This parameter is is currently unused; it exists only for forward compatibility of the API.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Is this entity marked for deconstruction? \n\nParameters\n\nforce :: string or LuaForce: The force which ordered the deconstruction. This parameter is is currently unused; it exists only for forward compatibility of the API.",
        "type": "function"
      },
      "to_be_looted": {
        "name": "to_be_looted",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Will this entity be picked up automatically when the player walks over it? \nCan only be used if this is ItemEntity"
      },
      "train": {
        "name": "train",
        "type": "LuaTrain",
        "mode": "[Read-only]",
        "doc": "The train this rolling stock belongs to. \nCan only be used if this is RollingStock"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The entity prototype type of this entity."
      },
      "unit_group": {
        "name": "unit_group",
        "type": "LuaUnitGroup",
        "mode": "[Read-only]",
        "doc": "The unit group this unit is a member of, or nil if none. \nCan only be used if this is Unit"
      },
      "unit_number": {
        "name": "unit_number",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The unit number or nil if the entity doesn't have one. This is unique for every entity that has one."
      },
      "update_connections": {
        "name": "update_connections()",
        "args": {},
        "doc": "Reconnect loader and beacon connections to entities that might have been teleported out or in by the script. The game doesn't do this automatically as we don't want to loose performance by checking this in normal games.",
        "type": "function"
      }
    }
  },
  "LuaDecorativePrototype": {
    "name": "LuaDecorativePrototype",
    "type": "LuaDecorativePrototype",
    "doc": "Prototype of an optimized decorative.",
    "properties": {
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[Read-only]",
        "doc": "Autoplace specification for this decorative prototype. nil if none."
      },
      "collision_box": {
        "name": "collision_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for collision checking."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      }
    }
  },
  "LuaDamagePrototype": {
    "name": "LuaDamagePrototype",
    "type": "LuaDamagePrototype",
    "doc": "Prototype of a damage.",
    "properties": {
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      }
    }
  },
  "LuaCustomTable": {
    "name": "LuaCustomTable",
    "type": "LuaCustomTable",
    "doc": "Lazily evaluated table.\n For performance reasons, we sometimes return a custom table-like type instead of a native Lua table. This custom\n type lazily constructs the necessary Lua wrappers of the corresponding C++ objects, therefore preventing their\n unnecessary construction in some cases.",
    "properties": {
      "operator []": {
        "name": "operator []",
        "mode": "[Read-Write]",
        "doc": "Access an element of this custom table.",
        "type": "operator []"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of elements in this table."
      }
    }
  },
  "LuaElectricEnergySourcePrototype": {
    "name": "LuaElectricEnergySourcePrototype",
    "type": "LuaElectricEnergySourcePrototype",
    "doc": "Prototype of an electric energy source.",
    "properties": {
      "buffer_capacity": {
        "name": "buffer_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "drain": {
        "name": "drain",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "effectivity": {
        "name": "effectivity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "emissions": {
        "name": "emissions",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "input_flow_limit": {
        "name": "input_flow_limit",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "output_flow_limit": {
        "name": "output_flow_limit",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "render_no_network_icon": {
        "name": "render_no_network_icon",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": ""
      },
      "render_no_power_icon": {
        "name": "render_no_power_icon",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": ""
      },
      "usage_priority": {
        "name": "usage_priority",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaCustomChartTag": {
    "name": "LuaCustomChartTag",
    "type": "LuaCustomChartTag",
    "doc": "A custom tag that shows on the map view.",
    "properties": {
      "destroy": {
        "name": "destroy()",
        "args": {},
        "doc": "Destroys this tag.",
        "type": "function"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force this tag belongs to."
      },
      "icon": {
        "name": "icon",
        "type": "SignalID",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "last_user": {
        "name": "last_user",
        "type": "LuaPlayer",
        "mode": "[Read-Write]",
        "doc": "The player who last edited this tag."
      },
      "orientation": {
        "name": "orientation",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The orientation of this tag."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "The position of this tag."
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[Read-only]",
        "doc": "The surface this tag belongs to."
      },
      "tag_number": {
        "name": "tag_number",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The unique ID for this tag on this force."
      },
      "target": {
        "name": "target",
        "type": "LuaEntity",
        "mode": "[Read-Write]",
        "doc": "The entity target if any or nil. This is almost always empty."
      },
      "text": {
        "name": "text",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": ""
      }
    }
  },
  "LuaControl": {
    "name": "LuaControl",
    "type": "LuaControl",
    "doc": "This is an abstract base class containing the common functionality between LuaPlayer and character entities\n (see LuaEntity). When accessing these members through a LuaEntity, it must refer to a character\n entity.",
    "properties": {
      "auto_trash_filters": {
        "name": "auto_trash_filters",
        "type": "dictionary string → uint",
        "mode": "[Read-Write]",
        "doc": "The auto-trash filters. The keys are item prototype names, the values are the slot values\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).ExampleThis will set the auto-trash slots to keep only at most 20 iron plates and 42 copper wires in the player's inventory. game.player.auto_trash_filters = {[\"iron-plate\"] = 20, [\"copper-cable\"] = 42}"
      },
      "begin_crafting": {
        "name": "begin_crafting{count=…, recipe=…, silent=…} → uint",
        "returns": "uint",
        "args": {
          "count": {
            "doc": "* count :: uint: The count to craft.\n * recipe :: string or LuaRecipe: The recipe to craft.\n * silent :: boolean (optional): If false and the recipe can't be crafted the requested number of times printing the failure is skipped.",
            "name": "count",
            "type": "uint"
          },
          "count=…": {
            "name": "count=…",
            "type": "count=…"
          },
          "recipe=…": {
            "name": "recipe=…",
            "type": "recipe=…"
          },
          "silent=…": {
            "name": "silent=…",
            "type": "silent=…"
          }
        },
        "doc": "Begins crafting the given count of the given recip\n\nParameters\n\n  * count :: uint: The count to craft.\n * recipe :: string or LuaRecipe: The recipe to craft.\n * silent :: boolean (optional): If false and the recipe can't be crafted the requested number of times printing the failure is skipped.\nReturn value The count that was actually started crafting.",
        "type": "function"
      },
      "build_distance": {
        "name": "build_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The build distance of this character or max uint when not a character or player connected to a character."
      },
      "can_insert": {
        "name": "can_insert(items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items that would be inserted.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Can at least some items be inserted\n\nParameters\n\nitems :: SimpleItemStack: Items that would be inserted.Return value true if at least a part of the given items could be inserted into this inventory.",
        "type": "function"
      },
      "can_reach_entity": {
        "name": "can_reach_entity(entity) → boolean",
        "returns": "boolean",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          }
        },
        "doc": "Can a given entity be opened or accessed\n\nParameters\n\nentity :: LuaEntity",
        "type": "function"
      },
      "cancel_crafting": {
        "name": "cancel_crafting(options)",
        "args": {
          "options": {
            "doc": "options: :  * index :: uint: The crafting queue index.\n * count :: uint: The count to cancel crafting.",
            "name": "options",
            "type": "uint"
          }
        },
        "doc": "Cancels crafting the given count of the given crafting queue inde\n\nParameters\n\noptions: :  * index :: uint: The crafting queue index.\n * count :: uint: The count to cancel crafting.",
        "type": "function"
      },
      "character_build_distance_bonus": {
        "name": "character_build_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_crafting_speed_modifier": {
        "name": "character_crafting_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_health_bonus": {
        "name": "character_health_bonus",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_inventory_slots_bonus": {
        "name": "character_inventory_slots_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_item_drop_distance_bonus": {
        "name": "character_item_drop_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_item_pickup_distance_bonus": {
        "name": "character_item_pickup_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_logistic_slot_count_bonus": {
        "name": "character_logistic_slot_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_loot_pickup_distance_bonus": {
        "name": "character_loot_pickup_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_maximum_following_robot_count_bonus": {
        "name": "character_maximum_following_robot_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_mining_speed_modifier": {
        "name": "character_mining_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_reach_distance_bonus": {
        "name": "character_reach_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_resource_reach_distance_bonus": {
        "name": "character_resource_reach_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_running_speed_modifier": {
        "name": "character_running_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_trash_slot_count_bonus": {
        "name": "character_trash_slot_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "cheat_mode": {
        "name": "cheat_mode",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When true hand crafting is free and instant"
      },
      "clear_gui_arrow": {
        "name": "clear_gui_arrow()",
        "args": {},
        "doc": "Removes the arrow created by set_gui_arrow.",
        "type": "function"
      },
      "clear_items_inside": {
        "name": "clear_items_inside()",
        "args": {},
        "doc": "Remove all items from this entity.",
        "type": "function"
      },
      "clear_selected_entity": {
        "name": "clear_selected_entity()",
        "args": {},
        "doc": "Unselect any selected entity.",
        "type": "function"
      },
      "crafting_queue": {
        "name": "crafting_queue",
        "type": "array of CraftingQueueItem",
        "mode": "[Read-only]",
        "doc": "Gets the current crafting queue items.\n Each CraftingQueueItem is a table: \n * index :: uint: The crafting queue index\n * recipe :: string: The recipe.\n * count :: uint: The count being crafted."
      },
      "crafting_queue_size": {
        "name": "crafting_queue_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Size of the crafting queue."
      },
      "cursor_stack": {
        "name": "cursor_stack",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The player's cursor stack."
      },
      "disable_flashlight": {
        "name": "disable_flashlight()",
        "args": {},
        "doc": "Disable the flashlight.",
        "type": "function"
      },
      "driving": {
        "name": "driving",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "true if the player is in a vehicle. Writing to this attribute puts the player in or out of a vehicle."
      },
      "drop_item_distance": {
        "name": "drop_item_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The item drop distance of this character or max uint when not a character or player connected to a character."
      },
      "enable_flashlight": {
        "name": "enable_flashlight()",
        "args": {},
        "doc": "Enable the flashlight.",
        "type": "function"
      },
      "force": {
        "name": "force",
        "type": "string or LuaForce",
        "mode": "[Read-Write]",
        "doc": "The force of this entity. Reading will always give a LuaForce, but it is possible to assign either string or LuaForce to this attribute to change the force."
      },
      "get_craftable_count": {
        "name": "get_craftable_count(recipe) → uint",
        "returns": "uint",
        "args": {
          "recipe": {
            "doc": "recipe :: string or LuaRecipe: The recipe.",
            "name": "recipe",
            "type": "string or LuaRecipe"
          }
        },
        "doc": "Gets the count of the given recipe that can be crafted\n\nParameters\n\nrecipe :: string or LuaRecipe: The recipe.Return value The count that can be crafted.",
        "type": "function"
      },
      "get_inventory": {
        "name": "get_inventory(inventory) → LuaInventory",
        "returns": "LuaInventory",
        "args": {
          "inventory": {
            "doc": "inventory :: defines.inventory",
            "name": "inventory",
            "type": "defines.inventory"
          }
        },
        "doc": "Get an inventory belonging to this entity. This can be either the \"main\" inventory or some auxiliary one, like the module slots or logistic trash slots\n\nParameters\n\ninventory :: defines.inventoryReturn value or nil if this entity doesn't have an inventory with the given index.",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Prototype name of the item to count. If not specified, count all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Get the number of all or some items in this entity\n\nParameters\n\nitem :: string (optional): Prototype name of the item to count. If not specified, count all items.",
        "type": "function"
      },
      "get_quickbar": {
        "name": "get_quickbar() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "Get the quickbar belonging to this entity if any. This works for both the character entity (the little guy running around) and the god controller (sandbox, character-less players).\nReturn value or nil if this entity doesn't have a quickbar.",
        "type": "function"
      },
      "has_items_inside": {
        "name": "has_items_inside() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Does this entity have any item inside it?",
        "type": "function"
      },
      "insert": {
        "name": "insert(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to insert.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items into this entity. This works the same way as inserters or shift-clicking: the \"best\" inventory is chosen automatically\n\nParameters\n\nitems :: SimpleItemStack: Items to insert.Return value Number of items actually inserted.",
        "type": "function"
      },
      "item_pickup_distance": {
        "name": "item_pickup_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The item pickup distance of this character or max double when not a character or player connected to a character."
      },
      "loot_pickup_distance": {
        "name": "loot_pickup_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The loot pickup distance of this character or max double when not a character or player connected to a character."
      },
      "mine_entity": {
        "name": "mine_entity(entity, force) → boolean",
        "returns": "boolean",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity: The entity to mine",
            "name": "entity",
            "type": "LuaEntity"
          },
          "force": {
            "doc": "force :: boolean (optional): Forces mining the entity even if the items can't fit in the player.",
            "name": "force",
            "type": "boolean"
          }
        },
        "doc": "Mines the given entity as if this player (or character) mined it. \n\nParameters\n\nentity :: LuaEntity: The entity to mineforce :: boolean (optional): Forces mining the entity even if the items can't fit in the player.Return value If the mining succeeded.",
        "type": "function"
      },
      "mining_state": {
        "name": "mining_state",
        "mode": "[Read-Write]",
        "doc": "Current mining state.\n It is a table with two fields: \n * mining :: boolean: Whether the player is mining at all\n * position :: Position (optional): What the player is mining; not necessary when mining is false.",
        "type": "mining_state"
      },
      "opened": {
        "name": "opened",
        "type": "LuaEntity or LuaItemStack or LuaEquipment or defines.gui_type",
        "mode": "[Read-Write]",
        "doc": "The GUI target the player currently has open; nil if none. \n\nNote: Write supports any of the types. Read will return the entity, equipment or nil."
      },
      "opened_gui_type": {
        "name": "opened_gui_type",
        "mode": "[Read-only]",
        "doc": "Returns the defines.gui_type or nil.",
        "type": "opened_gui_type"
      },
      "picking_state": {
        "name": "picking_state",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Current item-picking state."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Current position of the entity."
      },
      "quickbar_count_bonus": {
        "name": "quickbar_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Note: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "reach_distance": {
        "name": "reach_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The reach distance of this character or max uint when not a character or player connected to a character."
      },
      "remove_item": {
        "name": "remove_item(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to remove.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove items from this entity\n\nParameters\n\nitems :: SimpleItemStack: Items to remove.Return value Number of items actually removed.",
        "type": "function"
      },
      "repair_state": {
        "name": "repair_state",
        "mode": "[Read-Write]",
        "doc": "Current repair state.\n It is a table with two fields: \n * repairing :: boolean: The current state\n * position :: Position: The position being repaired",
        "type": "repair_state"
      },
      "resource_reach_distance": {
        "name": "resource_reach_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The resource reach distance of this character or max double when not a character or player connected to a character."
      },
      "riding_state": {
        "name": "riding_state",
        "mode": "[Read-Write]",
        "doc": "Current riding state of this car or the vehicle this player is riding in.\n It is a table with two fields: \n * acceleration :: defines.riding.acceleration\n * direction :: defines.riding.direction",
        "type": "riding_state"
      },
      "selected": {
        "name": "selected",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The currently selected entity; nil if none."
      },
      "set_gui_arrow": {
        "name": "set_gui_arrow{type=…}",
        "args": {
          "type": {
            "doc": "Table with the following fields:  * type :: string: Where to point to. This field determines what other fields are mandatory. May be \"nowhere\", \"goal\", \"entity_info\", \"active_window\", \"entity\", \"position\", \"crafting_queue\", or \"item_stack\".\n * Additional type-specific parameters * entity * entity :: LuaEntity\n      \n      \n    * position * position :: Position\n      \n      \n    * crafting_queue * crafting_queueindex :: uint\n      \n      \n    * item_stack * inventory_index :: uint\n       * item_stack_index :: uint\n       * source :: string: May be either \"player\" or \"target\".",
            "name": "type",
            "type": "string"
          }
        },
        "doc": "Create an arrow which points at this entity. This is used in the tutorial. For examples, see control.luain the campaign missions\n\nParameters\n\n Table with the following fields:  * type :: string: Where to point to. This field determines what other fields are mandatory. May be \"nowhere\", \"goal\", \"entity_info\", \"active_window\", \"entity\", \"position\", \"crafting_queue\", or \"item_stack\".\n * Additional type-specific parameters * entity * entity :: LuaEntity\n    * position * position :: Position\n    * crafting_queue * crafting_queueindex :: uint\n    * item_stack * inventory_index :: uint\n       * item_stack_index :: uint\n       * source :: string: May be either \"player\" or \"target\".",
        "type": "function"
      },
      "shooting_state": {
        "name": "shooting_state",
        "mode": "[Read-Write]",
        "doc": "Current shooting state.\n It is a table with two fields: \n * state :: defines.shooting: The current state\n * position :: Position: The position being shot at",
        "type": "shooting_state"
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[Read-only]",
        "doc": "The surface this entity is currently on."
      },
      "teleport": {
        "name": "teleport(position, surface) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: Position: Where to teleport to.",
            "name": "position",
            "type": "Position"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): Surface to teleport to. If not given, will teleport to the entity's current surface.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Teleport the entity to a given position, possibly on another surface\n\nParameters\n\nposition :: Position: Where to teleport to.surface :: SurfaceSpecification (optional): Surface to teleport to. If not given, will teleport to the entity's current surface.Return value true when the entity was successfully teleported\n\nNote: Some entities may not be teleported. For instance, walls, rail signals or entities with fluid boxes won't allow teleportation and this method will always return false when used on any such entity.",
        "type": "function"
      },
      "update_selected_entity": {
        "name": "update_selected_entity(position)",
        "args": {
          "position": {
            "doc": "position :: Position: Position of the entity to select",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Select an entity, as if by hovering the mouse above it\n\nParameters\n\nposition :: Position: Position of the entity to select",
        "type": "function"
      },
      "vehicle": {
        "name": "vehicle",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The vehicle the player is currently sitting in; nil if none."
      },
      "walking_state": {
        "name": "walking_state",
        "mode": "[Read-Write]",
        "doc": "Current walking state.\n It is a table with two fields: \n * walking :: boolean: If false, the player is currently not walking; otherwise it's going somewhere\n * direction :: defines.direction: Direction where the player is walking\nExampleMake the player go north. Note that a one-shot action like this will only make the player walk for one tick. game.player.walking_state = {walking = true, direction = defines.direction.north}",
        "type": "walking_state"
      }
    }
  },
  "LuaCommandProcessor": {
    "name": "LuaCommandProcessor",
    "type": "LuaCommandProcessor",
    "doc": "Custom game console commands.",
    "properties": {
      "add_command": {
        "name": "add_command(name, help, function)",
        "args": {
          "function": {
            "doc": "function :: function: The function that will be called when this command is invoked.",
            "name": "function",
            "type": "function"
          },
          "help": {
            "doc": "help :: LocalisedString: The localised help message.",
            "name": "help",
            "type": "LocalisedString"
          },
          "name": {
            "doc": "name :: string: Name of the command (case sensitive).",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Add a command\n\nParameters\n\nname :: string: Name of the command (case sensitive).help :: LocalisedString: The localised help message.function :: function: The function that will be called when this command is invoked\n\nNote: It is an error if the given command name is already registered or already exists as a game command.",
        "type": "function"
      },
      "commands": {
        "name": "commands",
        "type": "dictionary string → LocalisedString",
        "mode": "[Read-only]",
        "doc": "The script registered commands"
      },
      "game_commands": {
        "name": "game_commands",
        "type": "dictionary string → LocalisedString",
        "mode": "[Read-only]",
        "doc": "The script registered commands"
      },
      "remove_command": {
        "name": "remove_command(string) → boolean",
        "returns": "boolean",
        "args": {
          "string": {
            "name": "string",
            "type": "string"
          }
        },
        "doc": "Removes a registered command \n\nParameters\n\nReturn value If the command was removed. False if the command didn't exist.",
        "type": "function"
      }
    }
  },
  "LuaCircuitNetwork": {
    "name": "LuaCircuitNetwork",
    "type": "LuaCircuitNetwork",
    "doc": "A circuit network associated with a given entity, connector, and wire type.",
    "properties": {
      "circuit_connector_id": {
        "name": "circuit_connector_id",
        "type": "defines.circuit_connector_id",
        "mode": "[Read-only]",
        "doc": "The circuit connector ID on the associated entity this network was gotten from."
      },
      "entity": {
        "name": "entity",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity this circuit network reference is associated with"
      },
      "get_signal": {
        "name": "get_signal(SignalID) → int",
        "returns": "int",
        "args": {
          "SignalID": {
            "doc": "SignalID: The signal to read.",
            "name": "SignalID"
          }
        },
        "doc": "ParametersSignalID: The signal to read.Return value The current value of the signal.",
        "type": "function"
      },
      "network_id": {
        "name": "network_id",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The circuit networks ID."
      },
      "signals": {
        "name": "signals",
        "type": "array of Signal",
        "mode": "[Read-only]",
        "doc": "The circuit network signals last tick."
      },
      "wire_type": {
        "name": "wire_type",
        "type": "defines.wire_type",
        "mode": "[Read-only]",
        "doc": "The wire type this network is associated with."
      }
    }
  },
  "LuaChunkIterator": {
    "name": "LuaChunkIterator",
    "type": "LuaChunkIterator",
    "doc": "A chunk iterator can be used for iterating chunks coordinates of a surface."
  }
}