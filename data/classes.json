{
  "LuaControlBehavior": {
    "name": "LuaControlBehavior",
    "type": "LuaControlBehavior"
  },
  "LuaBootstrap": {
    "name": "LuaBootstrap",
    "type": "LuaBootstrap",
    "doc": "Entry point for registering event handlers. It is accessible through the global object named script.",
    "properties": {
      "on_init": {
        "name": "on_init(f)",
        "args": {
          "f": {
            "doc": "f :: function(): The function to call. Passing nil will unregister the handler.",
            "name": "f",
            "type": "function()"
          }
        },
        "doc": "Register a callback to be run on mod init. This is called once when a new save game is created or once when a save file is loaded that previously didn't contain the mod. This is always called before other event handlers and is meant for setting up initial values that a mod will use for its lifetime. \nParameters\n\nf :: function(): The function to call. Passing nil will unregister the handler.",
        "type": "function"
      },
      "on_load": {
        "name": "on_load(f)",
        "args": {
          "f": {
            "doc": "f :: function(): The function to call. Passing nil will unregister the handler.",
            "name": "f",
            "type": "function()"
          }
        },
        "doc": "Register a function to be run on module load. This is called every time a save file is loaded *except* for the instance when a mod is loaded into a save file that it previously wasn't part of. Additionally this is called when connecting to any other game in a multiplayer session and should never change the game state.\n This is meant for 3 specific reasons and only 3: \n *  re-register conditional event handlers\n *  re-setup meta tables\n *  create local references to tables stored in the global table\n In all other instances the LuaBootstrap::on_init, LuaBootstrap::on_configuration_changed or migration scripts should be used. Doing any other logic when loading a save file can break the replay and cause desync issues if the mod is used in multiplayer. \nParameters\n\nf :: function(): The function to call. Passing nil will unregister the handler.",
        "type": "function"
      },
      "on_configuration_changed": {
        "name": "on_configuration_changed(f)",
        "args": {
          "f": {
            "doc": "f :: function(ConfigurationChangedData): The handler for this event. Passing nil will unregister the handler.",
            "name": "f",
            "type": "function(ConfigurationChangedData)"
          }
        },
        "doc": "Register a function to be run when mod configuration changes. This is called any time the game version changes and any time mod versions change including adding or removing mods. \nParameters\n\nf :: function(ConfigurationChangedData): The handler for this event. Passing nil will unregister the handler.",
        "type": "function"
      },
      "on_event": {
        "name": "on_event(event, f)",
        "args": {
          "event": {
            "doc": "event :: defines.events or array of defines.events or string: The events or custom-input name to invoke the handler on",
            "name": "event",
            "type": "defines.events or array of defines.events or string"
          },
          "f": {
            "doc": "f :: function(Event): The handler to run. Passing nil will unregister the handler. The handler will receive a table that contains the key name (of type defines.events) specifying the name of the event it was called to handle, and tick that specifies when the event was created. This table will also contain other fields, depending on the type of the event. See the list of Factorio events for a listing of these additional fields.",
            "name": "f",
            "type": "function(Event)"
          }
        },
        "doc": "Register a handler to run on event or events. \nParameters\n\nevent :: defines.events or array of defines.events or string: The events or custom-input name to invoke the handler onf :: function(Event): The handler to run. Passing nil will unregister the handler. The handler will receive a table that contains the key name (of type defines.events) specifying the name of the event it was called to handle, and tick that specifies when the event was created. This table will also contain other fields, depending on the type of the event. See the list of\nFactorio events for a listing of these additional fields.",
        "type": "function"
      },
      "generate_event_name": {
        "name": "generate_event_name() → uint",
        "returns": "uint",
        "args": {},
        "doc": "Generate a new, unique event ID.\nReturn value The new ID",
        "type": "function"
      },
      "get_event_handler": {
        "name": "get_event_handler(event)",
        "args": {
          "event": {
            "doc": "event :: uint: The event identifier to get a handler for",
            "name": "event",
            "type": "uint"
          }
        },
        "doc": "Find the event handler for an event.\nParameters\n\nevent :: uint: The event identifier to get a handler forReturn value Reference to the function currently registered as the handler.",
        "type": "function"
      },
      "raise_event": {
        "name": "raise_event(event, table)",
        "args": {
          "event": {
            "doc": "event :: uint: ID of the event to raise",
            "name": "event",
            "type": "uint"
          },
          "table": {
            "doc": "table: Table with extra data. This table will be passed to the event handler.",
            "name": "table"
          }
        },
        "doc": "Raise an event. \nParameters\n\nevent :: uint: ID of the event to raisetable: Table with extra data. This table will be passed to the event handler.",
        "type": "function"
      }
    }
  },
  "LuaBurner": {
    "name": "LuaBurner",
    "type": "LuaBurner",
    "doc": "A reference to the burner energy source owned by a specfic LuaEntity or LuaEquipment.",
    "properties": {
      "owner": {
        "name": "owner",
        "type": "LuaEntity or LuaEquipment",
        "mode": "[Read-only]",
        "doc": "The owner of this burner energy source"
      },
      "inventory": {
        "name": "inventory",
        "type": "LuaInventory",
        "mode": "[Read-only]",
        "doc": "The fuel inventory."
      },
      "heat": {
        "name": "heat",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "heat_capacity": {
        "name": "heat_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "remaining_burning_fuel": {
        "name": "remaining_burning_fuel",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: Writing will silently do nothing if there's no LuaBurner::currently_burning set."
      },
      "currently_burning": {
        "name": "currently_burning",
        "type": "LuaItemPrototype",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: Writing automatically handles correcting LuaBurner::remaining_burning_fuel."
      }
    }
  },
  "LuaChunkIterator": {
    "name": "LuaChunkIterator",
    "type": "LuaChunkIterator",
    "doc": "A chunk iterator can be used for iterating chunks coordinates of a surface."
  },
  "LuaVirtualSignalPrototype": {
    "name": "LuaVirtualSignalPrototype",
    "type": "LuaVirtualSignalPrototype",
    "doc": "Prototype of a virtual signal.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "special": {
        "name": "special",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this is a special signal"
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaUnitGroup": {
    "name": "LuaUnitGroup",
    "type": "LuaUnitGroup",
    "doc": "A collection of units moving and attacking together. The engine creates autonomous unit groups to attack\n polluted areas. The script can create and control such groups as well. Groups can accept commands in the\n same manner as regular units.",
    "properties": {
      "add_member": {
        "name": "add_member(unit)",
        "args": {
          "unit": {
            "doc": "unit :: LuaEntity",
            "name": "unit",
            "type": "LuaEntity"
          }
        },
        "doc": "Make a unit a member of this group. Has the same effect as giving a group_command with this group to the unit.\nParameters\n\nunit :: LuaEntity\n\nNote: The member must have the same force as the unit group.",
        "type": "function"
      },
      "set_command": {
        "name": "set_command(command)",
        "args": {
          "command": {
            "doc": "command :: Command",
            "name": "command",
            "type": "Command"
          }
        },
        "doc": "Give this group a command.\nParameters\n\ncommand :: CommandSee also * LuaEntity::set_command",
        "type": "function"
      },
      "set_autonomous": {
        "name": "set_autonomous()",
        "args": {},
        "doc": "Make this group autonomous. Autonomous groups will automatically attack polluted areas.",
        "type": "function"
      },
      "start_moving": {
        "name": "start_moving()",
        "args": {},
        "doc": "Make the group start moving even if some of its members haven't yet arrived.",
        "type": "function"
      },
      "destroy": {
        "name": "destroy()",
        "args": {},
        "doc": "Dissolve this group. Its members won't be destroyed, they will be merely unlinked from this group.",
        "type": "function"
      },
      "members": {
        "name": "members",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Members of this group."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Group position. This can have different meanings depending on the group state. When the group is gathering, the position is the place of gathering. When the group is moving, the position is the expected position of its members along the path. When the group is attacking, it is the average position of its members."
      },
      "state": {
        "name": "state",
        "type": "defines.group_state",
        "mode": "[Read-only]",
        "doc": "Whether this group is gathering, moving or attacking."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force of this unit group."
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[Read-only]",
        "doc": "The surface of this unit group."
      }
    }
  },
  "LuaTransportLine": {
    "name": "LuaTransportLine",
    "type": "LuaTransportLine",
    "doc": "One line on a transport belt.",
    "properties": {
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Remove all items from this transport line.",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Prototype name of the item to count. If not specified, count all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Count some or all items on this line.\nParameters\n\nitem :: string (optional): Prototype name of the item to count. If not specified, count all items.See also * LuaInventory::get_item_count",
        "type": "function"
      },
      "remove_item": {
        "name": "remove_item(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to remove.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove some items from this line.\nParameters\n\nitems :: SimpleItemStack: Items to remove.Return value Number of items actually removed.",
        "type": "function"
      },
      "can_insert_at": {
        "name": "can_insert_at(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: float: Where to insert an item.",
            "name": "position",
            "type": "float"
          }
        },
        "doc": "Can an item be inserted at a given position?\nParameters\n\nposition :: float: Where to insert an item.",
        "type": "function"
      },
      "can_insert_at_back": {
        "name": "can_insert_at_back() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Can an item be inserted at the back of this line?",
        "type": "function"
      },
      "insert_at": {
        "name": "insert_at(position, items) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: float: Where on the line to insert the items.",
            "name": "position",
            "type": "float"
          },
          "items": {
            "doc": "items :: SimpleItemStack: Items to insert.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items at a given position.\nParameters\n\nposition :: float: Where on the line to insert the items.items :: SimpleItemStack: Items to insert.Return value Were the items inserted successfully?",
        "type": "function"
      },
      "insert_at_back": {
        "name": "insert_at_back(items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items at the back of this line.\nParameters\n\nitems :: SimpleItemStackReturn value Were the items inserted successfully?",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get counts of all items on this line.\nReturn value The counts, indexed by item names.See also * LuaInventory::get_contents",
        "type": "function"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Get the number of items on this transport line."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity this transport line belongs to."
      },
      "operator []": {
        "name": "operator []",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The indexing operator."
      }
    }
  },
  "LuaTrain": {
    "name": "LuaTrain",
    "type": "LuaTrain",
    "doc": "A train. Trains are a sequence of connected rolling stocks -- locomotives and wagons.",
    "properties": {
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Item name to count. If not given, counts all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Get the amount of a particular item stored in the train.\nParameters\n\nitem :: string (optional): Item name to count. If not given, counts all items.",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get a summary of the train's inventory.\nReturn value The counts, indexed by item names.",
        "type": "function"
      },
      "remove_item": {
        "name": "remove_item(stack) → uint",
        "returns": "uint",
        "args": {
          "stack": {
            "doc": "stack :: SimpleItemStack: The amount and type of items to remove",
            "name": "stack",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove some items from the train.\nParameters\n\nstack :: SimpleItemStack: The amount and type of items to removeReturn value Number of items actually removed.",
        "type": "function"
      },
      "insert": {
        "name": "insert(stack)",
        "args": {
          "stack": {
            "doc": "stack :: SimpleItemStack",
            "name": "stack",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert a stack into the train.\nParameters\n\nstack :: SimpleItemStack",
        "type": "function"
      },
      "clear_items_inside": {
        "name": "clear_items_inside()",
        "args": {},
        "doc": "Clear all items in this train.",
        "type": "function"
      },
      "recalculate_path": {
        "name": "recalculate_path(force) → boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "doc": "force :: boolean (optional): Forces the train to re-path regardless of the current path being valid or not.",
            "name": "force",
            "type": "boolean"
          }
        },
        "doc": "Checks if the path is invalid and tries to re-path if it isn't. \nParameters\n\nforce :: boolean (optional): Forces the train to re-path regardless of the current path being valid or not.Return value If the train has a path after the repath attempt.",
        "type": "function"
      },
      "manual_mode": {
        "name": "manual_mode",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When true, the train is explicitly controlled by the player or script. When false, the train moves autonomously according to its schedule."
      },
      "speed": {
        "name": "speed",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Current speed. \n\n\nNote: Changing the speed of the train is potentially an unsafe operation because train uses the speed for its internal calculations of break distances, etc."
      },
      "carriages": {
        "name": "carriages",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Rolling stocks the train is composed of."
      },
      "locomotives": {
        "name": "locomotives",
        "type": "dictionary string → array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Arrays of locomotives. The result is two arrays, indexed by \"front_movers\" and \"back_movers\"containing the locomotives. E.g. {front_movers={loco1, loco2}, back_movers={loco3}}."
      },
      "cargo_wagons": {
        "name": "cargo_wagons",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "The cargo carriages the train contains."
      },
      "fluid_wagons": {
        "name": "fluid_wagons",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "The fluid carriages the train contains."
      },
      "schedule": {
        "name": "schedule",
        "type": "TrainSchedule",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: The schedule can't be changed by modifying the returned table. Instead, changes must be made by assigning a new table to this attribute."
      },
      "state": {
        "name": "state",
        "type": "defines.train_state",
        "mode": "[Read-only]",
        "doc": "This train's current state."
      },
      "front_rail": {
        "name": "front_rail",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The rail at the front end of the train, possibly nil."
      },
      "back_rail": {
        "name": "back_rail",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The rail at the back end of the train, possibly nil."
      },
      "rail_direction_from_front_rail": {
        "name": "rail_direction_from_front_rail",
        "type": "defines.rail_direction",
        "mode": "[Read-only]",
        "doc": ""
      },
      "rail_direction_from_back_rail": {
        "name": "rail_direction_from_back_rail",
        "type": "defines.rail_direction",
        "mode": "[Read-only]",
        "doc": ""
      },
      "front_stock": {
        "name": "front_stock",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The front stock of this train or nil."
      },
      "back_stock": {
        "name": "back_stock",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The back stock of this train or nil."
      },
      "station": {
        "name": "station",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The train stop this train is stopped at or nil."
      },
      "has_path": {
        "name": "has_path",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this train has a path."
      },
      "path_end_rail": {
        "name": "path_end_rail",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The destination rail this train is currently pathing to or nil."
      },
      "path_end_stop": {
        "name": "path_end_stop",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The destination train stop this train is currently pathing to or nil."
      }
    }
  },
  "LuaTilePrototype": {
    "name": "LuaTilePrototype",
    "type": "LuaTilePrototype",
    "doc": "Prototype of a tile.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "The collison mask this tile uses \n The boolean values for each item are meaningless and will always be true.\n\n\nNote: This is a dictionary of the collision masks this tile uses to allow quick lookup of any value."
      },
      "layer": {
        "name": "layer",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "walking_speed_modifier": {
        "name": "walking_speed_modifier",
        "type": "float",
        "mode": "[Read-only]",
        "doc": ""
      },
      "vehicle_friction_modifier": {
        "name": "vehicle_friction_modifier",
        "type": "float",
        "mode": "[Read-only]",
        "doc": ""
      },
      "map_color": {
        "name": "map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": ""
      },
      "decorative_removal_probability": {
        "name": "decorative_removal_probability",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The probability that decorative entities will be removed from on top of this tile when this tile is generated."
      },
      "allowed_neighbors": {
        "name": "allowed_neighbors",
        "type": "dictionary string → LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "mineable_properties": {
        "name": "mineable_properties",
        "mode": "[Read-only]",
        "doc": "Table with the following fields:  * minable :: boolean: Is this tile mineable at all?\n * hardness :: double: Mining hardness.\n * miningtime :: double: Energy required to mine a tile.\n * miningparticle :: string (optional): Prototype name of the particle produced when mining this tile. Will only be present if this tile produces any particle during mining.\n * products :: array of Product: Products obtained by mining this tile.",
        "type": "mineable_properties"
      },
      "items_to_place_this": {
        "name": "items_to_place_this",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Items that when placed will produce this tile. It is a dictionary indexed by the item prototype name."
      },
      "can_be_part_of_blueprint": {
        "name": "can_be_part_of_blueprint",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "False if this tile is not allowed in blueprints regardless of the ability to build it."
      },
      "emissions_per_tick": {
        "name": "emissions_per_tick",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of pollution emissions per tick this tile will absorb."
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[Read-only]",
        "doc": "Autoplace specification for this prototype. nil if none."
      }
    }
  },
  "LuaTile": {
    "name": "LuaTile",
    "type": "LuaTile",
    "doc": "A single \"square\" on the map.",
    "properties": {
      "collides_with": {
        "name": "collides_with(layer)",
        "args": {
          "layer": {
            "doc": "layer :: string: Possible values:  *  \"ground-tile\"\n *  \"water-tile\"\n *  \"resource-layer\"\n *  \"floor-layer\"\n *  \"object-layer\"\n *  \"player-layer\"\n *  \"train-layer\"\n *  \"layer-11\"\n *  \"layer-12\"\n *  \"layer-13\"\n *  \"layer-14\"\n *  \"layer-15\"",
            "name": "layer",
            "type": "string"
          }
        },
        "doc": "What type of things can collide with this tile?\nParameters\n\nlayer :: string: Possible values:  *  \"ground-tile\"\n *  \"water-tile\"\n *  \"resource-layer\"\n *  \"floor-layer\"\n *  \"object-layer\"\n *  \"player-layer\"\n *  \"train-layer\"\n *  \"layer-11\"\n *  \"layer-12\"\n *  \"layer-13\"\n *  \"layer-14\"\n *  \"layer-15\"\nExampleCheck if the player would collide with a tile game.player.print(tostring(game.player.surface.get_tile(1, 1).collides_with(\"player-layer\")))",
        "type": "function"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Prototype name of this tile. E.g. \"sand-dark\" or \"grass-dry\"."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "The position this tile references."
      },
      "hidden_tile": {
        "name": "hidden_tile",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaTechnologyPrototype": {
    "name": "LuaTechnologyPrototype",
    "type": "LuaTechnologyPrototype",
    "doc": "A Technology prototype.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this technology."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of this technology."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this technology prototype is enabled by default (enabled at the begining of a game)."
      },
      "upgrade": {
        "name": "upgrade",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If the is technology prototype is an upgrade to some other technology."
      },
      "prerequisites": {
        "name": "prerequisites",
        "type": "dictionary string → LuaTechnologyPrototype",
        "mode": "[Read-only]",
        "doc": "Prerequisites of this technology. The result maps technology name to the LuaTechnologyPrototype object."
      },
      "research_unit_ingredients": {
        "name": "research_unit_ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients labs will require to research this technology. \nSee also * LuaTechnologyPrototype::research_unit_count"
      },
      "effects": {
        "name": "effects",
        "type": "array of Modifier",
        "mode": "[Read-only]",
        "doc": "Effects applied when this technology is researched."
      },
      "research_unit_count": {
        "name": "research_unit_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of research units required for this technology. \nSee also * LuaTechnologyPrototype::research_unit_ingredients"
      },
      "research_unit_energy": {
        "name": "research_unit_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of energy required to finish a unit of research."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string for this prototype."
      },
      "level": {
        "name": "level",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The level of this research."
      },
      "research_unit_count_formula": {
        "name": "research_unit_count_formula",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The count forumula used for this infinite research or nil if this isn't an infinite research."
      }
    }
  },
  "LuaTechnology": {
    "name": "LuaTechnology",
    "type": "LuaTechnology",
    "doc": "One research item.",
    "properties": {
      "reload": {
        "name": "reload()",
        "args": {},
        "doc": "Reload this technology from its prototype.",
        "type": "function"
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force this technology blongs to."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this technology."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of this technology."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaTechnologyPrototype",
        "mode": "[Read-only]",
        "doc": "The prototype of this technology."
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Can this technology be researched?"
      },
      "upgrade": {
        "name": "upgrade",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this an upgrade-type research?"
      },
      "researched": {
        "name": "researched",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Has this technology been researched? Switching from false to true will trigger the technology advancement perks; switching from true to false will reverse them."
      },
      "prerequisites": {
        "name": "prerequisites",
        "type": "dictionary string → LuaTechnology",
        "mode": "[Read-only]",
        "doc": "Prerequisites of this technology. The result maps technology name to the LuaTechnologyobject."
      },
      "research_unit_ingredients": {
        "name": "research_unit_ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients labs will require to research this technology. \nSee also * LuaTechnology::research_unit_count"
      },
      "effects": {
        "name": "effects",
        "type": "array of Modifier",
        "mode": "[Read-only]",
        "doc": "Effects applied when this technology is researched."
      },
      "research_unit_count": {
        "name": "research_unit_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of research units required for this technology. \nSee also * LuaTechnology::research_unit_ingredients"
      },
      "research_unit_energy": {
        "name": "research_unit_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of energy required to finish a unit of research."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string for this prototype."
      },
      "level": {
        "name": "level",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The current level of this technology."
      },
      "research_unit_count_formula": {
        "name": "research_unit_count_formula",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The count forumula used for this infinite research or nil if this isn't an infinite research."
      }
    }
  },
  "LuaSurface": {
    "name": "LuaSurface",
    "type": "LuaSurface",
    "doc": "A \"domain\" of the world. Surfaces can only be created through the API and can not be\n deleted. However, it is planned to allow deletion of a surface in the future. Surfaces\n are uniquely identified by their name. Every game contains at least the surface \"nauvis\".",
    "properties": {
      "get_pollution": {
        "name": "get_pollution(position) → double",
        "returns": "double",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Get the pollution for a given position.\nParameters\n\nposition :: PositionExample game.surfaces[1].get_pollution({1,2})",
        "type": "function"
      },
      "can_place_entity": {
        "name": "can_place_entity{name=…, position=…, direction=…, force=…} → boolean",
        "returns": "boolean",
        "args": {
          "name": {
            "doc": "Table with the following fields:  * name :: string: Name of the entity to check\n * position :: Position: Where the entity would be placed\n * direction :: defines.direction (optional): Direction the entity would be placed\n * force :: string or LuaForce (optional): The force that would place the entity. If not specified, the enemy force is assumed.",
            "name": "name",
            "type": "string"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "direction=…": {
            "name": "direction=…",
            "type": "direction=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Check for collisions with terrain or other entities.\nParameters\n\n Table with the following fields:  * name :: string: Name of the entity to check\n * position :: Position: Where the entity would be placed\n * direction :: defines.direction (optional): Direction the entity would be placed\n * force :: string or LuaForce (optional): The force that would place the entity. If not specified, the enemy force is assumed.",
        "type": "function"
      },
      "find_entity": {
        "name": "find_entity(entity, position) → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "entity": {
            "doc": "entity :: string: Entity to look for",
            "name": "entity",
            "type": "string"
          },
          "position": {
            "doc": "position :: Position: Coordinates to look at",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find a specific entity at a specific position.\nParameters\n\nentity :: string: Entity to look forposition :: Position: Coordinates to look atReturn value Will be nil if no such entity is found.Example game.player.selected.surface.find_entity('filter-inserter',{0,0})",
        "type": "function"
      },
      "find_entities": {
        "name": "find_entities(area) → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "area": {
            "doc": "area :: BoundingBox (optional): Where to search. If not given all entities on the surface are returned.",
            "name": "area",
            "type": "BoundingBox"
          }
        },
        "doc": "Find entities in a given area.\nParameters\n\narea :: BoundingBox (optional): Where to search. If not given all entities on the surface are returned.ExampleWill evaluate to a list of all entities within given area. game.surfaces[\"nauvis\"].find_entities({{-10, -10}, {10, 10}})",
        "type": "function"
      },
      "find_entities_filtered": {
        "name": "find_entities_filtered{area=…, position=…, name=…, type=…, force=…, limit=…} → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox (optional): Search area if not defined and position is not defined the entire surface is searched\n * position :: Position (optional): Search position if not defined and area is not defined the entire surface is searched\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "limit=…": {
            "name": "limit=…",
            "type": "limit=…"
          }
        },
        "doc": "Find entities of given type or name in a given area.\n If no filters (name, type, or force) are given, returns all entities in the search area. If multiple filters are specified, returns only entities matching all given filters.\nParameters\n\n Table with the following fields:  * area :: BoundingBox (optional): Search area if not defined and position is not defined the entire surface is searched\n * position :: Position (optional): Search position if not defined and area is not defined the entire surface is searched\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)\nExample game.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, type= \"resource\"} -- gets all resources in the rectangle\ngame.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, name= \"iron-ore\"} -- gets all iron ores in the rectangle\ngame.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, force= \"player\"} -- gets player owned entities in the rectangle\ngame.surfaces[1].find_entities_filtered{area = {{-10, -10}, {10, 10}}, limit= 5} -- gets the first 5 entities in the rectangle",
        "type": "function"
      },
      "count_entities_filtered": {
        "name": "count_entities_filtered{area=…, position=…, name=…, type=…, force=…, limit=…} → uint",
        "returns": "uint",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox (optional): Search area if not defined and position is not defined the entire surface is searched\n * position :: Position (optional): Search position if not defined and area is not defined the entire surface is searched\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "limit=…": {
            "name": "limit=…",
            "type": "limit=…"
          }
        },
        "doc": "Count entities of given type or name in a given area. Works just like LuaSurface::find_entities_filtered, except this only returns the count. As it doesn't construct all the wrapper objects, this is more efficient if one is only interested in the number of entities.\nParameters\n\n Table with the following fields:  * area :: BoundingBox (optional): Search area if not defined and position is not defined the entire surface is searched\n * position :: Position (optional): Search position if not defined and area is not defined the entire surface is searched\n * name :: string (optional)\n * type :: string (optional)\n * force :: string or LuaForce (optional)\n * limit :: uint (optional)",
        "type": "function"
      },
      "find_non_colliding_position": {
        "name": "find_non_colliding_position(name, center, radius, precision) → Position",
        "returns": "Position",
        "args": {
          "name": {
            "doc": "name :: string: Prototype name of the entity to find a position for. (The bounding box for the collision checking is taken from this prototype.)",
            "name": "name",
            "type": "string"
          },
          "center": {
            "doc": "center :: Position: Center of the search area.",
            "name": "center",
            "type": "Position"
          },
          "radius": {
            "doc": "radius :: double: Max distance from center to search in. 0 for infinitely-large search area.",
            "name": "radius",
            "type": "double"
          },
          "precision": {
            "doc": "precision :: double: The step length from the given position as it searches, in tiles.",
            "name": "precision",
            "type": "double"
          }
        },
        "doc": "Find a non-colliding possition within a given rectangle.\nParameters\n\nname :: string: Prototype name of the entity to find a position for. (The bounding box for the collision checking is taken from this prototype.)center :: Position: Center of the search area.radius :: double: Max distance from center to search in. 0 for infinitely-large search area.precision :: double: The step length from the given position as it searches, in tiles.Return value The non-colliding position. May be nil if no suitable position was found.",
        "type": "function"
      },
      "spill_item_stack": {
        "name": "spill_item_stack(position, items, enable_looted)",
        "args": {
          "position": {
            "doc": "position :: Position: Center of the spillage",
            "name": "position",
            "type": "Position"
          },
          "items": {
            "doc": "items :: LuaItemStack or SimpleItemStack: Items to spill",
            "name": "items",
            "type": "LuaItemStack or SimpleItemStack"
          },
          "enable_looted": {
            "doc": "enable_looted :: boolean (optional): When true, each created item will be flagged with the LuaEntity::to_be_looted flag.",
            "name": "enable_looted",
            "type": "boolean"
          }
        },
        "doc": "Spill items on the ground centered at a given location.\nParameters\n\nposition :: Position: Center of the spillageitems :: LuaItemStack or SimpleItemStack: Items to spillenable_looted :: boolean (optional): When true, each created item will be flagged with the LuaEntity::to_be_looted flag.",
        "type": "function"
      },
      "find_enemy_units": {
        "name": "find_enemy_units(center, radius, force) → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "center": {
            "doc": "center :: Position: Center of the search area",
            "name": "center",
            "type": "Position"
          },
          "radius": {
            "doc": "radius :: double: Radius of the circular search area",
            "name": "radius",
            "type": "double"
          },
          "force": {
            "doc": "force :: LuaForce or string (optional): Force to find enemies of. If not given, uses the player force.",
            "name": "force",
            "type": "LuaForce or string"
          }
        },
        "doc": "Find units enemy of a given force within an area.\nParameters\n\ncenter :: Position: Center of the search arearadius :: double: Radius of the circular search areaforce :: LuaForce or string (optional): Force to find enemies of. If not given, uses the player force.\n\nNote: This is more efficient than LuaSurface::find_entities.ExampleFind all entities who would be interested to attack the player, within 100-tile area. local enemies = game.player.surface.find_enemy_units(game.player.character.position, 100)",
        "type": "function"
      },
      "find_nearest_enemy": {
        "name": "find_nearest_enemy{position=…, max_distance=…, force=…} → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "position": {
            "doc": "Table with the following fields:  * position :: Position: Center of the search area.\n * max_distance :: double: Radius of the circular search area.\n * force :: string or LuaForce (optional): The force the result will be an enemy of. Uses the player force if not specified.",
            "name": "position",
            "type": "Position"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "max_distance=…": {
            "name": "max_distance=…",
            "type": "max_distance=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Find the enemy closest to the given position.\nParameters\n\n Table with the following fields:  * position :: Position: Center of the search area.\n * max_distance :: double: Radius of the circular search area.\n * force :: string or LuaForce (optional): The force the result will be an enemy of. Uses the player force if not specified.\nReturn value The nearest enemy unit or nil if no enemy could be found within the given area.",
        "type": "function"
      },
      "set_multi_command": {
        "name": "set_multi_command{command=…, unit_count=…, force=…, unit_search_distance=…} → uint",
        "returns": "uint",
        "args": {
          "command": {
            "doc": "Table with the following fields:  * command :: Command\n * unit_count :: uint: Number of units to give the command to.\n * force :: string or LuaForce (optional): Force of the units this command is to be given to. If not specified, uses the enemy force.\n * unit_search_distance :: uint (optional): Radius to search for units. The search area is centered on the destination of the command.",
            "name": "command",
            "type": "Command"
          },
          "command=…": {
            "name": "command=…",
            "type": "command=…"
          },
          "unit_count=…": {
            "name": "unit_count=…",
            "type": "unit_count=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "unit_search_distance=…": {
            "name": "unit_search_distance=…",
            "type": "unit_search_distance=…"
          }
        },
        "doc": "Give a command to multiple units. This will automatically select suitable units for the task.\nParameters\n\n Table with the following fields:  * command :: Command\n * unit_count :: uint: Number of units to give the command to.\n * force :: string or LuaForce (optional): Force of the units this command is to be given to. If not specified, uses the enemy force.\n * unit_search_distance :: uint (optional): Radius to search for units. The search area is centered on the destination of the command.\nReturn value Number of units actually sent. May be less than count if not enough units were available.",
        "type": "function"
      },
      "create_entity": {
        "name": "create_entity{name=…, position=…, direction=…, force=…, target=…, source=…, fast_replace=…, player=…, spill=…} → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "name": {
            "doc": "Table with the following fields:  * name :: string: The entity prototype name to create.\n * position :: Position: Where to create the entity.\n * direction :: defines.direction (optional): Desired orientation of the entity after creation.\n * force :: string or LuaForce (optional): Force of the entity, default is enemy.\n * target :: LuaEntity (optional): Entity with health for the new entity to target.\n * source :: LuaEntity (optional): Source entity. Used for beams.\n * fast_replace :: boolean (optional): If true, building will attempt to simulate fast-replace building.\n * player :: PlayerSpecification (optional): If given along with fast_replace being true, fast-replace will simulate using this player.\n * spill :: boolean (optional): If false while fast_replace is true any excess items from fast-replacing will be deleted instead of dropped on the ground.\n * Additional entity-specific parameters * assembling-machine * recipe :: string (optional)\n      \n      \n    * container * bar :: uint (optional): Inventory index where the red limiting bar should be set.\n      \n      \n    * flying-text * text :: string: The string to show.\n       * color :: Color: Color of the displayed text.\n      \n      \n    * entity-ghost * inner_name :: string: The prototype name of the entity contained in the ghost.\n       * expires :: boolean (optional): If false the ghost entity will not expire. Default is true.\n      \n      \n    * fire * initial_ground_flame_count :: uint: With how many small flames should the fire on ground be created.\n      \n      \n    * inserter * conditions: Table with the following fields:  * circuit :: CircuitCondition (optional)\n          * logistics :: CircuitCondition (optional)\n         \n         \n       * filters :: array of Filter\n      \n      \n    * item-entity * stack :: SimpleItemStack: The stack of items to create. This must be a table, i.e. a single string is not allowed here.\n      \n      \n    * item-request-proxy * modules :: array of SimpleItemStack: The stacks of items to be delivered to target entity from logistic network. Each stack must be table. If empty, the item request proxy won't be created.\n      \n      \n    * logistic-container * request_filters :: array of Filter (optional)\n      \n      \n    * particle * movement :: Vector\n       * height :: float\n       * vertical_speed :: float\n       * frame_speed :: float\n      \n      \n    * projectile * speed :: double\n      \n      \n    * resource * amount :: uint\n      \n      \n    * underground-belt * type :: string (optional): \"output\" or \"input\"; default is \"input\".\n      \n      \n    * programmable-speaker * parameters :: ProgrammableSpeakerParameters (optional)\n       * alert_parameters :: ProgrammableSpeakerAlertParameters (optional)\n      \n      \n    * character-corpse * inventory_size :: uint (optional)\n       * player_index :: uint (optional)",
            "name": "name",
            "type": "string"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "direction=…": {
            "name": "direction=…",
            "type": "direction=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "target=…": {
            "name": "target=…",
            "type": "target=…"
          },
          "source=…": {
            "name": "source=…",
            "type": "source=…"
          },
          "fast_replace=…": {
            "name": "fast_replace=…",
            "type": "fast_replace=…"
          },
          "player=…": {
            "name": "player=…",
            "type": "player=…"
          },
          "spill=…": {
            "name": "spill=…",
            "type": "spill=…"
          }
        },
        "doc": "Create an entity on this surface.\nParameters\n\n Table with the following fields:  * name :: string: The entity prototype name to create.\n * position :: Position: Where to create the entity.\n * direction :: defines.direction (optional): Desired orientation of the entity after creation.\n * force :: string or LuaForce (optional): Force of the entity, default is enemy.\n * target :: LuaEntity (optional): Entity with health for the new entity to target.\n * source :: LuaEntity (optional): Source entity. Used for beams.\n * fast_replace :: boolean (optional): If true, building will attempt to simulate fast-replace building.\n * player :: PlayerSpecification (optional): If given along with fast_replace being true, fast-replace will simulate using this player.\n * spill :: boolean (optional): If false while fast_replace is true any excess items from fast-replacing will be deleted instead of dropped on the ground.\n * Additional entity-specific parameters * assembling-machine * recipe :: string (optional)\n    * container * bar :: uint (optional): Inventory index where the red limiting bar should be set.\n    * flying-text * text :: string: The string to show.\n       * color :: Color: Color of the displayed text.\n    * entity-ghost * inner_name :: string: The prototype name of the entity contained in the ghost.\n       * expires :: boolean (optional): If false the ghost entity will not expire. Default is true.\n    * fire * initial_ground_flame_count :: uint: With how many small flames should the fire on ground be created.\n    * inserter * conditions: Table with the following fields:  * circuit :: CircuitCondition (optional)\n          * logistics :: CircuitCondition (optional)\n       * filters :: array of Filter\n    * item-entity * stack :: SimpleItemStack: The stack of items to create. This must be a table, i.e. a single string is not allowed here.\n    * item-request-proxy * modules :: array of SimpleItemStack: The stacks of items to be delivered to target entity from logistic network. Each stack must be table. If empty, the item request proxy won't be created.\n    * logistic-container * request_filters :: array of Filter (optional)\n    * particle * movement :: Vector\n       * height :: float\n       * vertical_speed :: float\n       * frame_speed :: float\n    * projectile * speed :: double\n    * resource * amount :: uint\n    * underground-belt * type :: string (optional): \"output\" or \"input\"; default is \"input\".\n    * programmable-speaker * parameters :: ProgrammableSpeakerParameters\n\n (optional)\n       * alert_parameters :: ProgrammableSpeakerAlertParameters\n\n (optional)\n    * character-corpse * inventory_size :: uint (optional)\n       * player_index :: uint (optional)\nReturn value The created entity or nil if the creation failed.Example asm = game.surfaces[1].create_entity{name = \"assembling-machine-1\", position = {15, 3}, force=game.forces.player, recipe = \"iron-stick\"} ExampleCreates a smart inserter with circuit conditions and a filter game.surfaces[1].create_entity{\nname = \"filter-inserter\", position = {20, 15}, force=game.player.force,\nconditions={red={name=\"wood\", count=3, operator=\">\"},\ngreen={name=\"iron-ore\", count=1, operator=\" logistics={name=\"wood\", count=3, operator=\"=\"}},\nfilters={ {index=1, name=\"iron-ore\"} }\n} ExampleCreates a requester chest already set to request 128 iron plates. game.surfaces[1].create_entity{\nname = \"logistic-chest-requester\", position = {game.player.position.x+3, game.player.position.y},\nforce=game.player.force, request_filters={ {index=1, name=\"iron-plate\", count=128} }\n} Example game.surfaces[1].create_entity{name = \"big-biter\", position= {15, 3}, force = game.forces.player} -- Friendly biter\ngame.surfaces[1].create_entity{name = \"medium-biter\", position= {15, 3}, force = game.forces.enemy} -- Enemy biter ExampleCreates a basic inserter at the player's location facing north game.surfaces[1].create_entity{name = \"inserter\", position = game.player.position, direction = defines.direction.north}",
        "type": "function"
      },
      "create_unit_group": {
        "name": "create_unit_group{position=…, force=…} → LuaUnitGroup",
        "returns": "LuaUnitGroup",
        "args": {
          "position": {
            "doc": "Table with the following fields:  * position :: Position: Initial position of the new unit group.\n * force :: string or LuaForce (optional): Force of the new unit group. Defaults to \"enemy\".",
            "name": "position",
            "type": "Position"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Create a new unit group at a given position.\nParameters\n\n Table with the following fields:  * position :: Position: Initial position of the new unit group.\n * force :: string or LuaForce (optional): Force of the new unit group. Defaults to \"enemy\".",
        "type": "function"
      },
      "build_enemy_base": {
        "name": "build_enemy_base(position, unit_count, force)",
        "args": {
          "position": {
            "doc": "position :: Position: Location of the new base.",
            "name": "position",
            "type": "Position"
          },
          "unit_count": {
            "doc": "unit_count :: uint: Number of biters to send for the base-building task.",
            "name": "unit_count",
            "type": "uint"
          },
          "force": {
            "doc": "force :: string or LuaForce (optional): Force the new base will belong to. Defaults to enemy.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Send a group to build a new base.\nParameters\n\nposition :: Position: Location of the new base.unit_count :: uint: Number of biters to send for the base-building task.force :: string or LuaForce (optional): Force the new base will belong to. Defaults to enemy.\n\nNote: The specified force must be AI-controlled; i.e. force.ai_controllable must be true.",
        "type": "function"
      },
      "get_tile": {
        "name": "get_tile(x, y) → LuaTile",
        "returns": "LuaTile",
        "args": {
          "x": {
            "doc": "x :: int",
            "name": "x",
            "type": "int"
          },
          "y": {
            "doc": "y :: int",
            "name": "y",
            "type": "int"
          }
        },
        "doc": "Get the tile at a given position.\nParameters\n\nx :: inty :: int\n\nNote: The input position params can also be a single tile position.",
        "type": "function"
      },
      "set_tiles": {
        "name": "set_tiles(tiles, correct_tiles)",
        "args": {
          "tiles": {
            "doc": "tiles :: array of Tile: Each Tile is a table:  * name :: string\n * position :: Position",
            "name": "tiles",
            "type": "array of Tile"
          },
          "correct_tiles": {
            "doc": "correct_tiles :: boolean (optional): If false, the correction logic is not done on the changed tiles. Defaults to true.",
            "name": "correct_tiles",
            "type": "boolean"
          }
        },
        "doc": "Set tiles at specified locations. Automatically corrects the edges around modified tiles.\nParameters\n\ntiles :: array of Tile: Each Tile is a table:  * name :: string\n * position :: Position\ncorrect_tiles :: boolean (optional): If false, the correction logic is not done on the changed tiles. Defaults to true.\n\nNote: It is recommended to call this method once for all the tiles you want to change rather than calling it individually for every tile. As the tile correction is used after every step, calling it one by one could cause the tile correction logic to redo some of the changes, and it is also much performance heavy.",
        "type": "function"
      },
      "pollute": {
        "name": "pollute(source, amount)",
        "args": {
          "source": {
            "doc": "source :: Position: Where to spawn the pollution.",
            "name": "source",
            "type": "Position"
          },
          "amount": {
            "doc": "amount :: double: How much pollution to add.",
            "name": "amount",
            "type": "double"
          }
        },
        "doc": "Spawn pollution at the given position.\nParameters\n\nsource :: Position: Where to spawn the pollution.amount :: double: How much pollution to add.",
        "type": "function"
      },
      "get_chunks": {
        "name": "get_chunks() → LuaChunkIterator",
        "returns": "LuaChunkIterator",
        "args": {},
        "doc": "Get an iterator going over every chunk on this surface.",
        "type": "function"
      },
      "is_chunk_generated": {
        "name": "is_chunk_generated(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: ChunkPosition: The chunk's position.",
            "name": "position",
            "type": "ChunkPosition"
          }
        },
        "doc": "Is a given chunk generated?\nParameters\n\nposition :: ChunkPosition: The chunk's position.",
        "type": "function"
      },
      "request_to_generate_chunks": {
        "name": "request_to_generate_chunks(position, radius)",
        "args": {
          "position": {
            "doc": "position :: Position: Where to generate the new chunks.",
            "name": "position",
            "type": "Position"
          },
          "radius": {
            "doc": "radius :: uint: Radius from position to generate new chunks in.",
            "name": "radius",
            "type": "uint"
          }
        },
        "doc": "Request that the game's map generator generate chunks at the given position for the given radius on this surface.\nParameters\n\nposition :: Position: Where to generate the new chunks.radius :: uint: Radius from position to generate new chunks in.",
        "type": "function"
      },
      "set_chunk_generated_status": {
        "name": "set_chunk_generated_status(position, status)",
        "args": {
          "position": {
            "doc": "position :: Position: The chunk's position.",
            "name": "position",
            "type": "Position"
          },
          "status": {
            "doc": "status :: defines.chunk_generated_status: The chunk's new status.",
            "name": "status",
            "type": "defines.chunk_generated_status"
          }
        },
        "doc": "Set generated status of a chunk. Useful when copying chunks.\nParameters\n\nposition :: Position: The chunk's position.status :: defines.chunk_generated_status: The chunk's new status.",
        "type": "function"
      },
      "find_logistic_network_by_position": {
        "name": "find_logistic_network_by_position(position, force) → LuaLogisticNetwork",
        "returns": "LuaLogisticNetwork",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          },
          "force": {
            "doc": "force :: string or LuaForce: Force the logistic network should belong to.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Find the logistic network that covers a given position.\nParameters\n\nposition :: Positionforce :: string or LuaForce: Force the logistic network should belong to.Return value The found network or nil if no such network was found.",
        "type": "function"
      },
      "find_logistic_networks_by_construction_area": {
        "name": "find_logistic_networks_by_construction_area(position, force) → array of LuaLogisticNetwork",
        "returns": "array of LuaLogisticNetwork",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          },
          "force": {
            "doc": "force :: string or LuaForce: Force the logistic networks should belong to.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Finds all of the logistics networks whos construction area intersects with the given position.\nParameters\n\nposition :: Positionforce :: string or LuaForce: Force the logistic networks should belong to.",
        "type": "function"
      },
      "freeze_daytime": {
        "name": "freeze_daytime(freeze)",
        "args": {
          "freeze": {
            "doc": "freeze :: boolean",
            "name": "freeze",
            "type": "boolean"
          }
        },
        "doc": "Freeze or unfreeze time of day at the current value. \nParameters\n\nfreeze :: boolean",
        "type": "function"
      },
      "deconstruct_area": {
        "name": "deconstruct_area{area=…, force=…}",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox: The area to mark for deconstruction\n * force :: string or LuaForce: The force whose bots should perform the deconstruction.",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Place a deconstruction request. \nParameters\n\n Table with the following fields:  * area :: BoundingBox: The area to mark for deconstruction\n * force :: string or LuaForce: The force whose bots should perform the deconstruction.",
        "type": "function"
      },
      "cancel_deconstruct_area": {
        "name": "cancel_deconstruct_area{area=…, force=…}",
        "args": {
          "area": {
            "doc": "Table with the following fields:  * area :: BoundingBox: The are to cancel deconstruction orders in.\n * force :: string or LuaForce: The force whose deconstruction orders to cancel.",
            "name": "area",
            "type": "BoundingBox"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          }
        },
        "doc": "Cancel a deconstruction order. \nParameters\n\n Table with the following fields:  * area :: BoundingBox: The are to cancel deconstruction orders in.\n * force :: string or LuaForce: The force whose deconstruction orders to cancel.",
        "type": "function"
      },
      "get_hidden_tile": {
        "name": "get_hidden_tile(position)",
        "args": {
          "position": {
            "doc": "position :: Position: The tile position.",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "The hidden tile name or nil if there isn't one for the given position.\nParameters\n\nposition :: Position: The tile position.",
        "type": "function"
      },
      "get_connected_tiles": {
        "name": "get_connected_tiles(position, tiles) → array of Position",
        "returns": "array of Position",
        "args": {
          "position": {
            "doc": "position :: Position: The tile position to start at.",
            "name": "position",
            "type": "Position"
          },
          "tiles": {
            "doc": "tiles :: array of string: The tiles to search for.",
            "name": "tiles",
            "type": "array of string"
          }
        },
        "doc": "Gets all tiles of the given types that are connected horizontally or vertically to the given tile position including the given tile position. \nParameters\n\nposition :: Position: The tile position to start at.tiles :: array of string: The tiles to search for.Return value The resulting set of tiles.\n\nNote: This won't find tiles in non-generated chunks.",
        "type": "function"
      },
      "delete_chunk": {
        "name": "delete_chunk(position)",
        "args": {
          "position": {
            "doc": "position :: Position: The chunk position to delete",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Parameters\n\nposition :: Position: The chunk position to delete\n\nNote: This won't delete the chunk immediately. Chunks are deleted at the end of the current tick.",
        "type": "function"
      },
      "regenerate_entity": {
        "name": "regenerate_entity(entitites, chunks)",
        "args": {
          "entitites": {
            "doc": "entitites :: string or array of string: Prototype names of entity or entities to autoplace.",
            "name": "entitites",
            "type": "string or array of string"
          },
          "chunks": {
            "doc": "chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored.",
            "name": "chunks",
            "type": "array of Position"
          }
        },
        "doc": "Regenerate autoplacement of some entities on this surface. This can be used to autoplace newly-added entities.\nParameters\n\nentitites :: string or array of string: Prototype names of entity or entities to autoplace.chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored.\n\nNote: All specified entity prototypes must be autoplacable.",
        "type": "function"
      },
      "regenerate_decorative": {
        "name": "regenerate_decorative(decoratives, chunks)",
        "args": {
          "decoratives": {
            "doc": "decoratives :: string or array of string: Prototype names of decorative or decoratives to autoplace.",
            "name": "decoratives",
            "type": "string or array of string"
          },
          "chunks": {
            "doc": "chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored.",
            "name": "chunks",
            "type": "array of Position"
          }
        },
        "doc": "Regenerate autoplacement of some decoratives on this surface. This can be used to autoplace newly-added decoratives.\nParameters\n\ndecoratives :: string or array of string: Prototype names of decorative or decoratives to autoplace.chunks :: array of Position (optional): The chunk positions to regenerate the entities on. If not given all chunks are regenerated. Note chunks with status < entities are ignored.\n\nNote: All specified decorative prototypes must be autoplacable.",
        "type": "function"
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console of all players on this surface.\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "destroy_decoratives": {
        "name": "destroy_decoratives(area)",
        "args": {
          "area": {
            "doc": "area :: BoundingBox",
            "name": "area",
            "type": "BoundingBox"
          }
        },
        "doc": "Removes all decoratives from the given area. \nParameters\n\narea :: BoundingBox",
        "type": "function"
      },
      "create_decoratives": {
        "name": "create_decoratives{check_collision=…, decoratives=…}",
        "args": {
          "check_collision": {
            "doc": "Table with the following fields:  * check_collision :: boolean (optional): If collision should be checked against entities/tiles.\n * decoratives :: array of Decorative",
            "name": "check_collision",
            "type": "boolean"
          },
          "check_collision=…": {
            "name": "check_collision=…",
            "type": "check_collision=…"
          },
          "decoratives=…": {
            "name": "decoratives=…",
            "type": "decoratives=…"
          }
        },
        "doc": "Adds the given decoratives to the surface. \n Each Decorative is \n * name :: string\n * position :: Position\n * amount :: uint8\nParameters\n\n Table with the following fields:  * check_collision :: boolean (optional): If collision should be checked against entities/tiles.\n * decoratives :: array of Decorative\n\n\nNote: This will merge decoratives of the same type that alreaday exist effectivly increasing the \"amount\" field.",
        "type": "function"
      },
      "get_trains": {
        "name": "get_trains(force) → array of LuaTrain",
        "returns": "array of LuaTrain",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce (optional): If given only trains matching this force are returned.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Parameters\n\nforce :: string or LuaForce (optional): If given only trains matching this force are returned.",
        "type": "function"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The name of this surface. Names are unique among surfaces."
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Unique ID associated with this surface."
      },
      "map_gen_settings": {
        "name": "map_gen_settings",
        "type": "MapGenSettings",
        "mode": "[Read-only]",
        "doc": "Gets the generation settings for the surface."
      },
      "always_day": {
        "name": "always_day",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When set to true, the sun will always shine."
      },
      "daytime": {
        "name": "daytime",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Current time of day, as a number in range [0, 1)."
      },
      "darkness": {
        "name": "darkness",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Amount of darkness at the current time."
      },
      "wind_speed": {
        "name": "wind_speed",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Current wind speed."
      },
      "wind_orientation": {
        "name": "wind_orientation",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Current wind direction."
      },
      "wind_orientation_change": {
        "name": "wind_orientation_change",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Change in wind orientation per tick."
      },
      "peaceful_mode": {
        "name": "peaceful_mode",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Is peaceful mode enabled on this surface?"
      }
    }
  },
  "LuaStyle": {
    "name": "LuaStyle",
    "type": "LuaStyle",
    "doc": "Style of a GUI element. All of the attributes listed here may be nil if not available for a\n particular GUI element.",
    "properties": {
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[Read-only]",
        "doc": "Gui of the LuaGuiElement of this style."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this style."
      },
      "minimal_width": {
        "name": "minimal_width",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "maximal_width": {
        "name": "maximal_width",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "minimal_height": {
        "name": "minimal_height",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "maximal_height": {
        "name": "maximal_height",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "top_padding": {
        "name": "top_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "right_padding": {
        "name": "right_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "bottom_padding": {
        "name": "bottom_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "left_padding": {
        "name": "left_padding",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "font_color": {
        "name": "font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "font": {
        "name": "font",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "cell_spacing": {
        "name": "cell_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Space between the table cell contents and border. \nCan only be used if this is LuaTableStyle"
      },
      "visible": {
        "name": "visible",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When not visible the GUI element is hidden completely and takes no space in the layout."
      },
      "hovered_font_color": {
        "name": "hovered_font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "clicked_font_color": {
        "name": "clicked_font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "disabled_font_color": {
        "name": "disabled_font_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "pie_progress_color": {
        "name": "pie_progress_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaButtonStyle"
      },
      "max_on_row": {
        "name": "max_on_row",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFlowStyle"
      },
      "resize_row_to_width": {
        "name": "resize_row_to_width",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "resize_to_row_height": {
        "name": "resize_to_row_height",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "horizontal_spacing": {
        "name": "horizontal_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Horizontal space between individual cells. \nCan only be used if this is LuaTableStyle"
      },
      "vertical_spacing": {
        "name": "vertical_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Vertical space between individual cells. \nCan only be used if this is LuaTableStyle"
      },
      "title_top_padding": {
        "name": "title_top_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "title_right_padding": {
        "name": "title_right_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "title_bottom_padding": {
        "name": "title_bottom_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "title_left_padding": {
        "name": "title_left_padding",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaFrameStyle"
      },
      "selection_background_color": {
        "name": "selection_background_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The background color when selecting text. \nCan only be used if this is LuaTextFieldStyle"
      },
      "smooth_size": {
        "name": "smooth_size",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaProgressBarStyle"
      },
      "smooth_color": {
        "name": "smooth_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaProgressBarStyle"
      },
      "diode_count": {
        "name": "diode_count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaProgressBarStyle"
      },
      "column_alignments": {
        "name": "column_alignments",
        "type": "custom array of Alignment",
        "mode": "[Read-only]",
        "doc": "Alignments of columns of the table"
      },
      "horizontal_scrollbar_spacing": {
        "name": "horizontal_scrollbar_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaScrollPaneStyle"
      },
      "vertical_scrollbar_spacing": {
        "name": "vertical_scrollbar_spacing",
        "type": "int",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is LuaScrollPaneStyle"
      }
    }
  },
  "LuaSettings": {
    "name": "LuaSettings",
    "type": "LuaSettings",
    "properties": {
      "get_player_settings": {
        "name": "get_player_settings(LuaPlayer)",
        "args": {
          "LuaPlayer": {
            "name": "LuaPlayer",
            "type": "LuaPlayer"
          }
        },
        "doc": "Parameters\n\n\n\nNote:",
        "type": "function"
      },
      "startup": {
        "name": "startup",
        "type": "custom dictionary string → ModSetting",
        "mode": "[Read-only]",
        "doc": ""
      },
      "global": {
        "name": "global",
        "type": "custom dictionary string → ModSetting",
        "mode": "[Read-only]",
        "doc": ""
      },
      "player": {
        "name": "player",
        "type": "custom dictionary string → ModSetting",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaRemote": {
    "name": "LuaRemote",
    "type": "LuaRemote",
    "doc": "Registry of interfaces between scripts. An interface is simply a dictionary mapping names to functions. A\n script or mod can then register an interface with LuaRemote, after that any script can call the\n registered functions, provided it knows the interface name and the desired function name. An instance of\n LuaRemote is available through the global object named remote.",
    "properties": {
      "add_interface": {
        "name": "add_interface(name, functions)",
        "args": {
          "name": {
            "doc": "name :: string: Name of the interface.",
            "name": "name",
            "type": "string"
          },
          "functions": {
            "doc": "functions :: dictionary string → function: List of functions that are members of the new interface.",
            "name": "functions",
            "type": "dictionary string → function"
          }
        },
        "doc": "Add a remote interface.\nParameters\n\nname :: string: Name of the interface.functions :: dictionary string → function: List of functions that are members of the new interface.\n\nNote: It is an error if the given interface name is already registered.",
        "type": "function"
      },
      "remove_interface": {
        "name": "remove_interface(name) → boolean",
        "returns": "boolean",
        "args": {
          "name": {
            "doc": "name :: string: Name of the interface.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Removes an interface with the given name. \nParameters\n\nname :: string: Name of the interface.Return value If the interface was removed. False if the interface didn't exist.",
        "type": "function"
      },
      "call": {
        "name": "call(interface, function, ...)",
        "args": {
          "interface": {
            "doc": "interface :: string: Interface to look up function in.",
            "name": "interface",
            "type": "string"
          },
          "function": {
            "doc": "function :: string: Function name that belongs to interface.",
            "name": "function",
            "type": "string"
          },
          "...": {
            "doc": "...: Arguments to pass to the called function.",
            "name": "..."
          }
        },
        "doc": "Call a function of an interface.\nParameters\n\ninterface :: string: Interface to look up function in.function :: string: Function name that belongs to interface....: Arguments to pass to the called function.",
        "type": "function"
      },
      "interfaces": {
        "name": "interfaces",
        "type": "dictionary string → dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "List of all registered interfaces. For each interface name, remote.interfaces[name] is a dictionary mapping the interface's registered functions to the value true.\nExampleAssuming the \"human interactor\" interface is registered as above game.player.print(tostring(remote.interfaces[\"human interactor\"][\"hello\"])) -- prints true\ngame.player.print(tostring(remote.interfaces[\"human interactor\"][\"nonexistent\"])) -- prints nil"
      }
    }
  },
  "LuaRecipePrototype": {
    "name": "LuaRecipePrototype",
    "type": "LuaRecipePrototype",
    "doc": "A crafting recipe prototype.",
    "properties": {
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this recipe prototype is enabled by default (enabled at the begining of a game)."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the recipe. This can be different than the name of the result items as there could be more recipes to make the same item."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the recipe."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Category of the recipe."
      },
      "ingredients": {
        "name": "ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients for this recipe."
      },
      "products": {
        "name": "products",
        "type": "array of Product",
        "mode": "[Read-only]",
        "doc": "The results of this recipe."
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is the recipe hidden? Hidden recipe don't show up in the crafting menu."
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Energy required to execute this recipe. This directly affects the crafting time: Recipe's energy is exactly its crafting time in seconds, when crafted in an assembling machine with crafting speed exactly equal to one."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string. This is used to sort the crafting menu."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this recipe."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this recipe."
      },
      "request_paste_multiplier": {
        "name": "request_paste_multiplier",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The multiplier used when this recipe is copied from an assembling machine to a requester chest. For each item in the recipe the item count * this value is set in the requester chest."
      },
      "overload_multiplier": {
        "name": "overload_multiplier",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Used to determine how many extra items are put into an assembling machine before it's considered \"full enough\"."
      }
    }
  },
  "LuaRecipe": {
    "name": "LuaRecipe",
    "type": "LuaRecipe",
    "doc": "A crafting recipe. Recipes belong to forces (see LuaForce) because some recipes\n are unlocked by research, and researches are per-force.",
    "properties": {
      "reload": {
        "name": "reload()",
        "args": {},
        "doc": "Reload the recipe from the prototype.",
        "type": "function"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the recipe. This can be different than the name of the result items as there could be more recipes to make the same item."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the recipe."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaRecipePrototype",
        "mode": "[Read-only]",
        "doc": "The prototype for this recipe."
      },
      "enabled": {
        "name": "enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Can the recipe be used?"
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Category of the recipe."
      },
      "ingredients": {
        "name": "ingredients",
        "type": "array of Ingredient",
        "mode": "[Read-only]",
        "doc": "Ingredients for this recipe. \nExampleWhat the \"steel-chest\" recipe would return { {type=\"item\", name=\"steel-plate\", amount=8} } ExampleWhat the \"advanced-oil-processing\" recipe would return { {type=\"fluid\", name=\"crude-oil\", amount=10}, {type=\"fluid\", name=\"water\", amount=5} }"
      },
      "products": {
        "name": "products",
        "type": "array of Product",
        "mode": "[Read-only]",
        "doc": "The results of this recipe."
      },
      "hidden": {
        "name": "hidden",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is the recipe hidden? Hidden recipe don't show up in the crafting menu."
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Energy required to execute this recipe. This directly affects the crafting time: Recipe's energy is exactly its crafting time in seconds, when crafted in an assembling machine with crafting speed exactly equal to one."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string. This is used to sort the crafting menu."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this recipe."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this recipe."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force that owns this recipe."
      }
    }
  },
  "LuaRandomGenerator": {
    "name": "LuaRandomGenerator",
    "type": "LuaRandomGenerator",
    "doc": "A deterministic random generator independent from the core games random generator that can be seeded and re-seeded at will.\n This random generator can be saved and loaded and will maintain its state.\n Note this is entirely different from calling math.random(...) and you should be sure you actually want to use this over calling math.random(...).",
    "properties": {
      "()": {
        "name": "operator ()(lower, upper) → double",
        "returns": "double",
        "args": {
          "lower": {
            "doc": "lower :: double (optional): Inclusive lower bound on the result",
            "name": "lower",
            "type": "double"
          },
          "upper": {
            "doc": "upper :: double (optional): Exclusive upper bound on the result",
            "name": "upper",
            "type": "double"
          }
        },
        "doc": "Generates a random number. If no parameters are given a number in the [0, 1) range is returned. If a single parameter is given a floored number in the [0, N) range is returned. If 2 parameters are given a floored number in the [N1, N2) range is returned. \nParameters\n\nlower :: double (optional): Inclusive lower bound on the resultupper :: double (optional): Exclusive upper bound on the result",
        "type": "function"
      },
      "re_seed": {
        "name": "re_seed(seed)",
        "args": {
          "seed": {
            "doc": "seed :: uint",
            "name": "seed",
            "type": "uint"
          }
        },
        "doc": "Re-seeds the random generator with the given value. \nParameters\n\nseed :: uint",
        "type": "function"
      }
    }
  },
  "LuaPlayer": {
    "name": "LuaPlayer",
    "type": "LuaPlayer",
    "doc": "A player in the game. Pay attention that a player may or may not have a character, which is the\n LuaEntity of the little guy running around the world doing things.",
    "properties": {
      "set_ending_screen_data": {
        "name": "set_ending_screen_data(message, file)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString: Message to be shown.",
            "name": "message",
            "type": "LocalisedString"
          },
          "file": {
            "doc": "file :: string (optional): Path to image to be shown.",
            "name": "file",
            "type": "string"
          }
        },
        "doc": "Setup the screen to be shown when the game is finished.\nParameters\n\nmessage :: LocalisedString: Message to be shown.file :: string (optional): Path to image to be shown.",
        "type": "function"
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console.\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "clear_console": {
        "name": "clear_console()",
        "args": {},
        "doc": "Clear the chat console.",
        "type": "function"
      },
      "get_goal_description": {
        "name": "get_goal_description() → LocalisedString",
        "returns": "LocalisedString",
        "args": {},
        "doc": "Get the current goal description, as a localised string.",
        "type": "function"
      },
      "set_goal_description": {
        "name": "set_goal_description(text, only_update)",
        "args": {
          "text": {
            "doc": "text :: LocalisedString (optional): The text to display. \\n can be used to delimit lines. Passing empty string or omitting this parameter entirely will make the goal window disappear.",
            "name": "text",
            "type": "LocalisedString"
          },
          "only_update": {
            "doc": "only_update :: boolean (optional): When true, won't play the \"goal updated\" sound.",
            "name": "only_update",
            "type": "boolean"
          }
        },
        "doc": "Set the text in the goal window (top left).\nParameters\n\ntext :: LocalisedString (optional): The text to display. \\n can be used to delimit lines. Passing empty string or omitting this parameter entirely will make the goal window disappear.only_update :: boolean (optional): When true, won't play the \"goal updated\" sound.",
        "type": "function"
      },
      "set_controller": {
        "name": "set_controller{type=…, character=…}",
        "args": {
          "type": {
            "doc": "Table with the following fields:  * type :: defines.controllers: Which controller to use\n * character :: LuaEntity (optional): Entity to control. Mandatory when type is defines.controllers.character, ignored otherwise.",
            "name": "type",
            "type": "defines.controllers"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          },
          "character=…": {
            "name": "character=…",
            "type": "character=…"
          }
        },
        "doc": "Set the controller type of the player.\nParameters\n\n Table with the following fields:  * type :: defines.controllers: Which controller to use\n * character :: LuaEntity (optional): Entity to control. Mandatory when type is defines.controllers.character, ignored otherwise.",
        "type": "function"
      },
      "disable_recipe_groups": {
        "name": "disable_recipe_groups()",
        "args": {},
        "doc": "Disable recipe groups.\n\n\nNote: There is no way to undo this.",
        "type": "function"
      },
      "disable_recipe_subgroups": {
        "name": "disable_recipe_subgroups()",
        "args": {},
        "doc": "Disable recipe subgroups.\n\n\nNote: There is no way to undo this.",
        "type": "function"
      },
      "print_entity_statistics": {
        "name": "print_entity_statistics(entities)",
        "args": {
          "entities": {
            "doc": "entities :: array of string (optional): Entity prototypes to get statistics for. If not specified or empty, display statistics for all entities.",
            "name": "entities",
            "type": "array of string"
          }
        },
        "doc": "Print entity statistics to the player's console. \nParameters\n\nentities :: array of string (optional): Entity prototypes to get statistics for. If not specified or empty, display statistics for all entities.",
        "type": "function"
      },
      "unlock_achievement": {
        "name": "unlock_achievement(name)",
        "args": {
          "name": {
            "doc": "name :: string: name of the achievement to unlock",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Unlock the achievements of the given player. This has any effect only when this is the local player and the achievement isn't unlocked so far. \nParameters\n\nname :: string: name of the achievement to unlock",
        "type": "function"
      },
      "clean_cursor": {
        "name": "clean_cursor() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Invokes the \"clean cursor\" action on the player as if the user pressed it. \nReturn value If the cursor is now empty.",
        "type": "function"
      },
      "create_character": {
        "name": "create_character(character)",
        "args": {
          "character": {
            "doc": "character :: string (optional): The character to create else the default is used.",
            "name": "character",
            "type": "string"
          }
        },
        "doc": "Creates and attaches a character entity to this player. \nParameters\n\ncharacter :: string (optional): The character to create else the default is used.\n\nNote: The player must not have a character already associated and must be online (see LuaPlayer::connected).",
        "type": "function"
      },
      "add_alert": {
        "name": "add_alert(entity, type)",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          },
          "type": {
            "doc": "type :: defines.alert_type",
            "name": "type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Adds an alert to this player for the given entity of the given alert type. \nParameters\n\nentity :: LuaEntitytype :: defines.alert_type",
        "type": "function"
      },
      "add_custom_alert": {
        "name": "add_custom_alert(entity, icon, message, show_on_map)",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          },
          "icon": {
            "doc": "icon :: SignalID",
            "name": "icon",
            "type": "SignalID"
          },
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          },
          "show_on_map": {
            "doc": "show_on_map :: boolean",
            "name": "show_on_map",
            "type": "boolean"
          }
        },
        "doc": "Adds a custom alert to this player. \nParameters\n\nentity :: LuaEntityicon :: SignalIDmessage :: LocalisedStringshow_on_map :: boolean",
        "type": "function"
      },
      "remove_alert": {
        "name": "remove_alert{entity=…, prototype=…, position=…, type=…, surface=…, icon=…, message=…}",
        "args": {
          "entity": {
            "doc": "Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)\n * icon :: SignalID (optional)\n * message :: LocalisedString (optional)",
            "name": "entity",
            "type": "LuaEntity"
          },
          "entity=…": {
            "name": "entity=…",
            "type": "entity=…"
          },
          "prototype=…": {
            "name": "prototype=…",
            "type": "prototype=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          },
          "icon=…": {
            "name": "icon=…",
            "type": "icon=…"
          },
          "message=…": {
            "name": "message=…",
            "type": "message=…"
          }
        },
        "doc": "Removes all alerts matching the given filters or if an empty filters table is given all alerts are removed. \nParameters\n\n Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)\n * icon :: SignalID (optional)\n * message :: LocalisedString (optional)",
        "type": "function"
      },
      "get_alerts": {
        "name": "get_alerts{entity=…, prototype=…, position=…, type=…, surface=…} → dictionary uint → dictionary defines.alert_type → array of alert",
        "returns": "dictionary uint → dictionary defines.alert_type → array of alert",
        "args": {
          "entity": {
            "doc": "Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)",
            "name": "entity",
            "type": "LuaEntity"
          },
          "entity=…": {
            "name": "entity=…",
            "type": "entity=…"
          },
          "prototype=…": {
            "name": "prototype=…",
            "type": "prototype=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          }
        },
        "doc": "Gets all alerts matching the given filters or if no filters are given all alerts are returned. \n A mapping of surface index to an array of arrays of alerts indexed by the alert type. An alert is a table: \n * target :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * tick :: uint: The tick this alert was created\n * icon :: SignalID (optional): The SignalID used for a custom alert. Only present for custom alerts.\n * message :: LocalisedString (optional): The message for a custom alert. Only present for custom alerts.\nParameters\n\n Table with the following fields:  * entity :: LuaEntity (optional)\n * prototype :: LuaEntityPrototype (optional)\n * position :: Position (optional)\n * type :: defines.alert_type (optional)\n * surface :: SurfaceSpecification (optional)",
        "type": "function"
      },
      "mute_alert": {
        "name": "mute_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Mutes alerts for the given alert category. \nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was muted (false if it was already muted).",
        "type": "function"
      },
      "unmute_alert": {
        "name": "unmute_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Unmutes alerts for the given alert category. \nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was unmuted (false if it was wasn't muted).",
        "type": "function"
      },
      "is_alert_muted": {
        "name": "is_alert_muted(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "If the given alert type is currently muted. \nParameters\n\nalert_type :: defines.alert_type",
        "type": "function"
      },
      "enable_alert": {
        "name": "enable_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Enables alerts for the given alert category. \nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was enabled (false if it was already enabled).",
        "type": "function"
      },
      "disable_alert": {
        "name": "disable_alert(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "Disables alerts for the given alert category. \nParameters\n\nalert_type :: defines.alert_typeReturn value If the alert type was disabled (false if it was already disabled).",
        "type": "function"
      },
      "is_alert_enabled": {
        "name": "is_alert_enabled(alert_type) → boolean",
        "returns": "boolean",
        "args": {
          "alert_type": {
            "doc": "alert_type :: defines.alert_type",
            "name": "alert_type",
            "type": "defines.alert_type"
          }
        },
        "doc": "If the given alert type is currently enabled. \nParameters\n\nalert_type :: defines.alert_type",
        "type": "function"
      },
      "character": {
        "name": "character",
        "type": "LuaEntity",
        "mode": "[Read-Write]",
        "doc": "The character attached to this player, or nil if no character.\n\n\nNote: It is not valid to access this attribute when the player is disconnected (see LuaPlayer::connected)."
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "This player's index in LuaGameScript::players."
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[Read-only]",
        "doc": ""
      },
      "opened_self": {
        "name": "opened_self",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if the player opened itself. I.e. if they opened the character or god-controller GUI."
      },
      "controller_type": {
        "name": "controller_type",
        "type": "defines.controllers",
        "mode": "[Read-only]",
        "doc": ""
      },
      "game_view_settings": {
        "name": "game_view_settings",
        "type": "GameViewSettings",
        "mode": "[Read-Write]",
        "doc": "The player's game view settings."
      },
      "minimap_enabled": {
        "name": "minimap_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "true if the minimap is visible."
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The colour associated with the player. This will be used to tint the player's character as well as their buildings and vehicles."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The player's username."
      },
      "tag": {
        "name": "tag",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The tag that is shown after the player in chat and on the map."
      },
      "connected": {
        "name": "connected",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if the player is currently connected to the game."
      },
      "admin": {
        "name": "admin",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if the player is an admin."
      },
      "entity_copy_source": {
        "name": "entity_copy_source",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The source entity used during entity settings copy-paste if any. \n nil if there isn't currently a source entity."
      },
      "afk_time": {
        "name": "afk_time",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "How many ticks since the last action of this player"
      },
      "online_time": {
        "name": "online_time",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "How many ticks did this player spend playing this save (all sessions combined)"
      },
      "permission_group": {
        "name": "permission_group",
        "type": "LuaPermissionGroup",
        "mode": "[Read-Write]",
        "doc": "The permission group this player is part of or nil if not part of any group."
      },
      "cursor_position": {
        "name": "cursor_position",
        "type": "Position",
        "mode": "[Write-only]",
        "doc": "Position of the player's mouse cursor. This is in screen coordinates."
      },
      "zoom": {
        "name": "zoom",
        "type": "double",
        "mode": "[Write-only]",
        "doc": "The player's zoom-level."
      }
    }
  },
  "LuaPermissionGroups": {
    "name": "LuaPermissionGroups",
    "type": "LuaPermissionGroups",
    "doc": "All permission groups.",
    "properties": {
      "create_group": {
        "name": "create_group(name) → LuaPermissionGroup",
        "returns": "LuaPermissionGroup",
        "args": {
          "name": {
            "doc": "name :: string (optional)",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Creates a new permission group. \nParameters\n\nname :: string (optional)\n\nNote: May return nil if the calling player doesn't have permission to make groups.",
        "type": "function"
      },
      "get_group": {
        "name": "get_group(group) → LuaPermissionGroup",
        "returns": "LuaPermissionGroup",
        "args": {
          "group": {
            "doc": "group :: string or uint",
            "name": "group",
            "type": "string or uint"
          }
        },
        "doc": "Gets the permission group with the given name or group ID or nil if there is no matching group. \nParameters\n\ngroup :: string or uint",
        "type": "function"
      },
      "groups": {
        "name": "groups",
        "type": "array of LuaPermissionGroup",
        "mode": "[Read-only]",
        "doc": "All of the permission groups."
      }
    }
  },
  "LuaPermissionGroup": {
    "name": "LuaPermissionGroup",
    "type": "LuaPermissionGroup",
    "doc": "A permission group that defines what players in this group are allowed to do.",
    "properties": {
      "add_player": {
        "name": "add_player(player) → boolean",
        "returns": "boolean",
        "args": {
          "player": {
            "doc": "player :: PlayerSpecification",
            "name": "player",
            "type": "PlayerSpecification"
          }
        },
        "doc": "Adds the given player to this group. \nParameters\n\nplayer :: PlayerSpecificationReturn value If the player was added.",
        "type": "function"
      },
      "remove_player": {
        "name": "remove_player(player) → boolean",
        "returns": "boolean",
        "args": {
          "player": {
            "doc": "player :: PlayerSpecification",
            "name": "player",
            "type": "PlayerSpecification"
          }
        },
        "doc": "Removes the given player from this group. \nParameters\n\nplayer :: PlayerSpecificationReturn value If the player was removed.",
        "type": "function"
      },
      "allows_action": {
        "name": "allows_action(action) → boolean",
        "returns": "boolean",
        "args": {
          "action": {
            "doc": "action: The defines.input_action value.",
            "name": "action"
          }
        },
        "doc": "If this group allows the given action. \nParameters\n\naction: The defines.input_action value.",
        "type": "function"
      },
      "set_allows_action": {
        "name": "set_allows_action(action, boolean) → boolean",
        "returns": "boolean",
        "args": {
          "action": {
            "doc": "action: The defines.input_action value.",
            "name": "action"
          },
          "boolean": {
            "name": "boolean",
            "type": "boolean"
          }
        },
        "doc": "Sets if the player is allowed to perform the given action. \nParameters\n\naction: The defines.input_action value.Return value If the value was applied.",
        "type": "function"
      },
      "destroy": {
        "name": "destroy() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Destroys this group. \nReturn value If the group was destroyed.",
        "type": "function"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The name of this group. \n\n\nNote: Setting to nil or an empty string sets the name to the default value."
      },
      "players": {
        "name": "players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The players in this group."
      },
      "group_id": {
        "name": "group_id",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The group ID"
      }
    }
  },
  "LuaLogisticPoint": {
    "name": "LuaLogisticPoint",
    "type": "LuaLogisticPoint",
    "doc": "Logistic point of a particular LuaEntity. A \"Logistic point\" is the name given for\n settings and properties used by requester, provider, and storage points in a given logistic network.\n These \"points\" don't have to be a logistic container but often are. One other entity that can own several\n points is the \"player\" character type entity.",
    "properties": {
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The LuaEntity owner of this LuaLogisticPoint."
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": ""
      },
      "logistic_member_index": {
        "name": "logistic_member_index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The Logistic member index of this logistic point."
      },
      "filters": {
        "name": "filters",
        "type": "array of LogisticFilter",
        "mode": "[Read-only]",
        "doc": "The logistic filters for this logistic point or nil if this doesn't use logistic filters. \n\n\nNote: The returned array will always have an entry for each filter and will be indexed in sequence when not nil."
      },
      "mode": {
        "name": "mode",
        "type": "defines.logistic_mode",
        "mode": "[Read-only]",
        "doc": "The logistic mode."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force of this logistic point. \n\n\nNote: This will always be the same as the LuaLogisticPoint::owner force."
      },
      "targeted_items_pickup": {
        "name": "targeted_items_pickup",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "Items targeted to be picked up from this logistic point by robots."
      },
      "targeted_items_deliver": {
        "name": "targeted_items_deliver",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "Items targeted to be dropped off into this logistic point by robots."
      },
      "exact": {
        "name": "exact",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this logistic point is using the exact mode. In exact mode robots never over-deliver requests."
      }
    }
  },
  "LuaLogisticNetwork": {
    "name": "LuaLogisticNetwork",
    "type": "LuaLogisticNetwork",
    "doc": "A single logistic network of a given force on a given surface.",
    "properties": {
      "get_item_count": {
        "name": "get_item_count(item, member) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Item name to count. If not given, gives counts of all items in the network.",
            "name": "item",
            "type": "string"
          },
          "member": {
            "doc": "member :: string (optional): Logistic members to check, must be either \"storage\"or \"providers\". If not given, gives count in the entire network.",
            "name": "member",
            "type": "string"
          }
        },
        "doc": "Count given or all items in the network or given members.\nParameters\n\nitem :: string (optional): Item name to count. If not given, gives counts of all items in the network.member :: string (optional): Logistic members to check, must be either \"storage\"or \"providers\". If not given, gives count in the entire network.",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get item counts for the entire network. \nReturn value A mapping of item prototype names to the number available in the network.See also * LuaInventory::get_contents",
        "type": "function"
      },
      "remove_item": {
        "name": "remove_item(item, members) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: SimpleItemStack: What to remove.",
            "name": "item",
            "type": "SimpleItemStack"
          },
          "members": {
            "doc": "members :: string (optional): Which logistic members to remove from. Must be \"storage\", \"passive-provider\", or \"active-provider\". If not specified, removes from the network in the usual order.",
            "name": "members",
            "type": "string"
          }
        },
        "doc": "Remove items from the logistic network. This will actually remove the items from some logistic chests.\nParameters\n\nitem :: SimpleItemStack: What to remove.members :: string (optional): Which logistic members to remove from. Must be \"storage\", \"passive-provider\", or \"active-provider\". If not specified, removes from the network in the usual order.Return value Number of items removed.",
        "type": "function"
      },
      "insert": {
        "name": "insert(item, members) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: LuaItemStack: What to insert.",
            "name": "item",
            "type": "LuaItemStack"
          },
          "members": {
            "doc": "members :: string (optional): Which logistic members to insert the items to. Must be \"storage\", \"storage-empty\" (storage chests that are completely empty), \"storage-empty-slot\" (storage chests that have an empty slot), or \"requester\". If not specified, inserts items into the logistic network in the usual order.",
            "name": "members",
            "type": "string"
          }
        },
        "doc": "Insert items into the logistic network. This will actually insert the items into some logistic chests.\nParameters\n\nitem :: LuaItemStack: What to insert.members :: string (optional): Which logistic members to insert the items to. Must be \"storage\", \"storage-empty\" (storage chests that are completely empty), \"storage-empty-slot\" (storage chests that have an empty slot), or \"requester\". If not specified, inserts items into the logistic network in the usual order.Return value Number of items actually inserted.",
        "type": "function"
      },
      "find_cell_closest_to": {
        "name": "find_cell_closest_to(position) → LuaLogisticCell",
        "returns": "LuaLogisticCell",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find logistic cell closest to a given position.\nParameters\n\nposition :: PositionReturn value May be nil if no cell was found.",
        "type": "function"
      },
      "available_logistic_robots": {
        "name": "available_logistic_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of logistic robots available for a job."
      },
      "all_logistic_robots": {
        "name": "all_logistic_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The total number of logistic robots in the network (idle and active + in roboports)."
      },
      "available_construction_robots": {
        "name": "available_construction_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of construction robots available for a job."
      },
      "all_construction_robots": {
        "name": "all_construction_robots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The total number of construction robots in the network (idle and active + in roboports)."
      },
      "robot_limit": {
        "name": "robot_limit",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Maximum number of robots the network can work with. Currently only used for the personal roboport."
      },
      "cells": {
        "name": "cells",
        "type": "array of LuaLogisticCell",
        "mode": "[Read-only]",
        "doc": "All cells in this network."
      },
      "providers": {
        "name": "providers",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have logistic provider points in this network."
      },
      "empty_providers": {
        "name": "empty_providers",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have empty logistic provider points in this network."
      },
      "requesters": {
        "name": "requesters",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have logistic requester points in this network."
      },
      "full_or_satisfied_requesters": {
        "name": "full_or_satisfied_requesters",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have full or satisfied logistic requester points in this network."
      },
      "storages": {
        "name": "storages",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All entities that have logistic storage points in this network."
      },
      "logistic_members": {
        "name": "logistic_members",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "All other entities that have logistic points in this network (inserters mostly)."
      },
      "provider_points": {
        "name": "provider_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have provider points in this network."
      },
      "empty_provider_points": {
        "name": "empty_provider_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have empty provider points in this network."
      },
      "requester_points": {
        "name": "requester_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have requester points in this network."
      },
      "full_or_satisfied_requester_points": {
        "name": "full_or_satisfied_requester_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have full or satisfied requester points in this network."
      },
      "storage_points": {
        "name": "storage_points",
        "type": "array of LuaLogisticPoint",
        "mode": "[Read-only]",
        "doc": "All things that have storage points in this network."
      }
    }
  },
  "LuaLogisticCell": {
    "name": "LuaLogisticCell",
    "type": "LuaLogisticCell",
    "doc": "Logistic cell of a particular LuaEntity. A \"Logistic Cell\" is the given name for\n settings and properties used by what would normally be seen as a \"Roboport\". A logistic\n cell however doesn't have to be attached to the roboport entity (the player has one for\n the personal roboport).",
    "properties": {
      "is_in_logistic_range": {
        "name": "is_in_logistic_range(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Is a given position within the logistic range of this cell?\nParameters\n\nposition :: Position",
        "type": "function"
      },
      "is_in_construction_range": {
        "name": "is_in_construction_range(position) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: Position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Is a given position within the construction range of this cell?\nParameters\n\nposition :: Position",
        "type": "function"
      },
      "is_neighbour_with": {
        "name": "is_neighbour_with(other) → boolean",
        "returns": "boolean",
        "args": {
          "other": {
            "doc": "other :: LuaLogisticCell",
            "name": "other",
            "type": "LuaLogisticCell"
          }
        },
        "doc": "Are two cells neighbours?\nParameters\n\nother :: LuaLogisticCell",
        "type": "function"
      },
      "logistic_radius": {
        "name": "logistic_radius",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Logistic radius of this cell."
      },
      "construction_radius": {
        "name": "construction_radius",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Construction radius of this cell."
      },
      "stationed_logistic_robot_count": {
        "name": "stationed_logistic_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of stationed logistic robots in this cell."
      },
      "stationed_construction_robot_count": {
        "name": "stationed_construction_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of stationed construction robots in this cell."
      },
      "mobile": {
        "name": "mobile",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if this is a mobile cell. In vanilla, only the logistic cell created by a player's personal roboport is mobile."
      },
      "transmitting": {
        "name": "transmitting",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "true if this cell is active."
      },
      "charge_approach_distance": {
        "name": "charge_approach_distance",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Radius at which the robots hover when waiting to be charged."
      },
      "charging_robot_count": {
        "name": "charging_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of robots currently charging."
      },
      "to_charge_robot_count": {
        "name": "to_charge_robot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of robots waiting to charge."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "This cell's owner."
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": "The network that owns this cell or nil."
      },
      "neighbours": {
        "name": "neighbours",
        "type": "array of LuaLogisticCell",
        "mode": "[Read-only]",
        "doc": "Neighbouring cells."
      },
      "charging_robots": {
        "name": "charging_robots",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Robots currently being charged."
      },
      "to_charge_robots": {
        "name": "to_charge_robots",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "Robots waiting to charge."
      }
    }
  },
  "LuaItemStack": {
    "name": "LuaItemStack",
    "type": "LuaItemStack",
    "doc": "A reference to an item and count owned by some external entity.",
    "properties": {
      "is_blueprint_setup": {
        "name": "is_blueprint_setup() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Is this blueprint item setup? I.e. is it a non-empty blueprint?",
        "type": "function"
      },
      "get_blueprint_entities": {
        "name": "get_blueprint_entities() → array of blueprint entity",
        "returns": "array of blueprint entity",
        "args": {},
        "doc": "Entities in this blueprint.\nReturn value The fields of an entity table depend on the type of the entity. Every entity has at least the following fields:  * entity_number :: uint: Entity's unique identifier in this blueprint\n * name :: string: Prototype name of the entity\n * position :: Position: Position of the entity\n * direction :: defines.direction (optional): The direction the entity is facing. Only present for entities that can face in different directions.\n * other: Entity-specific fields...\nCan only be used if this is BlueprintItem",
        "type": "function"
      },
      "set_blueprint_entities": {
        "name": "set_blueprint_entities(entities)",
        "args": {
          "entities": {
            "doc": "entities :: array of blueprint entity: New blueprint entities. The format is the same as in LuaItemStack::get_blueprint_entities.",
            "name": "entities",
            "type": "array of blueprint entity"
          }
        },
        "doc": "Set new entities to be a part of this blueprint.\nParameters\n\nentities :: array of blueprint entity: New blueprint entities. The format is the same as in LuaItemStack::get_blueprint_entities.Can only be used if this is BlueprintItem",
        "type": "function"
      },
      "add_ammo": {
        "name": "add_ammo(amount)",
        "args": {
          "amount": {
            "doc": "amount :: uint: Amount of ammo to add.",
            "name": "amount",
            "type": "uint"
          }
        },
        "doc": "Add ammo to this ammo item.\nParameters\n\namount :: uint: Amount of ammo to add.Can only be used if this is AmmoItem",
        "type": "function"
      },
      "drain_ammo": {
        "name": "drain_ammo(amount)",
        "args": {
          "amount": {
            "doc": "amount :: uint: Amount of ammo to remove.",
            "name": "amount",
            "type": "uint"
          }
        },
        "doc": "Remove ammo from this ammo item.\nParameters\n\namount :: uint: Amount of ammo to remove.Can only be used if this is AmmoItem",
        "type": "function"
      },
      "add_durability": {
        "name": "add_durability(amount)",
        "args": {
          "amount": {
            "doc": "amount :: double: Amount of durability to add.",
            "name": "amount",
            "type": "double"
          }
        },
        "doc": "Add durability to this tool item.\nParameters\n\namount :: double: Amount of durability to add.Can only be used if this is ToolItem",
        "type": "function"
      },
      "drain_durability": {
        "name": "drain_durability(amount)",
        "args": {
          "amount": {
            "doc": "amount :: double: Amount of durability to remove.",
            "name": "amount",
            "type": "double"
          }
        },
        "doc": "Remove durability from this tool item.\nParameters\n\namount :: double: Amount of durability to remove.Can only be used if this is ToolItem",
        "type": "function"
      },
      "can_set_stack": {
        "name": "can_set_stack(stack) → boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "doc": "stack :: LuaItemStack or SimpleItemStack (optional): Stack that would be set, possibly nil.",
            "name": "stack",
            "type": "LuaItemStack or SimpleItemStack"
          }
        },
        "doc": "Would a call to LuaItemStack::set_stack succeed?\nParameters\n\nstack :: LuaItemStack or SimpleItemStack (optional): Stack that would be set, possibly nil.",
        "type": "function"
      },
      "set_stack": {
        "name": "set_stack(stack) → boolean",
        "returns": "boolean",
        "args": {
          "stack": {
            "doc": "stack :: LuaItemStack or SimpleItemStack (optional): Item stack to set this one to. Omitting this parameter or passing nil will clear this item stack, as if by calling LuaItemStack::clear.",
            "name": "stack",
            "type": "LuaItemStack or SimpleItemStack"
          }
        },
        "doc": "Set this item stack to another item stack.\nParameters\n\nstack :: LuaItemStack or SimpleItemStack (optional): Item stack to set this one to. Omitting this parameter or passing nil will clear this item stack, as if by calling LuaItemStack::clear.Return value Was the stack set successfully?",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Clear this item stack.",
        "type": "function"
      },
      "get_blueprint_tiles": {
        "name": "get_blueprint_tiles() → array of blueprint tile",
        "returns": "array of blueprint tile",
        "args": {},
        "doc": "Tiles in this blueprint \nReturn value A blueprint tile is a table:  * position :: Position\n * name :: string: Prototype name of the tile.\nCan only be used if this is BlueprintItem",
        "type": "function"
      },
      "set_blueprint_tiles": {
        "name": "set_blueprint_tiles(tiles)",
        "args": {
          "tiles": {
            "doc": "tiles :: array of blueprint tile: Tiles to be a part of the blueprint; the format is the same as is returned from the corresponding get function; see LuaItemStack::get_blueprint_tiles.",
            "name": "tiles",
            "type": "array of blueprint tile"
          }
        },
        "doc": "Set tiles in this blueprint \nParameters\n\ntiles :: array of blueprint tile: Tiles to be a part of the blueprint; the format is the same as is returned from the corresponding get function; see LuaItemStack::get_blueprint_tiles.Can only be used if this is BlueprintItem",
        "type": "function"
      },
      "get_inventory": {
        "name": "get_inventory(inventory) → LuaInventory",
        "returns": "LuaInventory",
        "args": {
          "inventory": {
            "doc": "inventory :: defines.inventory: Index of the inventory to access -- currently can only be defines.inventory.item_main.",
            "name": "inventory",
            "type": "defines.inventory"
          }
        },
        "doc": "Access the inner inventory of an item.\nParameters\n\ninventory :: defines.inventory: Index of the inventory to access -- currently can only be defines.inventory.item_main.Return value or nil if there is no inventory with the given index.",
        "type": "function"
      },
      "build_blueprint": {
        "name": "build_blueprint{surface=…, force=…, position=…, force_build=…, direction=…} → array of LuaEntity",
        "returns": "array of LuaEntity",
        "args": {
          "surface": {
            "doc": "Table with the following fields:  * surface :: SurfaceSpecification: Surface to build on\n * force :: string or LuaForce: Force to use for the building\n * position :: Position: The position to build at\n * force_build :: boolean (optional): When true, anything that can be built is else nothing is built if any one thing can't be built\n * direction :: defines.direction (optional): The direction to use when building",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "force_build=…": {
            "name": "force_build=…",
            "type": "force_build=…"
          },
          "direction=…": {
            "name": "direction=…",
            "type": "direction=…"
          }
        },
        "doc": "Build this blueprint\nParameters\n\n Table with the following fields:  * surface :: SurfaceSpecification: Surface to build on\n * force :: string or LuaForce: Force to use for the building\n * position :: Position: The position to build at\n * force_build :: boolean (optional): When true, anything that can be built is else nothing is built if any one thing can't be built\n * direction :: defines.direction (optional): The direction to use when building",
        "type": "function"
      },
      "create_blueprint": {
        "name": "create_blueprint{surface=…, force=…, area=…, always_include_tiles=…}",
        "args": {
          "surface": {
            "doc": "Table with the following fields:  * surface :: SurfaceSpecification: Surface to create from\n * force :: string or LuaForce: Force to use for the creation\n * area :: BoundingBox: The bounding box\n * always_include_tiles :: boolean (optional): When true, blueprintable tiles are always included in the blueprint. When false they're only included if no entities exist in the setup area.",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "surface=…": {
            "name": "surface=…",
            "type": "surface=…"
          },
          "force=…": {
            "name": "force=…",
            "type": "force=…"
          },
          "area=…": {
            "name": "area=…",
            "type": "area=…"
          },
          "always_include_tiles=…": {
            "name": "always_include_tiles=…",
            "type": "always_include_tiles=…"
          }
        },
        "doc": "Sets up this blueprint using the found blueprintable entities/tiles on the surface.\nParameters\n\n Table with the following fields:  * surface :: SurfaceSpecification: Surface to create from\n * force :: string or LuaForce: Force to use for the creation\n * area :: BoundingBox: The bounding box\n * always_include_tiles :: boolean (optional): When true, blueprintable tiles are always included in the blueprint. When false they're only included if no entities exist in the setup area.",
        "type": "function"
      },
      "get_tag": {
        "name": "get_tag(tag_name) → Any",
        "returns": "Any",
        "args": {
          "tag_name": {
            "doc": "tag_name :: string",
            "name": "tag_name",
            "type": "string"
          }
        },
        "doc": "Gets the tag with the given name or returns nil if it doesn't exist. \nParameters\n\ntag_name :: stringCan only be used if this is ItemWithTags",
        "type": "function"
      },
      "set_tag": {
        "name": "set_tag(tag_name, tag) → Any",
        "returns": "Any",
        "args": {
          "tag_name": {
            "doc": "tag_name :: string",
            "name": "tag_name",
            "type": "string"
          },
          "tag": {
            "doc": "tag :: Any",
            "name": "tag",
            "type": "Any"
          }
        },
        "doc": "Sets the tag with the given name and value. \nParameters\n\ntag_name :: stringtag :: AnyCan only be used if this is ItemWithTags",
        "type": "function"
      },
      "remove_tag": {
        "name": "remove_tag() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Removes a tag with the given name. \nReturn value If the tag existed and was removed.Can only be used if this is ItemWithTags",
        "type": "function"
      },
      "clear_blueprint": {
        "name": "clear_blueprint()",
        "args": {},
        "doc": "Clears this blueprint item. \nCan only be used if this is BlueprintItem",
        "type": "function"
      },
      "get_entity_filter": {
        "name": "get_entity_filter(index) → string",
        "returns": "string",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the entity filter at the given index for this deconstruction item. \nParameters\n\nindex :: uintCan only be used if this is DeconstructionItem",
        "type": "function"
      },
      "set_entity_filter": {
        "name": "set_entity_filter(index, filter, DeconstructionItem) → boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          },
          "filter": {
            "doc": "filter :: string or LuaEntityPrototype or LuaEntity: Setting to nil erases the filter.",
            "name": "filter",
            "type": "string or LuaEntityPrototype or LuaEntity"
          },
          "DeconstructionItem": {
            "name": "DeconstructionItem",
            "type": "DeconstructionItem"
          }
        },
        "doc": "Sets the entity filter ata the given index for this deconstruction item. \nParameters\n\nindex :: uintfilter :: string or LuaEntityPrototype or LuaEntity: Setting to nil erases the filter.Return value If the new filter was set (was valid.)",
        "type": "function"
      },
      "get_tile_filter": {
        "name": "get_tile_filter(index) → string",
        "returns": "string",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the tile filter at the given index for this deconstruction item. \nParameters\n\nindex :: uintCan only be used if this is DeconstructionItem",
        "type": "function"
      },
      "set_tile_filter": {
        "name": "set_tile_filter(index, filter, DeconstructionItem) → boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          },
          "filter": {
            "doc": "filter :: string or LuaTilePrototype or LuaTile: Setting to nil erases the filter.",
            "name": "filter",
            "type": "string or LuaTilePrototype or LuaTile"
          },
          "DeconstructionItem": {
            "name": "DeconstructionItem",
            "type": "DeconstructionItem"
          }
        },
        "doc": "Sets the tile filter ata the given index for this deconstruction item. \nParameters\n\nindex :: uintfilter :: string or LuaTilePrototype or LuaTile: Setting to nil erases the filter.Return value If the new filter was set (was valid.)",
        "type": "function"
      },
      "clear_deconstruction_item": {
        "name": "clear_deconstruction_item()",
        "args": {},
        "doc": "Clears all settings/filters on this deconstruction item resetting it to default values. \nCan only be used if this is DeconstructionItem",
        "type": "function"
      },
      "valid_for_read": {
        "name": "valid_for_read",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this valid for reading? Differs from the usual valid in that valid will be true even if the item stack is blank but the entity that holds it is still valid."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Prototype of the item held in this stack."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Prototype name of the item held in this stack."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of the item prototype."
      },
      "count": {
        "name": "count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of items in this stack."
      },
      "grid": {
        "name": "grid",
        "type": "LuaEquipmentGrid",
        "mode": "[Read-only]",
        "doc": "The equipment grid of this item or nil if this item doesn't have a grid."
      },
      "health": {
        "name": "health",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "How much health the item has, as a number in range [0, 1]."
      },
      "durability": {
        "name": "durability",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Durability of the contained item. Automatically capped at the item's maximum durability. \n\n\nNote: When used on a non-tool item, the value of this attribute is nil."
      },
      "ammo": {
        "name": "ammo",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of bullets left in the magazine. \nCan only be used if this is AmmoItem"
      },
      "blueprint_icons": {
        "name": "blueprint_icons",
        "type": "array of Icon",
        "mode": "[Read-Write]",
        "doc": "Icons of a blueprint item. Every entry of this array has the following fields: \n * signal :: SignalID: Slot icon to use. The slot will have the icon of the specified signal. This allows the use of any item icon, as well as virtual signal icons.\n * index :: uint: Index of the icon in the blueprint icons slots. Has to be in {1, 2, 3, 4}.\nCan only be used if this is BlueprintItem"
      },
      "label": {
        "name": "label",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The current label for this item. Nil when none. \nCan only be used if this is ItemWithLabel"
      },
      "label_color": {
        "name": "label_color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The current label color for this item. Nil when none. \nCan only be used if this is ItemWithLabel"
      },
      "allow_manual_label_change": {
        "name": "allow_manual_label_change",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If the label for this item can be manually changed. When false the label can only be changed through the API. \nCan only be used if this is ItemWithLabel"
      },
      "cost_to_build": {
        "name": "cost_to_build",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "Raw materials required to build this blueprint. Result is a dictionary mapping each item prototype name to the required count.\nCan only be used if this is BlueprintItem"
      },
      "extends_inventory": {
        "name": "extends_inventory",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this item extends the inventory it resides in (provides its contents for counts, crafting, insertion). Only callable on items with inventories. \nCan only be used if this is ItemWithInventory"
      },
      "prioritize_insertion_mode": {
        "name": "prioritize_insertion_mode",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The insertion mode priority this ItemWithInventory uses when items are inserted into an inventory it resides in. Only callable on items with inventories. \nCan only be used if this is ItemWithInventory"
      },
      "default_icons": {
        "name": "default_icons",
        "type": "array of Icon",
        "mode": "[Read-only]",
        "doc": "The default icons for a blueprint item. Every entry of this array has the following fields: \n * name :: string: Prototype name of the item whose icon to use\n * index :: uint: Index of the icon in the blueprint icons slots. Has to be in {1, 2, 3, 4}.\nCan only be used if this is BlueprintItem"
      },
      "tags": {
        "name": "tags",
        "type": "dictionary string → Any",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is ItemWithTags"
      },
      "custom_description": {
        "name": "custom_description",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The custom description this item-with-tags. This is shown over the normal item description if this is set to a non-empty value."
      },
      "entity_filters": {
        "name": "entity_filters",
        "type": "array of string",
        "mode": "[Read-Write]",
        "doc": "The entity filters for this deconstruction item."
      },
      "tile_filters": {
        "name": "tile_filters",
        "type": "array of string",
        "mode": "[Read-Write]",
        "doc": "The tile filters for this deconstruction item."
      },
      "entity_filter_mode": {
        "name": "entity_filter_mode",
        "type": "defines.deconstruction_item.entity_filter_mode",
        "mode": "[Read-Write]",
        "doc": "The blacklist/whitelist entity filter mode for this deconstruction item. \nCan only be used if this is DeconstructionItem"
      },
      "tile_filter_mode": {
        "name": "tile_filter_mode",
        "type": "defines.deconstruction_item.tile_filter_mode",
        "mode": "[Read-Write]",
        "doc": "The blacklist/whitelist tile filter mode for this deconstruction item. \nCan only be used if this is DeconstructionItem"
      },
      "tile_selection_mode": {
        "name": "tile_selection_mode",
        "type": "defines.deconstruction_item.tile_filter_mode",
        "mode": "[Read-Write]",
        "doc": "The tile selection mode for this deconstruction item. \nCan only be used if this is DeconstructionItem"
      },
      "trees_only": {
        "name": "trees_only",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this deconstruction item is set to allow trees only. \nCan only be used if this is DeconstructionItem"
      },
      "entity_filter_count": {
        "name": "entity_filter_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of entity filters this deconstruction item supports. \nCan only be used if this is DeconstructionItem"
      },
      "tile_filter_count": {
        "name": "tile_filter_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of tile filters this deconstruction item supports. \nCan only be used if this is DeconstructionItem"
      },
      "active_index": {
        "name": "active_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The active blueprint index for this blueprint book. \nCan only be used if this is BlueprintBookItem"
      }
    }
  },
  "LuaItemPrototype": {
    "name": "LuaItemPrototype",
    "type": "LuaItemPrototype",
    "doc": "Prototype of an item.",
    "properties": {
      "has_flag": {
        "name": "has_flag(flag) → boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "doc": "flag :: string: The flag to check. Can be either \"goes-to-main-inventory\", \"goes-to-quickbar\" or \"hidden\". Any other value will cause an error.",
            "name": "flag",
            "type": "string"
          }
        },
        "doc": "Does this prototype have a flag enabled? \nParameters\n\nflag :: string: The flag to check. Can be either \"goes-to-main-inventory\", \"goes-to-quickbar\" or \"hidden\". Any other value will cause an error.",
        "type": "function"
      },
      "get_ammo_type": {
        "name": "get_ammo_type(ammo_source_type)",
        "args": {
          "ammo_source_type": {
            "doc": "ammo_source_type :: string (optional): \"default\", \"player\", \"turret\", or \"vehicle\"",
            "name": "ammo_source_type",
            "type": "string"
          }
        },
        "doc": "Type of this ammo prototype or nil if this is not an ammo prototype. \nParameters\n\nammo_source_type :: string (optional): \"default\", \"player\", \"turret\", or \"vehicle\"",
        "type": "function"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this prototype. E.g. \"gun\" or \"mining-tool\"."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string."
      },
      "place_result": {
        "name": "place_result",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "Prototype of the entity that will be created by placing this item, or nil if there is no such entity."
      },
      "place_as_equipment_result": {
        "name": "place_as_equipment_result",
        "type": "LuaEquipmentPrototype",
        "mode": "[Read-only]",
        "doc": "Prototype of the equipment that will be created by placing this item in an equipment grid or nil if there is no equipment defined."
      },
      "place_as_tile_result": {
        "name": "place_as_tile_result",
        "mode": "[Read-only]",
        "doc": "The place as tile result if one is defined else nil.",
        "type": "place_as_tile_result"
      },
      "stackable": {
        "name": "stackable",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this item allowed to stack at all?"
      },
      "default_request_amount": {
        "name": "default_request_amount",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The default request value."
      },
      "stack_size": {
        "name": "stack_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Maximum stack size of the item specified by this prototype."
      },
      "fuel_category": {
        "name": "fuel_category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The fuel category or nil."
      },
      "burnt_result": {
        "name": "burnt_result",
        "type": "LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "The result of burning this item as fuel or nil."
      },
      "fuel_value": {
        "name": "fuel_value",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Fuel value when burned."
      },
      "fuel_acceleration_multiplier": {
        "name": "fuel_acceleration_multiplier",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The acceleration multiplier when this item is used as fuel in a vehicle."
      },
      "fuel_top_speed_multiplier": {
        "name": "fuel_top_speed_multiplier",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The fuel top speed multiplier when this item is used as fuel in a vehicle."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "The subgroup this prototype belongs to."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "The group this prototype belongs to."
      },
      "flags": {
        "name": "flags",
        "type": "dictionary string → boolean",
        "mode": "[Read-only]",
        "doc": "The item prototype flags for this item prototype. It is a dictionary where the keys are the set flags and the value is always true -- if a flag is unset, it isn't present in the dictionary at all.\n The possible flags are: \n *  \"goes-to-main-inventory\": If true, the item will prefer to go to the player's main inventory\n *  \"goes-to-quickbar\": If true, the item will prefer to go to the player's quickbar.\n *  \"hidden\": If true, the item will be hidden from all crafting menus."
      },
      "magazine_size": {
        "name": "magazine_size",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Size of full magazine; nil if this is not an ammo item."
      },
      "equipment_grid": {
        "name": "equipment_grid",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[Read-only]",
        "doc": "The prototype of this armor equipment grid or nil if none or this is not an armor item."
      },
      "resistances": {
        "name": "resistances",
        "type": "Resistances",
        "mode": "[Read-only]",
        "doc": "Resistances of this armour item; nil if not an armor or or the armor has no resistances."
      },
      "inventory_size_bonus": {
        "name": "inventory_size_bonus",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The invntory size bonus for this armor prototype. nil if this isn't an armor prototype. \nCan only be used if this is ArmorPrototype"
      },
      "capsule_action": {
        "name": "capsule_action",
        "type": "CapsuleAction",
        "mode": "[Read-only]",
        "doc": "The capsule action for this capsule item prototype or nil if this isn't a capsule item prototype."
      },
      "attack_parameters": {
        "name": "attack_parameters",
        "type": "AttackParameters",
        "mode": "[Read-only]",
        "doc": "The gun attack parameters or nil if not a gun item prototype."
      },
      "inventory_size": {
        "name": "inventory_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The main inventory size for item-with-inventory-prototype. nil if not an item-with-inventory-prototype. \nCan only be used if this is ItemWithInventoryPrototype"
      },
      "item_filters": {
        "name": "item_filters",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemWithInventory"
      },
      "group_filters": {
        "name": "group_filters",
        "type": "dictionary string → LuaGroup",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemWithInventory"
      },
      "sub_group_filters": {
        "name": "sub_group_filters",
        "type": "dictionary string → LuaGroup",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemWithInventory"
      },
      "filter_mode": {
        "name": "filter_mode",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The filter mode used by this item with inventory. \nCan only be used if this is ItemWithInventory"
      },
      "insertion_priority_mode": {
        "name": "insertion_priority_mode",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The insertion priority mode used by this item with inventory. \nCan only be used if this is ItemWithInventory"
      },
      "localised_filter_message": {
        "name": "localised_filter_message",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "The localised string used when the player attempts to put items into this item with inventory that aren't allowed. \nCan only be used if this is ItemWithInventory"
      },
      "extend_inventory_by_default": {
        "name": "extend_inventory_by_default",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If this item with inventory extends the inventory it resides in by default. \nCan only be used if this is ItemWithInventory"
      },
      "default_label_color": {
        "name": "default_label_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The default label color used for this item with label. nil if not defined or if this isn't an item with label. \nCan only be used if this is ItemWithLabel"
      },
      "draw_label_for_cursor_render": {
        "name": "draw_label_for_cursor_render",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If true, and this item with label has a label it is drawn in place of the normal number when held in the cursor. \nCan only be used if this is ItemWithLabel"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Mining or repairing speed if this is a mining or repairing tool; otherwise nil."
      },
      "attack_result": {
        "name": "attack_result",
        "type": "array of TriggerItem",
        "mode": "[Read-only]",
        "doc": "The attack result of this mining tool prototype. \nCan only be used if this is MiningTool"
      },
      "attack_range": {
        "name": "attack_range",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The attack range of this mining tool or nil if not a mining tool. \nCan only be used if this is Miningtool"
      },
      "module_effects": {
        "name": "module_effects",
        "type": "dictionary string → EffectValue",
        "mode": "[Read-only]",
        "doc": "Effects of this module; nil if this is not a module. It is a dictionary indexed by the effect type. \nExampleThese are the effects of the vanilla Productivity Module 3 (up to floating point impresicions): {consumption={bonus=0.6},\nspeed={bonus=-0.15},\nproductivity={bonus=0.06},\npollution={bonus=0.075}} Can only be used if this is ModuleItem"
      },
      "category": {
        "name": "category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The module category name \nCan only be used if this is ModuleItem"
      },
      "tier": {
        "name": "tier",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The module tier \nCan only be used if this is ModuleItem"
      },
      "limitations": {
        "name": "limitations",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "An array of recipe names this module is allowed to work with. \nCan only be used if this is ModuleItem"
      },
      "limitation_message_key": {
        "name": "limitation_message_key",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The limitation message key used when the player attempts to use this modules in some place it's not allowed. \nCan only be used if this is ModuleItem"
      },
      "straight_rail": {
        "name": "straight_rail",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The straight rail prototype used for this rail planner prototype. \nCan only be used if this is RailPlanner"
      },
      "curved_rail": {
        "name": "curved_rail",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The curved rail prototype used for this rail planner prototype. \nCan only be used if this is RailPlanner"
      },
      "repair_result": {
        "name": "repair_result",
        "type": "array of TriggerItem",
        "mode": "[Read-only]",
        "doc": "The repair result of this repair tool prototype or nil if this isn't a repair tool prototype. \nCan only be used if this is RepairTool"
      },
      "selection_border_color": {
        "name": "selection_border_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The color used when doing normal selection with this selection tool prototype. \nCan only be used if this is SelectionTool"
      },
      "alt_selection_border_color": {
        "name": "alt_selection_border_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The color used when doing alt selection with this selection tool prototype. \nCan only be used if this is SelectionTool"
      },
      "selection_mode_flags": {
        "name": "selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[Read-only]",
        "doc": "Flags that affect which entities will be selected.\nCan only be used if this is SelectionTool"
      },
      "alt_selection_mode_flags": {
        "name": "alt_selection_mode_flags",
        "type": "SelectionModeFlags",
        "mode": "[Read-only]",
        "doc": "Flags that affect which entities will be selected during alternate selection.\nCan only be used if this is SelectionTool"
      },
      "selection_cursor_box_type": {
        "name": "selection_cursor_box_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is SelectionTool"
      },
      "alt_selection_cursor_box_type": {
        "name": "alt_selection_cursor_box_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is SelectionTool"
      },
      "always_include_tiles": {
        "name": "always_include_tiles",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "If tiles area always included when doing selection with this selection tool prototype. \nCan only be used if this is SelectionTool"
      },
      "entity_filter_slots": {
        "name": "entity_filter_slots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of entity filters this deconstruction item has or nil if this isn't a deconstruction item prototype. \nCan only be used if this is DeconstructionItem"
      },
      "tile_filter_slots": {
        "name": "tile_filter_slots",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of tile filters this deconstruction item has or nil if this isn't a deconstruction item prototype. \nCan only be used if this is DeconstructionItem"
      },
      "durability_description_key": {
        "name": "durability_description_key",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The durability message key used when displaying the durability of this tool. \nCan only be used if this is ToolItem"
      },
      "durability": {
        "name": "durability",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The durability of this tool item or nil if not a tool item."
      }
    }
  },
  "LuaInventory": {
    "name": "LuaInventory",
    "type": "LuaInventory",
    "doc": "A storage of item stacks.",
    "properties": {
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Make this inventory empty.",
        "type": "function"
      },
      "can_insert": {
        "name": "can_insert(items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items that would be inserted.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Can at least some items be inserted?\nParameters\n\nitems :: SimpleItemStack: Items that would be inserted.Return value true if at least a part of the given items could be inserted into this inventory.",
        "type": "function"
      },
      "insert": {
        "name": "insert(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to insert.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items into this inventory.\nParameters\n\nitems :: SimpleItemStack: Items to insert.Return value Number of items actually inserted.",
        "type": "function"
      },
      "remove": {
        "name": "remove(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to remove.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove items from this inventory.\nParameters\n\nitems :: SimpleItemStack: Items to remove.Return value Number of items actually removed.",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Prototype name of the item to count. If not specified, count all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Get the number of all or some items in this inventory.\nParameters\n\nitem :: string (optional): Prototype name of the item to count. If not specified, count all items.",
        "type": "function"
      },
      "is_empty": {
        "name": "is_empty() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Does this inventory contain nothing?",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get counts of all items in this inventory.\nReturn value The counts, indexed by item names.",
        "type": "function"
      },
      "hasbar": {
        "name": "hasbar() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Does this inventory have a bar? Bar is the draggable red thing, found for example on chests, that limits the portion of the inventory that may be manipulated by machines.\n\n\nNote: \"Having a bar\" doesn't mean that the bar is set to some nontrivial value. Having a bar means the inventory supports having this limit at all. The character's inventory is an example of an inventory without a bar; the wooden chest's inventory is an example of one with a bar.",
        "type": "function"
      },
      "getbar": {
        "name": "getbar() → uint",
        "returns": "uint",
        "args": {},
        "doc": "Get the current bar. This is the index at which the red area starts.\n\n\nNote: Only useable if this inventory has a bar.",
        "type": "function"
      },
      "setbar": {
        "name": "setbar(bar)",
        "args": {
          "bar": {
            "doc": "bar :: uint (optional): The new limit. Ommitting this parameter will clear the limit.",
            "name": "bar",
            "type": "uint"
          }
        },
        "doc": "Set the current bar.\nParameters\n\nbar :: uint (optional): The new limit. Ommitting this parameter will clear the limit.\n\nNote: Only useable if this inventory has a bar.",
        "type": "function"
      },
      "supports_filters": {
        "name": "supports_filters() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "If this inventory supports filters.",
        "type": "function"
      },
      "is_filtered": {
        "name": "is_filtered() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "If this inventory supports filters and has at least 1 filter set.",
        "type": "function"
      },
      "can_set_filter": {
        "name": "can_set_filter(index, filter) → boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "doc": "index :: uint: The item stack index",
            "name": "index",
            "type": "uint"
          },
          "filter": {
            "doc": "filter :: string: The item name of the filter",
            "name": "filter",
            "type": "string"
          }
        },
        "doc": "If the given inventory slot filter can be set to the given filter.\nParameters\n\nindex :: uint: The item stack indexfilter :: string: The item name of the filter",
        "type": "function"
      },
      "get_filter": {
        "name": "get_filter(index) → string",
        "returns": "string",
        "args": {
          "index": {
            "doc": "index :: uint: The item stack index",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the filter for the given item stack index.\nParameters\n\nindex :: uint: The item stack indexReturn value The current filter or nil if none.",
        "type": "function"
      },
      "set_filter": {
        "name": "set_filter(index, filter) → boolean",
        "returns": "boolean",
        "args": {
          "index": {
            "doc": "index :: uint: The item stack index",
            "name": "index",
            "type": "uint"
          },
          "filter": {
            "doc": "filter :: string: The new filter or nil to erase the filter",
            "name": "filter",
            "type": "string"
          }
        },
        "doc": "Sets the filter for the given item stack index.\nParameters\n\nindex :: uint: The item stack indexfilter :: string: The new filter or nil to erase the filterReturn value If the filter was allowed to be set.\n\nNote: Some inventory slots don't allow some filters (gun ammo can't be filtered for non-ammo).",
        "type": "function"
      },
      "find_item_stack": {
        "name": "find_item_stack(item) → LuaItemStack",
        "returns": "LuaItemStack",
        "args": {
          "item": {
            "doc": "item :: string: The item name to find",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Gets the first LuaItemStack in the inventory that matches the given item name. \nParameters\n\nitem :: string: The item name to findReturn value or nil.",
        "type": "function"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Get the number of slots in this inventory.\nExampleWill print the number of slots in the player's main inventory. game.player.print(#game.player.get_inventory(defines.inventory.player_main))"
      },
      "index": {
        "name": "index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The inventory index this inventory uses."
      },
      "entity_owner": {
        "name": "entity_owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity that owns this inventory or nil if this isn't owned by an entity."
      },
      "player_owner": {
        "name": "player_owner",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player that owns this inventory or nil if this isn't owned by a player."
      },
      "equipment_owner": {
        "name": "equipment_owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The equipment that owns this inventory or nil if this isn't owned by an equipment."
      },
      "operator []": {
        "name": "operator []",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The indexing operator.\nExampleWill get the first item in the player's quickbar. game.player.get_inventory(defines.inventory.player_quickbar)[1]"
      }
    }
  },
  "LuaGuiElement": {
    "name": "LuaGuiElement",
    "type": "LuaGuiElement",
    "doc": "An element of the custom GUI. This type is used to represent any kind of a GUI element -- labels as well\n as buttons as well as frames are all instances of this type. Just like LuaEntity, different kinds\n of elements support different attributes; attempting to access an attribute on an element that doesn't support\n it (for instance, trying to access the value of a text field) will result in a run-time error.",
    "properties": {
      "add": {
        "name": "add{type=…, name=…, style=…} → LuaGuiElement",
        "returns": "LuaGuiElement",
        "args": {
          "type": {
            "doc": "Table with the following fields:  * type :: string: The kind of the element to add. Has to be one of \"button\", \"sprite-button\", \"checkbox\", \"flow\", \"frame\", \"label\", \"table\", \"progressbar\", \"textfield\", \"radio-button\", \"sprite\", \"scroll-pane\", \"camera\", or \"drop-down\".\n * name :: string: Name of the child element.\n * style :: string (optional): Style of the new element.\n *  Other attributes may have to be specified, depending on type * sprite-button * sprite :: SpritePath (optional): Path to the image to display on the button.\n      \n      \n    * checkbox * state :: boolean: Whether the checkbox should be checked by default.\n      \n      \n    * radio-button * state :: boolean: Whether the radio-button should be checked by default.\n      \n      \n    * frame * direction :: string: The initial direction of the frame's layout. See LuaGuiElement::direction.\n      \n      \n    * label * caption :: string (optional): Initial text to display on the label.\n       * single_line :: boolean (optional): If text should be shown on a single line or wrapped based off the max width of the label.\n       * want_ellipsis :: boolean (optional): If text beyond the widget width should be shown as \"...\" instead of clipped. Can't be used with single_line==false\n      \n      \n    * progressbar * size :: uint: Width of the progressbar.\n       * value :: double (optional): Initial value of the progressbar, in range [0, 1]. Defaults to 0 if not given.\n      \n      \n    * table * colspan :: uint: Number of columns\n      \n      \n    * drop-down * items :: array of LocalisedString (optional): The initial items in the dropdown.\n       * selected_index :: uint (optional): The initial selected index.\n      \n      \n    * camera * position :: Position: The position the camera centers on.\n       * surface_index :: uint (optional): The surface the camera will render else if not given the players surface is used.\n       * zoom :: double (optional): The camera zoom - defaults to 0.75.\n      \n      \n    * choose-elem-button * elem_type :: string: \"item\", \"tile\", \"entity\", or \"signal\"\n       * item :: string (optional): If type is \"item\" - the default value for the button\n       * entity :: string (optional): If type is \"entity\" - the default value for the button\n       * tile :: string (optional): If type is \"tile\" - the default value for the button\n       * signal :: SignalID (optional): If type is \"signal\" - the default value for the button",
            "name": "type",
            "type": "string"
          },
          "type=…": {
            "name": "type=…",
            "type": "type=…"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "style=…": {
            "name": "style=…",
            "type": "style=…"
          }
        },
        "doc": "Add a child element.\nParameters\n\n Table with the following fields:  * type :: string: The kind of the element to add. Has to be one of \"button\", \"sprite-button\", \"checkbox\", \"flow\", \"frame\", \"label\", \"table\", \"progressbar\", \"textfield\", \"radio-button\", \"sprite\", \"scroll-pane\", \"camera\", or \"drop-down\".\n * name :: string: Name of the child element.\n * style :: string (optional): Style of the new element.\n *  Other attributes may have to be specified, depending on type * sprite-button * sprite :: SpritePath (optional): Path to the image to display on the button.\n    * checkbox * state :: boolean: Whether the checkbox should be checked by default.\n    * radio-button * state :: boolean: Whether the radio-button should be checked by default.\n    * frame * direction :: string: The initial direction of the frame's layout. See LuaGuiElement::direction.\n    * label * caption :: string (optional): Initial text to display on the label.\n       * single_line :: boolean (optional): If text should be shown on a single line or wrapped based off the max width of the label.\n       * want_ellipsis :: boolean (optional): If text beyond the widget width should be shown as \"...\" instead of clipped. Can't be used with single_line==false\n    * progressbar * size :: uint: Width of the progressbar.\n       * value :: double (optional): Initial value of the progressbar, in range [0, 1]. Defaults to 0 if not given.\n    * table * colspan :: uint: Number of columns\n    * drop-down * items :: array of LocalisedString (optional): The initial items in the dropdown.\n       * selected_index :: uint (optional): The initial selected index.\n    * camera * position :: Position: The position the camera centers on.\n       * surface_index :: uint (optional): The surface the camera will render else if not given the players surface is used.\n       * zoom :: double (optional): The camera zoom - defaults to 0.75.\n    * choose-elem-button * elem_type :: string: \"item\", \"tile\", \"entity\", or \"signal\"\n       * item :: string (optional): If type is \"item\" - the default value for the button\n       * entity :: string (optional): If type is \"entity\" - the default value for the button\n       * tile :: string (optional): If type is \"tile\" - the default value for the button\n       * signal :: SignalID (optional): If type is \"signal\" - the default value for the button\nReturn value The added GUI element.",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Remove children of this element. Any LuaGuiElement objects referring to the destroyed elements become invalid after this operation.\nExample game.player.gui.top.clear()",
        "type": "function"
      },
      "destroy": {
        "name": "destroy()",
        "args": {},
        "doc": "Remove this element, along with its children. Any LuaGuiElement objects referring to the destroyed elements become invalid after this operation.\n\n\nNote: The top-level GUI elements -- LuaGui::top, LuaGui::left, LuaGui::center -- can't be destroyed.Example game.player.gui.top.greeting.destroy()",
        "type": "function"
      },
      "clear_items": {
        "name": "clear_items()",
        "args": {},
        "doc": "Clears the items in this dropdown. \nCan only be used if this is drop-down",
        "type": "function"
      },
      "get_item": {
        "name": "get_item(index) → LocalisedString",
        "returns": "LocalisedString",
        "args": {
          "index": {
            "doc": "index :: uint: The index to get.",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets an item at the given index from this dropdown. \nParameters\n\nindex :: uint: The index to get.Can only be used if this is drop-down",
        "type": "function"
      },
      "set_item": {
        "name": "set_item(index, LocalisedString)",
        "args": {
          "index": {
            "doc": "index :: uint: The index",
            "name": "index",
            "type": "uint"
          },
          "LocalisedString": {
            "doc": "LocalisedString: The item.",
            "name": "LocalisedString"
          }
        },
        "doc": "Sets an item at the given index in this dropdown. \nParameters\n\nindex :: uint: The indexLocalisedString: The item.Can only be used if this is drop-down",
        "type": "function"
      },
      "add_item": {
        "name": "add_item(LocalisedString, index)",
        "args": {
          "LocalisedString": {
            "doc": "LocalisedString: The item.",
            "name": "LocalisedString"
          },
          "index": {
            "doc": "index :: uint (optional): The index",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Adds an item at the end or at the given index in this dropdown. \nParameters\n\nLocalisedString: The item.index :: uint (optional): The indexCan only be used if this is drop-down",
        "type": "function"
      },
      "gui": {
        "name": "gui",
        "type": "LuaGui",
        "mode": "[Read-only]",
        "doc": "The GUI this element is a part of."
      },
      "parent": {
        "name": "parent",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The direct parent of this element; nil if this is a top-level element."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The name of this element.\nExample game.player.gui.top.greeting.name == \"greeting\""
      },
      "caption": {
        "name": "caption",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The text displayed on the element. For frames, this is the \"heading\". For other elements, like buttons or labels, this is the content.\n\n\nNote: Whilst this attribute may be used on all elements without producing an error, it doesn't make sense for tables and flows as they won't display it."
      },
      "value": {
        "name": "value",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "How much this progress bar is filled. It is a value in range [0, 1].\nCan only be used if this is progressbar"
      },
      "direction": {
        "name": "direction",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "Direction of the layout. May be either \"horizontal\" or \"vertical\".\nCan only be used if this is frame"
      },
      "style": {
        "name": "style",
        "type": "LuaStyle or string",
        "mode": "[Read-Write]",
        "doc": "The style of this element. When read, this evaluates to a LuaStyle. For writing, it only accepts a string that specifies the textual identifier of the desired style."
      },
      "text": {
        "name": "text",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The text contained in a textfield.\nCan only be used if this is textfield"
      },
      "children_names": {
        "name": "children_names",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "Names of all the children of this element. These are the identifiers that can be used to access the child as an attribute of this element."
      },
      "state": {
        "name": "state",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Is this checkbox checked?\nCan only be used if this is checkbox"
      },
      "player_index": {
        "name": "player_index",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Index into LuaGameScript::players specifying the player who owns this element."
      },
      "sprite": {
        "name": "sprite",
        "type": "SpritePath",
        "mode": "[Read-Write]",
        "doc": "Path the the image to display on this sprite-button. \nCan only be used if this is sprite-button"
      },
      "tooltip": {
        "name": "tooltip",
        "type": "LocalisedString",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "vertical_scroll_policy": {
        "name": "vertical_scroll_policy",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "Allowed values are: \"always\", \"never\", or \"auto\" \nCan only be used if this is scroll-pane"
      },
      "horizontal_scroll_policy": {
        "name": "horizontal_scroll_policy",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "Allowed values are: \"always\", \"never\", or \"auto\" \nCan only be used if this is scroll-pane"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The type of this GUI element."
      },
      "children": {
        "name": "children",
        "type": "array of LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The children elements"
      },
      "items": {
        "name": "items",
        "type": "array of LocalisedString",
        "mode": "[Read-Write]",
        "doc": "The items in this dropdown. \nCan only be used if this is drop-down"
      },
      "selected_index": {
        "name": "selected_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The selected index for this dropdown. 0 if none."
      },
      "single_line": {
        "name": "single_line",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this label should render its contents on single line or multiple based off the max width of the label."
      },
      "want_ellipsis": {
        "name": "want_ellipsis",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If this label text should render text outside the label area as \"...\"."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-Write]",
        "doc": "The position this camera is focused on. \nCan only be used if this is camera"
      },
      "surface_index": {
        "name": "surface_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The surface index this camera is using. \nCan only be used if this is camera"
      },
      "zoom": {
        "name": "zoom",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The zoom this camera is using. \nCan only be used if this is camera"
      },
      "elem_type": {
        "name": "elem_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The elem type of this choose-elem-button. \nCan only be used if this is choose-elem-button"
      },
      "elem_value": {
        "name": "elem_value",
        "type": "string or SignalID",
        "mode": "[Read-Write]",
        "doc": "The elem value of this choose-elem-button or nil if there is no value. \n\n\nNote: Types \"item\", \"entity\", and \"tile\" operate with strings. Type \"signal\" operates with SignalID.Can only be used if this is choose-elem-button"
      }
    }
  },
  "LuaGui": {
    "name": "LuaGui",
    "type": "LuaGui",
    "doc": "The root of the GUI. This type houses the root elements, top, left, center and goal, to which\n other elements can be added to be displayed on screen.",
    "properties": {
      "is_valid_sprite_path": {
        "name": "is_valid_sprite_path(sprite_path) → boolean",
        "returns": "boolean",
        "args": {
          "sprite_path": {
            "doc": "sprite_path :: SpritePath: Path to a image.",
            "name": "sprite_path",
            "type": "SpritePath"
          }
        },
        "doc": "Returns true if sprite_path is valid and contains loaded sprite, otherwise false. \nParameters\n\nsprite_path :: SpritePath: Path to a image.",
        "type": "function"
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player who owns this gui."
      },
      "children": {
        "name": "children",
        "type": "dictionary string → LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The children GUI elements mapped by name <> element."
      },
      "top": {
        "name": "top",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The top part of the GUI. It is a flow element."
      },
      "left": {
        "name": "left",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The left part of the GUI. It is a flow element."
      },
      "center": {
        "name": "center",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The center part of the GUI. It is a flow element."
      },
      "goal": {
        "name": "goal",
        "type": "LuaGuiElement",
        "mode": "[Read-only]",
        "doc": "The flow used in the objectives window. It is a flow element. The objectives window is only visible when the flow is not empty or the objective text is set."
      }
    }
  },
  "LuaGroup": {
    "name": "LuaGroup",
    "type": "LuaGroup",
    "doc": "Item group or subgroup.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "The parent group if any; nil if none."
      },
      "subgroups": {
        "name": "subgroups",
        "type": "array of LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroups of this group.\n\n\nNote: Can only be used on groups, not on subgroups."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaGameScript": {
    "name": "LuaGameScript",
    "type": "LuaGameScript",
    "doc": "Main toplevel type, provides access to most of the API though its members. An instance\n of LuaGameScript is available as the global object named game.",
    "properties": {
      "help": {
        "name": "help()",
        "args": {},
        "doc": "Internal",
        "type": "function"
      },
      "set_game_state": {
        "name": "set_game_state{game_finished=…, player_won=…, next_level=…, can_continue=…}",
        "args": {
          "game_finished": {
            "doc": "Table with the following fields:  * game_finished :: boolean\n * player_won :: boolean\n * next_level :: string\n * can_continue :: boolean",
            "name": "game_finished",
            "type": "boolean"
          },
          "game_finished=…": {
            "name": "game_finished=…",
            "type": "game_finished=…"
          },
          "player_won=…": {
            "name": "player_won=…",
            "type": "player_won=…"
          },
          "next_level=…": {
            "name": "next_level=…",
            "type": "next_level=…"
          },
          "can_continue=…": {
            "name": "can_continue=…",
            "type": "can_continue=…"
          }
        },
        "doc": "Set scenario state. \nParameters\n\n Table with the following fields:  * game_finished :: boolean\n * player_won :: boolean\n * next_level :: string\n * can_continue :: boolean",
        "type": "function"
      },
      "get_entity_by_tag": {
        "name": "get_entity_by_tag(tag) → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "tag": {
            "doc": "tag :: string",
            "name": "tag",
            "type": "string"
          }
        },
        "doc": "Parameters\n\ntag :: string",
        "type": "function"
      },
      "show_message_dialog": {
        "name": "show_message_dialog{text=…, image=…, point_to=…}",
        "args": {
          "text": {
            "doc": "Table with the following fields:  * text :: LocalisedString: What the dialog should say\n * image :: string (optional): Path to an image to show on the dialog\n * point_to :: GuiArrowSpecification (optional): If specified, dialog will show an arrow pointing to this place. When not specified, the arrow will point to the player's position. (Use point_to={type=\"nowhere\"} to remove the arrow entirely.) The dialog itself will be placed near the arrow's target.",
            "name": "text",
            "type": "LocalisedString"
          },
          "text=…": {
            "name": "text=…",
            "type": "text=…"
          },
          "image=…": {
            "name": "image=…",
            "type": "image=…"
          },
          "point_to=…": {
            "name": "point_to=…",
            "type": "point_to=…"
          }
        },
        "doc": "Show an in-game message dialog. \nParameters\n\n Table with the following fields:  * text :: LocalisedString: What the dialog should say\n * image :: string (optional): Path to an image to show on the dialog\n * point_to :: GuiArrowSpecification (optional): If specified, dialog will show an arrow pointing to this place. When not specified, the arrow will point to the player's position. (Use point_to={type=\"nowhere\"} to remove the arrow entirely.) The dialog itself will be placed near the arrow's target.\n\n\nNote: Can only be used when the map contains exactly one player.",
        "type": "function"
      },
      "disable_tips_and_tricks": {
        "name": "disable_tips_and_tricks()",
        "args": {},
        "doc": "Disable showing tips and tricks.",
        "type": "function"
      },
      "is_demo": {
        "name": "is_demo() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Is this the demo version of Factorio?",
        "type": "function"
      },
      "reload_script": {
        "name": "reload_script()",
        "args": {},
        "doc": "Forces a reload of the scenario script when the save game without the migration is loaded. \n\n\nNote: Useable only in migration scripts.",
        "type": "function"
      },
      "save_atlas": {
        "name": "save_atlas()",
        "args": {},
        "doc": "Saves the current configuration of Atlas to a file. This will result in huge file containing all of the game graphics moved to as small space as possible.\n\n\nNote: Exists mainly for debugging reasons.",
        "type": "function"
      },
      "check_consistency": {
        "name": "check_consistency()",
        "args": {},
        "doc": "Run internal consistency checks. Allegedly prints any errors it finds.\n\n\nNote: Exists mainly for debugging reasons.",
        "type": "function"
      },
      "regenerate_entity": {
        "name": "regenerate_entity(entitites)",
        "args": {
          "entitites": {
            "doc": "entitites :: string or array of string: Prototype names of entity or entities to autoplace.",
            "name": "entitites",
            "type": "string or array of string"
          }
        },
        "doc": "Regenerate autoplacement of some entities on all surfaces. This can be used to autoplace newly-added entities.\nParameters\n\nentitites :: string or array of string: Prototype names of entity or entities to autoplace.\n\nNote: All specified entity prototypes must be autoplacable.",
        "type": "function"
      },
      "take_screenshot": {
        "name": "take_screenshot{player=…, by_player=…, position=…, resolution=…, zoom=…, path=…, show_gui=…, show_entity_info=…, anti_alias=…}",
        "args": {
          "player": {
            "doc": "Table with the following fields:  * player :: PlayerSpecification (optional)\n * by_player :: PlayerSpecification (optional): If defined, the screenshot will only be taken for this player.\n * position :: Position (optional)\n * resolution :: Position (optional): Maximum allowed resolution is 16384x16384 (resp. 8196x8196 when anti_alias is true), but maximum recommended resolution is 4096x4096 (resp. 2048x2048).\n * zoom :: double (optional)\n * path :: string (optional): Path to save the screenshot in\n * show_gui :: boolean (optional): Include game GUI in the screenshot?\n * show_entity_info :: boolean (optional): Include entity info (alt-mode)?\n * anti_alias :: boolean (optional): Render in double resolution and scale down (including GUI)?",
            "name": "player",
            "type": "PlayerSpecification"
          },
          "player=…": {
            "name": "player=…",
            "type": "player=…"
          },
          "by_player=…": {
            "name": "by_player=…",
            "type": "by_player=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "resolution=…": {
            "name": "resolution=…",
            "type": "resolution=…"
          },
          "zoom=…": {
            "name": "zoom=…",
            "type": "zoom=…"
          },
          "path=…": {
            "name": "path=…",
            "type": "path=…"
          },
          "show_gui=…": {
            "name": "show_gui=…",
            "type": "show_gui=…"
          },
          "show_entity_info=…": {
            "name": "show_entity_info=…",
            "type": "show_entity_info=…"
          },
          "anti_alias=…": {
            "name": "anti_alias=…",
            "type": "anti_alias=…"
          }
        },
        "doc": "Take a screenshot and save it to a file.\nParameters\n\n Table with the following fields:  * player :: PlayerSpecification (optional)\n * by_player :: PlayerSpecification (optional): If defined, the screenshot will only be taken for this player.\n * position :: Position (optional)\n * resolution :: Position (optional): Maximum allowed resolution is 16384x16384 (resp. 8196x8196 when anti_alias is true), but maximum recommended resolution is 4096x4096 (resp. 2048x2048).\n * zoom :: double (optional)\n * path :: string (optional): Path to save the screenshot in\n * show_gui :: boolean (optional): Include game GUI in the screenshot?\n * show_entity_info :: boolean (optional): Include entity info (alt-mode)?\n * anti_alias :: boolean (optional): Render in double resolution and scale down (including GUI)?\n\n\nNote: If Factorio is running headless, this function will do nothing.",
        "type": "function"
      },
      "write_file": {
        "name": "write_file(filename, data, append, for_player)",
        "args": {
          "filename": {
            "doc": "filename :: string: Path to the file to write to",
            "name": "filename",
            "type": "string"
          },
          "data": {
            "doc": "data :: string: File content",
            "name": "data",
            "type": "string"
          },
          "append": {
            "doc": "append :: boolean (optional): When true, this will append to the end of the file. Defaults to false,",
            "name": "append",
            "type": "boolean"
          },
          "for_player": {
            "doc": "for_player :: uint (optional): If given, the file will only be written for this player_index. 0 means only the server if one exists. which will overwrite any pre-existing file with the new data.",
            "name": "for_player",
            "type": "uint"
          }
        },
        "doc": "Write a string to a file.\nParameters\n\nfilename :: string: Path to the file to write todata :: string: File contentappend :: boolean (optional): When true, this will append to the end of the file. Defaults to false,for_player :: uint (optional): If given, the file will only be written for this player_index. 0 means only the server if one exists. which will overwrite any pre-existing file with the new data.",
        "type": "function"
      },
      "remove_path": {
        "name": "remove_path(path)",
        "args": {
          "path": {
            "doc": "path :: string: Path to remove, relative to the script output directory",
            "name": "path",
            "type": "string"
          }
        },
        "doc": "Remove file or directory. Given path is taken relative to the script output directory. Can be used to remove files created by LuaGameScript::write_file.\nParameters\n\npath :: string: Path to remove, relative to the script output directory",
        "type": "function"
      },
      "remove_offline_players": {
        "name": "remove_offline_players(players)",
        "args": {
          "players": {
            "doc": "players :: array of LuaPlayer or string (optional): List of players to remove. If not specified, remove all offline players.",
            "name": "players",
            "type": "array of LuaPlayer or string"
          }
        },
        "doc": "Remove players who are currently not connected from the map. \nParameters\n\nplayers :: array of LuaPlayer or string (optional): List of players to remove. If not specified, remove all offline players.",
        "type": "function"
      },
      "force_crc": {
        "name": "force_crc()",
        "args": {},
        "doc": "Force a CRC check. Tells all peers to calculate their current map CRC; these CRC are then compared against each other. If a mismatch is detected, the game is desynced and some peers are forced to reconnect.",
        "type": "function"
      },
      "create_force": {
        "name": "create_force(force) → LuaForce",
        "returns": "LuaForce",
        "args": {
          "force": {
            "doc": "force :: string: Name of the new force",
            "name": "force",
            "type": "string"
          }
        },
        "doc": "Create a new force.\nParameters\n\nforce :: string: Name of the new forceReturn value The force that was just created\n\nNote: The game currently supports a maximum of 64 forces, including the three built-in forces. This means that a maximum of 61 new forces may be created.\n\nNote: Force names must be unique.",
        "type": "function"
      },
      "merge_forces": {
        "name": "merge_forces(source, destination)",
        "args": {
          "source": {
            "doc": "source :: string or LuaForce: The force to remove",
            "name": "source",
            "type": "string or LuaForce"
          },
          "destination": {
            "doc": "destination :: string or LuaForce: The force to reassign all entities to",
            "name": "destination",
            "type": "string or LuaForce"
          }
        },
        "doc": "Merge two forces together. All entities in the source force will be reassigned to the target force. The source force will then be destroyed.\nParameters\n\nsource :: string or LuaForce: The force to removedestination :: string or LuaForce: The force to reassign all entities to\n\nNote: The three built-in forces -- player, enemy and neutral -- can't be destroyed. I.e. they can't be used as the source argument to this function.",
        "type": "function"
      },
      "create_surface": {
        "name": "create_surface(name, settings) → LuaSurface",
        "returns": "LuaSurface",
        "args": {
          "name": {
            "doc": "name :: string: Name of the new surface",
            "name": "name",
            "type": "string"
          },
          "settings": {
            "doc": "settings :: MapGenSettings (optional): Map generation settings",
            "name": "settings",
            "type": "MapGenSettings"
          }
        },
        "doc": "Create a new surface\nParameters\n\nname :: string: Name of the new surfacesettings :: MapGenSettings (optional): Map generation settingsReturn value The surface that was just created",
        "type": "function"
      },
      "server_save": {
        "name": "server_save(name)",
        "args": {
          "name": {
            "doc": "name :: string (optional): Save name. If not specified, writes into the currently-running save.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Instruct the server to save the map. \nParameters\n\nname :: string (optional): Save name. If not specified, writes into the currently-running save.",
        "type": "function"
      },
      "delete_surface": {
        "name": "delete_surface(surface)",
        "args": {
          "surface": {
            "doc": "surface :: string or LuaSurface: The surface to be deleted. Currently the primary surface (0, 'nauvis') cannot be deleted.",
            "name": "surface",
            "type": "string or LuaSurface"
          }
        },
        "doc": "Deletes the given surface and all entities on it. \nParameters\n\nsurface :: string or LuaSurface: The surface to be deleted. Currently the primary surface (0, 'nauvis') cannot be deleted.",
        "type": "function"
      },
      "disable_replay": {
        "name": "disable_replay()",
        "args": {},
        "doc": "Disables replay saving for the current save file. Once done there's no way to re-enable replay saving for the save file without loading an old save.",
        "type": "function"
      },
      "direction_to_string": {
        "name": "direction_to_string(direction)",
        "args": {
          "direction": {
            "doc": "direction :: defines.direction",
            "name": "direction",
            "type": "defines.direction"
          }
        },
        "doc": "Converts the given direction into the string version of the direction. \nParameters\n\ndirection :: defines.direction",
        "type": "function"
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console all players.\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "create_random_generator": {
        "name": "create_random_generator(seed) → LuaRandomGenerator",
        "returns": "LuaRandomGenerator",
        "args": {
          "seed": {
            "doc": "seed :: uint (optional)",
            "name": "seed",
            "type": "uint"
          }
        },
        "doc": "Creates a deterministic standalone random generator with the given seed or if a seed is not provided the initial map seed is used. \nParameters\n\nseed :: uint (optional)\n\nNote: *Make sure* you actually want to use this over math.random(...) as this provides entirely different functionality over math.random(...).",
        "type": "function"
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player typing at the console - nil in all other instances. See LuaGameScript::players for accessing all players."
      },
      "players": {
        "name": "players",
        "type": "custom dictionary uint or string → LuaPlayer",
        "mode": "[Read-only]",
        "doc": "\n\nNote: This is a sparse table so pairs(), a known player index, or player name should be used to access elements."
      },
      "map_settings": {
        "name": "map_settings",
        "type": "MapSettings",
        "mode": "[Read-only]",
        "doc": ""
      },
      "difficulty_settings": {
        "name": "difficulty_settings",
        "type": "DifficultySettings",
        "mode": "[Read-only]",
        "doc": "Although it can be done; because different difficulties can have different technology or recipe trees it's not recomended to change difficulty settings mid-game."
      },
      "difficulty": {
        "name": "difficulty",
        "type": "defines.difficulty",
        "mode": "[Read-only]",
        "doc": "Current scenario difficulty."
      },
      "forces": {
        "name": "forces",
        "type": "custom dictionary string → LuaForce",
        "mode": "[Read-only]",
        "doc": ""
      },
      "entity_prototypes": {
        "name": "entity_prototypes",
        "type": "custom dictionary string → LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "item_prototypes": {
        "name": "item_prototypes",
        "type": "custom dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "fluid_prototypes": {
        "name": "fluid_prototypes",
        "type": "custom dictionary string → LuaFluidPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "tile_prototypes": {
        "name": "tile_prototypes",
        "type": "custom dictionary string → LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "equipment_prototypes": {
        "name": "equipment_prototypes",
        "type": "custom dictionary string → LuaEquipmentPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "damage_prototypes": {
        "name": "damage_prototypes",
        "type": "custom dictionary string → LuaDamagePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "virtual_signal_prototypes": {
        "name": "virtual_signal_prototypes",
        "type": "custom dictionary string → LuaVirtualSignalPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "equipment_grid_prototypes": {
        "name": "equipment_grid_prototypes",
        "type": "custom dictionary string → LuaEquipmentGridPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "recipe_prototypes": {
        "name": "recipe_prototypes",
        "type": "custom dictionary string → LuaRecipePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "technology_prototypes": {
        "name": "technology_prototypes",
        "type": "custom dictionary string → LuaTechnologyPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "decorative_prototypes": {
        "name": "decorative_prototypes",
        "type": "custom dictionary string → LuaDecorativePrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "tick": {
        "name": "tick",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Current map tick."
      },
      "finished": {
        "name": "finished",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is the scenario finished?"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Speed to update the map at. 1.0 is normal speed -- 60 UPS. \n\n\nNote: Minimum value is 0.1."
      },
      "surfaces": {
        "name": "surfaces",
        "type": "custom dictionary string → LuaSurface",
        "mode": "[Read-only]",
        "doc": ""
      },
      "active_mods": {
        "name": "active_mods",
        "type": "dictionary string → string",
        "mode": "[Read-only]",
        "doc": "The active mods versions. The keys are mod names, the values are the versions. \nExampleThis will print the names and versions of active mods to player p's console. for name, version in pairs(game.active_mods) do\np.print(name .. \" version \" .. version)\nend"
      },
      "connected_players": {
        "name": "connected_players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The online players \n This is primarally useful when you want to do some action against all online players.\n\n\nNote: This does *not* index using player index. See LuaPlayer::index on each player instance for the player index."
      },
      "permissions": {
        "name": "permissions",
        "type": "LuaPermissionGroups",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaFluidPrototype": {
    "name": "LuaFluidPrototype",
    "type": "LuaFluidPrototype",
    "doc": "Prototype of a fluid.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "default_temperature": {
        "name": "default_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Default temperature of the fluid."
      },
      "max_temperature": {
        "name": "max_temperature",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum temperature the fluid can reach."
      },
      "heat_capacity": {
        "name": "heat_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "How much energy the fluid will generate at max temperature assuming 100% efficiency steam engine."
      },
      "pressure_to_speed_ratio": {
        "name": "pressure_to_speed_ratio",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "How much pressure -- difference in fluid levels -- will be converted to speed."
      },
      "flow_to_energy_ratio": {
        "name": "flow_to_energy_ratio",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "How much will a volume of fluid transferred be converted to energy."
      },
      "max_push_amount": {
        "name": "max_push_amount",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "ratio_to_push": {
        "name": "ratio_to_push",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string for this prototype."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this prototype."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this prototype."
      },
      "base_color": {
        "name": "base_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": ""
      },
      "flow_color": {
        "name": "flow_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaForce": {
    "name": "LuaForce",
    "type": "LuaForce",
    "doc": "LuaForce encapsulates data local to each \"force\" or \"faction\" of the game.\n Default forces are player, enemy and neutral. Players and mods can create\n additional forces (up to 64 total).",
    "properties": {
      "get_entity_count": {
        "name": "get_entity_count(name) → uint",
        "returns": "uint",
        "args": {
          "name": {
            "doc": "name :: string: Prototype name of the entity.",
            "name": "name",
            "type": "string"
          }
        },
        "doc": "Count entities of given type.\nParameters\n\nname :: string: Prototype name of the entity.Return value Number of entities of given prototype belonging to this force.\n\nNote: This function has O(1) time complexity as entity counts are kept and maintained in the game engine.",
        "type": "function"
      },
      "disable_research": {
        "name": "disable_research()",
        "args": {},
        "doc": "Disable research for this force.",
        "type": "function"
      },
      "enable_research": {
        "name": "enable_research()",
        "args": {},
        "doc": "Enable research for this force.",
        "type": "function"
      },
      "disable_all_prototypes": {
        "name": "disable_all_prototypes()",
        "args": {},
        "doc": "Disable all recipes and technologies. Only recipes and technologies enabled explicitly will be useable from this point.",
        "type": "function"
      },
      "reset_recipes": {
        "name": "reset_recipes()",
        "args": {},
        "doc": "Load the original version of all recipes from the prototypes.",
        "type": "function"
      },
      "enable_all_recipes": {
        "name": "enable_all_recipes()",
        "args": {},
        "doc": "Unlock all recipes.",
        "type": "function"
      },
      "enable_all_technologies": {
        "name": "enable_all_technologies()",
        "args": {},
        "doc": "Unlock all technologies.",
        "type": "function"
      },
      "research_all_technologies": {
        "name": "research_all_technologies(include_disabled_prototypes)",
        "args": {
          "include_disabled_prototypes": {
            "doc": "include_disabled_prototypes (optional): If technologies that are explicitly disabled in the prototype are also researched. This defaults to false.",
            "name": "include_disabled_prototypes"
          }
        },
        "doc": "Research all technologies. \nParameters\n\ninclude_disabled_prototypes (optional): If technologies that are explicitly disabled in the prototype are also researched. This defaults to false.",
        "type": "function"
      },
      "reset_technologies": {
        "name": "reset_technologies()",
        "args": {},
        "doc": "Load the original versions of technologies from prototypes. Preserves research state of technologies.",
        "type": "function"
      },
      "reset": {
        "name": "reset()",
        "args": {},
        "doc": "Reset everything. All technologies are set to not researched, all modifiers are set to default values.",
        "type": "function"
      },
      "reset_technology_effects": {
        "name": "reset_technology_effects()",
        "args": {},
        "doc": "Reapplies all possible research effects, including unlocked recipes. Any custom chages are lost. Preserves research state of technologies.",
        "type": "function"
      },
      "chart": {
        "name": "chart(surface, area)",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "area": {
            "doc": "area :: BoundingBox: The area on the given surface to chart.",
            "name": "area",
            "type": "BoundingBox"
          }
        },
        "doc": "Chart a portion of the map. The chart for the given area is refreshed; it creates chart for any parts of the given area that haven't been charted yet.\nParameters\n\nsurface :: SurfaceSpecificationarea :: BoundingBox: The area on the given surface to chart.ExampleCharts a 2048x2048 rectangle centered around the origin. game.player.force.chart(game.player.surface,\n{{x = -1024, y = -1024}, {x = 1024, y = 1024}})",
        "type": "function"
      },
      "clear_chart": {
        "name": "clear_chart(surface)",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): Which surface to erase chart data for or if not provided all surfaces charts are erased.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Erases chart data for this force. \nParameters\n\nsurface :: SurfaceSpecification (optional): Which surface to erase chart data for or if not provided all surfaces charts are erased.",
        "type": "function"
      },
      "rechart": {
        "name": "rechart()",
        "args": {},
        "doc": "Force a rechart of the whole chart.",
        "type": "function"
      },
      "chart_all": {
        "name": "chart_all(surface)",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): Which surface to chart or all if not given.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Chart all generated chunks. \nParameters\n\nsurface :: SurfaceSpecification (optional): Which surface to chart or all if not given.",
        "type": "function"
      },
      "is_chunk_charted": {
        "name": "is_chunk_charted(surface, position) → boolean",
        "returns": "boolean",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "position": {
            "doc": "position :: ChunkPosition: Position of the chunk.",
            "name": "position",
            "type": "ChunkPosition"
          }
        },
        "doc": "Has a chunk been charted?\nParameters\n\nsurface :: SurfaceSpecificationposition :: ChunkPosition: Position of the chunk.",
        "type": "function"
      },
      "is_chunk_visible": {
        "name": "is_chunk_visible(surface, position) → boolean",
        "returns": "boolean",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "position": {
            "doc": "position :: ChunkPosition",
            "name": "position",
            "type": "ChunkPosition"
          }
        },
        "doc": "Is the given chunk currently charted and visible (not covered by fogg of war) on the map. \nParameters\n\nsurface :: SurfaceSpecificationposition :: ChunkPosition",
        "type": "function"
      },
      "get_ammo_damage_modifier": {
        "name": "get_ammo_damage_modifier(ammo) → double",
        "returns": "double",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          }
        },
        "doc": "Parameters\n\nammo :: string: Ammo category",
        "type": "function"
      },
      "set_ammo_damage_modifier": {
        "name": "set_ammo_damage_modifier(ammo, modifier)",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          },
          "modifier": {
            "doc": "modifier :: double",
            "name": "modifier",
            "type": "double"
          }
        },
        "doc": "Parameters\n\nammo :: string: Ammo categorymodifier :: double",
        "type": "function"
      },
      "get_gun_speed_modifier": {
        "name": "get_gun_speed_modifier(ammo) → double",
        "returns": "double",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          }
        },
        "doc": "Parameters\n\nammo :: string: Ammo category",
        "type": "function"
      },
      "set_gun_speed_modifier": {
        "name": "set_gun_speed_modifier(ammo, modifier)",
        "args": {
          "ammo": {
            "doc": "ammo :: string: Ammo category",
            "name": "ammo",
            "type": "string"
          },
          "modifier": {
            "doc": "modifier :: double",
            "name": "modifier",
            "type": "double"
          }
        },
        "doc": "Parameters\n\nammo :: string: Ammo categorymodifier :: double",
        "type": "function"
      },
      "get_turret_attack_modifier": {
        "name": "get_turret_attack_modifier(turret) → double",
        "returns": "double",
        "args": {
          "turret": {
            "doc": "turret :: string: Turret prototype name",
            "name": "turret",
            "type": "string"
          }
        },
        "doc": "Parameters\n\nturret :: string: Turret prototype name",
        "type": "function"
      },
      "set_turret_attack_modifier": {
        "name": "set_turret_attack_modifier(turret, modifier)",
        "args": {
          "turret": {
            "doc": "turret :: string: Turret prototype name",
            "name": "turret",
            "type": "string"
          },
          "modifier": {
            "doc": "modifier :: double",
            "name": "modifier",
            "type": "double"
          }
        },
        "doc": "Parameters\n\nturret :: string: Turret prototype namemodifier :: double",
        "type": "function"
      },
      "set_cease_fire": {
        "name": "set_cease_fire(other, cease_fire)",
        "args": {
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          },
          "cease_fire": {
            "doc": "cease_fire :: boolean: When true, this force won't attack other; otherwise it will.",
            "name": "cease_fire",
            "type": "boolean"
          }
        },
        "doc": "Stop attacking members of a given force.\nParameters\n\nother :: string or LuaForcecease_fire :: boolean: When true, this force won't attack other; otherwise it will.",
        "type": "function"
      },
      "get_cease_fire": {
        "name": "get_cease_fire(other) → boolean",
        "returns": "boolean",
        "args": {
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          }
        },
        "doc": "Will this force attack members of another force?\nParameters\n\nother :: string or LuaForce",
        "type": "function"
      },
      "set_friend": {
        "name": "set_friend(other, cease_fire)",
        "args": {
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          },
          "cease_fire": {
            "doc": "cease_fire :: boolean",
            "name": "cease_fire",
            "type": "boolean"
          }
        },
        "doc": "Friends have unrestricted access to buildings and turrets won't fire at them.\nParameters\n\nother :: string or LuaForcecease_fire :: boolean",
        "type": "function"
      },
      "get_friend": {
        "name": "get_friend(other) → boolean",
        "returns": "boolean",
        "args": {
          "other": {
            "doc": "other :: string or LuaForce",
            "name": "other",
            "type": "string or LuaForce"
          }
        },
        "doc": "Is this force a friend?\nParameters\n\nother :: string or LuaForce",
        "type": "function"
      },
      "is_pathfinder_busy": {
        "name": "is_pathfinder_busy() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Is pathfinder busy? When the pathfinder is busy, it won't accept any more pathfinding requests.",
        "type": "function"
      },
      "kill_all_units": {
        "name": "kill_all_units()",
        "args": {},
        "doc": "Kill all units and flush the pathfinder.",
        "type": "function"
      },
      "find_logistic_network_by_position": {
        "name": "find_logistic_network_by_position(position, surface) → LuaLogisticNetwork",
        "returns": "LuaLogisticNetwork",
        "args": {
          "position": {
            "doc": "position :: Position: Position to find a network for",
            "name": "position",
            "type": "Position"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification: Surface to search on",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameters\n\nposition :: Position: Position to find a network forsurface :: SurfaceSpecification: Surface to search onReturn value The found network or nil.",
        "type": "function"
      },
      "set_spawn_position": {
        "name": "set_spawn_position(position, surface)",
        "args": {
          "position": {
            "doc": "position :: Position: The new position on the given surface.",
            "name": "position",
            "type": "Position"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification: Surface to set the spawn position for.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameters\n\nposition :: Position: The new position on the given surface.surface :: SurfaceSpecification: Surface to set the spawn position for.",
        "type": "function"
      },
      "get_spawn_position": {
        "name": "get_spawn_position(surface) → Position",
        "returns": "Position",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameters\n\nsurface :: SurfaceSpecification",
        "type": "function"
      },
      "unchart_chunk": {
        "name": "unchart_chunk(position, surface)",
        "args": {
          "position": {
            "doc": "position :: ChunkPosition: The chunk position to unchart.",
            "name": "position",
            "type": "ChunkPosition"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification: Surface to unchart on.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameters\n\nposition :: ChunkPosition: The chunk position to unchart.surface :: SurfaceSpecification: Surface to unchart on.",
        "type": "function"
      },
      "get_item_launched": {
        "name": "get_item_launched(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string: The item to get",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Gets the count of a given item launched in rockets. \nParameters\n\nitem :: string: The item to getReturn value The count of the item that has been launched.",
        "type": "function"
      },
      "set_item_launched": {
        "name": "set_item_launched(item, count)",
        "args": {
          "item": {
            "doc": "item :: string: The item to set",
            "name": "item",
            "type": "string"
          },
          "count": {
            "doc": "count :: uint: The count to set",
            "name": "count",
            "type": "uint"
          }
        },
        "doc": "Sets the count of a given item launched in rockets. \nParameters\n\nitem :: string: The item to setcount :: uint: The count to set",
        "type": "function"
      },
      "print": {
        "name": "print(message)",
        "args": {
          "message": {
            "doc": "message :: LocalisedString",
            "name": "message",
            "type": "LocalisedString"
          }
        },
        "doc": "Print text to the chat console of all players on this force.\nParameters\n\nmessage :: LocalisedString",
        "type": "function"
      },
      "get_trains": {
        "name": "get_trains(surface) → array of LuaTrain",
        "returns": "array of LuaTrain",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): If given only trains on the surface are returned.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Parameters\n\nsurface :: SurfaceSpecification (optional): If given only trains on the surface are returned.",
        "type": "function"
      },
      "add_chart_tag": {
        "name": "add_chart_tag(surface, tag) → LuaCustomChartTag",
        "returns": "LuaCustomChartTag",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification: Which surface to add the tag to.",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "tag": {
            "doc": "tag: Table with the following fields:  * icon :: SignalID (optional): )\n * position :: Position\n * text :: string (optional)\n * last_user :: PlayerSpecification (optional)\n * orientation :: float (optional)\n * target :: LuaEntity (optional)",
            "name": "tag",
            "type": "SignalID"
          }
        },
        "doc": "Adds a custom chart tag to the given surface and returns the new tag or nil if the given position isn't valid for a chart tag. \nParameters\n\nsurface :: SurfaceSpecification: Which surface to add the tag to.tag: Table with the following fields:  * icon :: SignalID (optional): )\n * position :: Position\n * text :: string (optional)\n * last_user :: PlayerSpecification (optional)\n * orientation :: float (optional)\n * target :: LuaEntity (optional)\n\n\nNote: The chunk must be charted for a tag to be valid at that location.\n\nNote: The icon, text, or both must be provided.",
        "type": "function"
      },
      "find_chart_tags": {
        "name": "find_chart_tags(surface, area) → array of LuaCustomChartTag",
        "returns": "array of LuaCustomChartTag",
        "args": {
          "surface": {
            "doc": "surface :: SurfaceSpecification",
            "name": "surface",
            "type": "SurfaceSpecification"
          },
          "area": {
            "doc": "area :: BoundingBox (optional)",
            "name": "area",
            "type": "BoundingBox"
          }
        },
        "doc": "Finds all custom chart tags within the given bounding box on the given surface. \nParameters\n\nsurface :: SurfaceSpecificationarea :: BoundingBox (optional)",
        "type": "function"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the force.\nExamplePrints \"player\" game.player.print(game.player.force.name)"
      },
      "technologies": {
        "name": "technologies",
        "type": "custom dictionary string → LuaTechnology",
        "mode": "[Read-only]",
        "doc": "Technologies owned by this force, indexed by their name.\nExampleResearches the technology for the player's force game.player.force.technologies[\"iron-working\"].researched = true"
      },
      "recipes": {
        "name": "recipes",
        "type": "custom dictionary string → LuaRecipe",
        "mode": "[Read-only]",
        "doc": "Recipes available to this force, indexed by their name.\nExamplePrints the category of the given recipe game.player.print(game.player.force.recipes[\"transport-belt\"].category)"
      },
      "manual_mining_speed_modifier": {
        "name": "manual_mining_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Multiplier of the manual mining speed. Default value is 0. The actual mining speed will be multiplied by 1 + manual_mining_speed_modifier.\nExampleDouble the player's mining speed game.player.force.manual_mining_speed_modifier = 1"
      },
      "manual_crafting_speed_modifier": {
        "name": "manual_crafting_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Multiplier of the manual crafting speed. Default value is 0. The actual crafting speed will be multiplied by 1 + manual_crafting_speed_modifier.\nExampleDouble the player's crafting speed game.player.force.manual_crafting_speed_modifier = 1"
      },
      "laboratory_speed_modifier": {
        "name": "laboratory_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "worker_robots_speed_modifier": {
        "name": "worker_robots_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "worker_robots_storage_bonus": {
        "name": "worker_robots_storage_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "current_research": {
        "name": "current_research",
        "type": "LuaTechnology or string",
        "mode": "[Read-Write]",
        "doc": "The current research in progress. Reading this attribute gives a LuaTechnology of the current technology in research, or nil if no research is currently ongoing. Writing this attribute expects a string specifying a technology name or nil to stop any research in progress; writing will start a research of the specified technology."
      },
      "research_progress": {
        "name": "research_progress",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Progress of current research, as a number in range [0, 1]."
      },
      "inserter_stack_size_bonus": {
        "name": "inserter_stack_size_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The inserter stack size bonus for non stack inserters"
      },
      "stack_inserter_capacity_bonus": {
        "name": "stack_inserter_capacity_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of items that can be transferred by stack inserters"
      },
      "character_logistic_slot_count": {
        "name": "character_logistic_slot_count",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Number of character logistic slots."
      },
      "character_trash_slot_count": {
        "name": "character_trash_slot_count",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Number of character trash slots."
      },
      "quickbar_count": {
        "name": "quickbar_count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of character quick bars."
      },
      "maximum_following_robot_count": {
        "name": "maximum_following_robot_count",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Maximum number of follower robots."
      },
      "ghost_time_to_live": {
        "name": "ghost_time_to_live",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The time, in ticks, before a placed ghost disappears."
      },
      "players": {
        "name": "players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "Players belonging to this force."
      },
      "ai_controllable": {
        "name": "ai_controllable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Enables some higher-level AI behaviour for this force. When set to true, biters belonging to this force will automatically expand into new territories, build new spawners, and form unit groups. By default, this value is true for the enemy force and false for all others.\n\n\nNote: Setting this to false does not turn off biters' AI. They will still move around and attack players who come close.\n\nNote: It is necessary for a force to be AI controllable in order to be able to create unit groups or build bases from scripts."
      },
      "logistic_networks": {
        "name": "logistic_networks",
        "type": "dictionary string → array of LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": "List of logistic networks, grouped by surface."
      },
      "item_production_statistics": {
        "name": "item_production_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The item production statistics for this force."
      },
      "fluid_production_statistics": {
        "name": "fluid_production_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The fluid production statistics for this force."
      },
      "kill_count_statistics": {
        "name": "kill_count_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The kill counter statistics for this force."
      },
      "entity_build_count_statistics": {
        "name": "entity_build_count_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The entity build statistics for this force (built and mined)"
      },
      "character_running_speed_modifier": {
        "name": "character_running_speed_modifier",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_build_distance_bonus": {
        "name": "character_build_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_item_drop_distance_bonus": {
        "name": "character_item_drop_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_reach_distance_bonus": {
        "name": "character_reach_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_resource_reach_distance_bonus": {
        "name": "character_resource_reach_distance_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_item_pickup_distance_bonus": {
        "name": "character_item_pickup_distance_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_loot_pickup_distance_bonus": {
        "name": "character_loot_pickup_distance_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "character_inventory_slots_bonus": {
        "name": "character_inventory_slots_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "the number of additional inventory slots the character main inventory has."
      },
      "deconstruction_time_to_live": {
        "name": "deconstruction_time_to_live",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The time, in ticks, before a deconstruction order is removed."
      },
      "character_health_bonus": {
        "name": "character_health_bonus",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "auto_character_trash_slots": {
        "name": "auto_character_trash_slots",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "true if auto character trash slots are enabled. Character trash slots must be > 0 as well for this to actually be used."
      },
      "zoom_to_world_enabled": {
        "name": "zoom_to_world_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to use zoom-to-world on map."
      },
      "zoom_to_world_ghost_building_enabled": {
        "name": "zoom_to_world_ghost_building_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to build ghosts through blueprint or direct ghost placement, or \"mine\" ghosts when using zoom-to-world."
      },
      "zoom_to_world_blueprint_enabled": {
        "name": "zoom_to_world_blueprint_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to create new blueprints using empty blueprint item when using zoom-to-world."
      },
      "zoom_to_world_deconstruction_planner_enabled": {
        "name": "zoom_to_world_deconstruction_planner_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to use deconstruction planner when using zoom-to-world."
      },
      "zoom_to_world_selection_tool_enabled": {
        "name": "zoom_to_world_selection_tool_enabled",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Ability to use custom selection tools when using zoom-to-world."
      },
      "rockets_launched": {
        "name": "rockets_launched",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The number of rockets launched."
      },
      "items_launched": {
        "name": "items_launched",
        "type": "dictionary string → uint",
        "mode": "[Read-only]",
        "doc": "All of the items that have been launched in rockets."
      },
      "connected_players": {
        "name": "connected_players",
        "type": "array of LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The connected players belonging to this force. \n This is primarally useful when you want to do some action against all online players of this force.\n\n\nNote: This does *not* index using player index. See LuaPlayer::index on each player instance for the player index."
      },
      "mining_drill_productivity_bonus": {
        "name": "mining_drill_productivity_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "train_braking_force_bonus": {
        "name": "train_braking_force_bonus",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "evolution_factor": {
        "name": "evolution_factor",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Evolution factor of this force."
      },
      "friendly_fire": {
        "name": "friendly_fire",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "If friendly fire is enabled for this force."
      }
    }
  },
  "LuaFluidBox": {
    "name": "LuaFluidBox",
    "type": "LuaFluidBox",
    "doc": "An array of fluid boxes. Entities may contain more than one fluid box, and some can change the number\n of fluid boxes -- for instance, an assembling machine will change its number of fluid boxes depending\n on its active recipe.",
    "properties": {
      "get_capacity": {
        "name": "get_capacity(index) → double",
        "returns": "double",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "The capacity of the given fluidbox index. \nParameters\n\nindex :: uint",
        "type": "function"
      },
      "get_connections": {
        "name": "get_connections() → array of LuaFluidBox",
        "returns": "array of LuaFluidBox",
        "args": {},
        "doc": "The fluidbox connections for the given fluidbox index.",
        "type": "function"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of fluid boxes."
      },
      "owner": {
        "name": "owner",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity that owns this fluidbox."
      },
      "operator []": {
        "name": "operator []",
        "mode": "[Read-only]",
        "doc": "Access, set or clear a fluid box. The index must always be in bounds (see LuaFluidBox::operator #); new fluidboxes may not be added or removed using this operator. If the given fluid box doesn't contain any fluid, nil is returned. Similarly, nil can be written to a fluid box to remove all fluid from it.",
        "type": "operator []"
      }
    }
  },
  "LuaFlowStatistics": {
    "name": "LuaFlowStatistics",
    "type": "LuaFlowStatistics",
    "doc": "Encapsulates statistic data for different parts of the game.",
    "properties": {
      "get_input_count": {
        "name": "get_input_count(string)",
        "args": {
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Gets the total input count for a given prototype.\nParameters\n\nstring: The prototype name.",
        "type": "function"
      },
      "set_input_count": {
        "name": "set_input_count(string, count)",
        "args": {
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          },
          "count": {
            "doc": "count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
            "name": "count",
            "type": "uint64 or double"
          }
        },
        "doc": "Sets the total input count for a given prototype.\nParameters\n\nstring: The prototype name.count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
        "type": "function"
      },
      "get_output_count": {
        "name": "get_output_count(string)",
        "args": {
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          }
        },
        "doc": "Gets the total output count for a given prototype.\nParameters\n\nstring: The prototype name.",
        "type": "function"
      },
      "set_output_count": {
        "name": "set_output_count(string, count)",
        "args": {
          "string": {
            "doc": "string: The prototype name.",
            "name": "string"
          },
          "count": {
            "doc": "count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
            "name": "count",
            "type": "uint64 or double"
          }
        },
        "doc": "Sets the total output count for a given prototype.\nParameters\n\nstring: The prototype name.count :: uint64 or double: The new count. The type depends on the instance of the statistics.",
        "type": "function"
      },
      "input_counts": {
        "name": "input_counts",
        "type": "dictionary string → array of uint64 or double",
        "mode": "[Read-only]",
        "doc": "List of input counts indexed by name <> value."
      },
      "output_counts": {
        "name": "output_counts",
        "type": "dictionary string → array of uint64 or double",
        "mode": "[Read-only]",
        "doc": "List of output counts indexed by name <> value."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force these statistics belong to."
      }
    }
  },
  "LuaEquipmentPrototype": {
    "name": "LuaEquipmentPrototype",
    "type": "LuaEquipmentPrototype",
    "doc": "Prototype of a modular equipment.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this equipment prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "shape": {
        "name": "shape",
        "mode": "[Read-only]",
        "doc": "Shape of this equipment prototype. It is a table: \n * width :: uint\n * height :: uint",
        "type": "shape"
      },
      "take_result": {
        "name": "take_result",
        "type": "LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "The result item when taking this equipment out of an equipment grid. nil if there is no result item."
      },
      "energy_production": {
        "name": "energy_production",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The max power generated by this equipment."
      },
      "shield": {
        "name": "shield",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The shield value of this equipment. 0 for non-shield equipment."
      },
      "energy_per_shield": {
        "name": "energy_per_shield",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The energy per shield point restored. 0 for non-shield equipment."
      },
      "logistic_parameters": {
        "name": "logistic_parameters",
        "mode": "[Read-only]",
        "doc": "The logistic parameters for roboport equipment",
        "type": "logistic_parameters"
      },
      "energy_consumption": {
        "name": "energy_consumption",
        "type": "double",
        "mode": "[Read-only]",
        "doc": ""
      },
      "movement_bonus": {
        "name": "movement_bonus",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is MovementBonusEquipmentPrototype"
      },
      "night_vision_tint": {
        "name": "night_vision_tint",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is NightVisionEquipmentPrototype"
      },
      "energy_source": {
        "name": "energy_source",
        "mode": "[Read-only]",
        "doc": "The energy source prototype for the equipment.",
        "type": "energy_source"
      },
      "equipment_categories": {
        "name": "equipment_categories",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "Category names for this equipment. These categories will be used to determine whether this equpiment is allowed in a particular equpiment grid. \nSee also * LuaEquipmentGridPrototype::equipment_categories"
      }
    }
  },
  "LuaEquipmentGridPrototype": {
    "name": "LuaEquipmentGridPrototype",
    "type": "LuaEquipmentGridPrototype",
    "doc": "Prototype of a virtual signal.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "equipment_categories": {
        "name": "equipment_categories",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "Equipment category names for the categories that may be inserted into this equipment grid. The grid will accept any equipment that has at least one category in this list. \nSee also * LuaEquipmentPrototype::equipment_categories"
      },
      "width": {
        "name": "width",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "height": {
        "name": "height",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaEquipmentGrid": {
    "name": "LuaEquipmentGrid",
    "type": "LuaEquipmentGrid",
    "doc": "An equipment grid is the inside of a power armour.",
    "properties": {
      "take": {
        "name": "take{position=…, equipment=…} → SimpleItemStack",
        "returns": "SimpleItemStack",
        "args": {
          "position": {
            "doc": "Table with the following fields:  * position :: Position (optional): Take the equipment that contains this position in the grid.\n * equipment :: LuaEquipment (optional): Take this exact equipment.\n\nEither position or equipment must be specified.",
            "name": "position",
            "type": "Position"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          },
          "equipment=…": {
            "name": "equipment=…",
            "type": "equipment=…"
          }
        },
        "doc": "Remove an equipment from the grid.\nParameters\n\n Table with the following fields:  * position :: Position (optional): Take the equipment that contains this position in the grid.\n * equipment :: LuaEquipment (optional): Take this exact equipment.\nEither position or equipment must be specified.Return value The removed equipment, or nil if no equipment was removed.",
        "type": "function"
      },
      "take_all": {
        "name": "take_all() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Remove all equipment from the grid.\nReturn value Count of each removed equipment, indexed by their prototype names.",
        "type": "function"
      },
      "clear": {
        "name": "clear()",
        "args": {},
        "doc": "Clear all equipment from the grid. I.e. remove it without actually returning it.",
        "type": "function"
      },
      "put": {
        "name": "put{name=…, position=…} → LuaEquipment",
        "returns": "LuaEquipment",
        "args": {
          "name": {
            "doc": "Table with the following fields:  * name :: string: Equipment prototype name\n * position :: Position (optional): Grid position to put the equipment in.",
            "name": "name",
            "type": "string"
          },
          "name=…": {
            "name": "name=…",
            "type": "name=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Insert an equipment into the grid.\nParameters\n\n Table with the following fields:  * name :: string: Equipment prototype name\n * position :: Position (optional): Grid position to put the equipment in.\nReturn value The newly-added equipment, or nil if the equipment could not be added.",
        "type": "function"
      },
      "can_move": {
        "name": "can_move{equipment=…, position=…} → boolean",
        "returns": "boolean",
        "args": {
          "equipment": {
            "doc": "Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it",
            "name": "equipment",
            "type": "LuaEquipment"
          },
          "equipment=…": {
            "name": "equipment=…",
            "type": "equipment=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Check whether moving an equipment would succeed.\nParameters\n\n Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it",
        "type": "function"
      },
      "move": {
        "name": "move{equipment=…, position=…} → boolean",
        "returns": "boolean",
        "args": {
          "equipment": {
            "doc": "Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it",
            "name": "equipment",
            "type": "LuaEquipment"
          },
          "equipment=…": {
            "name": "equipment=…",
            "type": "equipment=…"
          },
          "position=…": {
            "name": "position=…",
            "type": "position=…"
          }
        },
        "doc": "Move an equipment within this grid.\nParameters\n\n Table with the following fields:  * equipment :: LuaEquipment: The equipment to move\n * position :: Position: Where to put it\nReturn value true if the equipment was successfully moved.",
        "type": "function"
      },
      "get": {
        "name": "get(position) → LuaEquipment",
        "returns": "LuaEquipment",
        "args": {
          "position": {
            "doc": "position :: Position: The position",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Find equipment in the Equipment Grid based off a position.\nParameters\n\nposition :: Position: The positionReturn value The found equipment, or nil if equipment could not be found at the given position.",
        "type": "function"
      },
      "get_contents": {
        "name": "get_contents() → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {},
        "doc": "Get counts of all equipment in this grid.\nReturn value The counts, indexed by equipment names.",
        "type": "function"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEquipmentGridPrototype",
        "mode": "[Read-only]",
        "doc": ""
      },
      "width": {
        "name": "width",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Width of the equipment grid."
      },
      "height": {
        "name": "height",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Height of the equipment grid."
      },
      "equipment": {
        "name": "equipment",
        "type": "array of LuaEquipment",
        "mode": "[Read-only]",
        "doc": "All the equipment in this grid."
      },
      "generator_energy": {
        "name": "generator_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Total energy per tick generated by the equipment inside this grid."
      },
      "max_solar_energy": {
        "name": "max_solar_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum energy per tick that can be created by any solar panels in the equipment grid. Actual generated energy varies depending on the daylight levels."
      },
      "available_in_batteries": {
        "name": "available_in_batteries",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The total energy stored in all batteries in the equipment grid."
      },
      "battery_capacity": {
        "name": "battery_capacity",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Total energy storage capacity of all batteries in the equipment grid."
      },
      "shield": {
        "name": "shield",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The amount of shields this equipment grid has."
      },
      "max_shield": {
        "name": "max_shield",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "The maximum amount of shields this equipment grid has."
      }
    }
  },
  "LuaEquipment": {
    "name": "LuaEquipment",
    "type": "LuaEquipment",
    "doc": "An item in one's power armour.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this equipment."
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this equipment."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Position of this equipment in the equipment grid."
      },
      "shape": {
        "name": "shape",
        "mode": "[Read-only]",
        "doc": "Shape of this equipment. It is a table: \n * width :: uint\n * height :: uint",
        "type": "shape"
      },
      "shield": {
        "name": "shield",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Current shield value of the equipment. \n\n\nNote: Can't be set higher than LuaEquipment::max_shield."
      },
      "max_shield": {
        "name": "max_shield",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum shield value."
      },
      "max_solar_power": {
        "name": "max_solar_power",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum solar power generated."
      },
      "movement_bonus": {
        "name": "movement_bonus",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Movement speed bonus."
      },
      "generator_power": {
        "name": "generator_power",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Energy generated per tick."
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Current available energy."
      },
      "max_energy": {
        "name": "max_energy",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Maximum amount of energy that can be stored in this equipment."
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEquipmentPrototype",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaEntityPrototype": {
    "name": "LuaEntityPrototype",
    "type": "LuaEntityPrototype",
    "doc": "Prototype of an entity.",
    "properties": {
      "has_flag": {
        "name": "has_flag(flag) → boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "doc": "flag :: string: The flag to check. Must be one of  *  \"pushable\"\n *  \"placeable-neutral\"\n *  \"placeable-player\"\n *  \"placeable-enemy\"\n *  \"placeable-off-grid\"\n *  \"player-creation\"\n *  \"building-direction-8-way\"\n *  \"filter-directions\"\n *  \"fast-replaceable-no-build-while-moving\"\n *  \"breaths-air\"\n *  \"not-repairable\"\n *  \"not-on-map\"\n *  \"not-blueprintable\"\n *  \"not-deconstructable\"",
            "name": "flag",
            "type": "string"
          }
        },
        "doc": "Does this prototype have a flag enabled?\nParameters\n\nflag :: string: The flag to check. Must be one of  *  \"pushable\"\n *  \"placeable-neutral\"\n *  \"placeable-player\"\n *  \"placeable-enemy\"\n *  \"placeable-off-grid\"\n *  \"player-creation\"\n *  \"building-direction-8-way\"\n *  \"filter-directions\"\n *  \"fast-replaceable-no-build-while-moving\"\n *  \"breaths-air\"\n *  \"not-repairable\"\n *  \"not-on-map\"\n *  \"not-blueprintable\"\n *  \"not-deconstructable\"",
        "type": "function"
      },
      "get_inventory_size": {
        "name": "get_inventory_size(index) → uint",
        "returns": "uint",
        "args": {
          "index": {
            "doc": "index :: uint",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Gets the base size of the given inventory on this entity or nil if the given inventory doesn't exist. \nParameters\n\nindex :: uint",
        "type": "function"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Type of this prototype."
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "max_health": {
        "name": "max_health",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Max health of this entity. Will be 0 if this is not an entity with health."
      },
      "infinite_resource": {
        "name": "infinite_resource",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this resource infinite? Will be nil when used on a non-resource."
      },
      "minimum_resource_amount": {
        "name": "minimum_resource_amount",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Minimum amount of this resource. Will be nil when used on a non-resource."
      },
      "resource_category": {
        "name": "resource_category",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Category of this resource. \"basic-solid\", \"basic-fluid\" or nil (when not a resource)."
      },
      "mineable_properties": {
        "name": "mineable_properties",
        "mode": "[Read-only]",
        "doc": "Table with the following fields:  * minable :: boolean: Is this entity mineable at all?\n * hardness :: double: Mining hardness.\n * miningtime :: double: Energy required to mine an entity.\n * miningparticle :: string (optional): Prototype name of the particle produced when mining this entity. Will only be present if this entity produces any particle during mining.\n * products :: array of Product: Products obtained by mining this entity.",
        "type": "mineable_properties"
      },
      "items_to_place_this": {
        "name": "items_to_place_this",
        "type": "dictionary string → LuaItemPrototype",
        "mode": "[Read-only]",
        "doc": "Items that when placed will produce this entity. It is a dictionary indexed by the item prototype name."
      },
      "collision_box": {
        "name": "collision_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for collision checking."
      },
      "selection_box": {
        "name": "selection_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for drawing selection."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "group": {
        "name": "group",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Group of this entity."
      },
      "subgroup": {
        "name": "subgroup",
        "type": "LuaGroup",
        "mode": "[Read-only]",
        "doc": "Subgroup of this entity."
      },
      "healing_per_tick": {
        "name": "healing_per_tick",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Amount this entity can heal per tick."
      },
      "emissions_per_tick": {
        "name": "emissions_per_tick",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "Amount of pollution emissions per tick this entity will create."
      },
      "corpses": {
        "name": "corpses",
        "type": "dictionary string → LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "Corpses used when this entity is destroyed. It is a dictionary indexed by the corpse's prototype name."
      },
      "selectable_in_game": {
        "name": "selectable_in_game",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Is this entity selectable?"
      },
      "weight": {
        "name": "weight",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "resistances": {
        "name": "resistances",
        "type": "Resistances",
        "mode": "[Read-only]",
        "doc": ""
      },
      "fast_replaceable_group": {
        "name": "fast_replaceable_group",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The group of mutually fast-replaceable entities. Possibly nil."
      },
      "loot": {
        "name": "loot",
        "type": "Loot",
        "mode": "[Read-only]",
        "doc": "Loot that will be dropped when this entity is killed. nil if there is no loot."
      },
      "repair_speed_modifier": {
        "name": "repair_speed_modifier",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Repair-speed modifier for this entity. Actual repair speed will be tool_repair_speed * entity_repair_speed_modifier. May be nil."
      },
      "turret_range": {
        "name": "turret_range",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": ""
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[Read-only]",
        "doc": "Autoplace specification for this entity prototype. nil if none."
      },
      "collision_mask": {
        "name": "collision_mask",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "The collison masks this entity uses"
      },
      "belt_speed": {
        "name": "belt_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The speed of this transport belt or nil if this isn't a transport belt related prototype."
      },
      "result_units": {
        "name": "result_units",
        "type": "array of UnitSpawnDefinition",
        "mode": "[Read-only]",
        "doc": "The result units and spawn points with weight and evolution factor for a biter spawner entity.\n Each UnitSpawnDefinition is a table: \n * unit :: string: Prototype name of the unit that would be spawned\n * spawn_points :: array of SpawnPoint: Each SpawnPoint is a table:  * evolution_factor :: double: Evolution factor for which this weight applies.\n    * weight :: double: Probability of spawning this unit at this evolution factor."
      },
      "attack_result": {
        "name": "attack_result",
        "mode": "[Read-only]",
        "doc": "The attack result of this entity if the entity has one else nil.",
        "type": "attack_result"
      },
      "final_attack_result": {
        "name": "final_attack_result",
        "mode": "[Read-only]",
        "doc": "The final attack result for projectiles nil if not a projectile",
        "type": "final_attack_result"
      },
      "spawn_cooldown": {
        "name": "spawn_cooldown",
        "mode": "[Read-only]",
        "doc": "The spawning cooldown for this enemy spawner prototype or nil. \nTable with the following fields:  * min :: double\n * max :: double",
        "type": "spawn_cooldown"
      },
      "mining_drill_radius": {
        "name": "mining_drill_radius",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The mining radius of this mining drill prototype or nil if this isn't a mining drill prototype."
      },
      "logistic_mode": {
        "name": "logistic_mode",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The logistic mode of this logistic container or nil if this isn't a logistic container prototype."
      },
      "max_underground_distance": {
        "name": "max_underground_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The max underground distance for underground belts and underground pipes or nil if this isn't one of those prototypes."
      },
      "drawing_box": {
        "name": "drawing_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for drawing the entity icon."
      },
      "sticker_box": {
        "name": "sticker_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used to attach sticker type entities."
      },
      "flags": {
        "name": "flags",
        "type": "array of string",
        "mode": "[Read-only]",
        "doc": "The entity prototype flags for this entitiy."
      },
      "remains_when_mined": {
        "name": "remains_when_mined",
        "type": "array of LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The remains left behind when this entity is mined."
      },
      "additional_pastable_entities": {
        "name": "additional_pastable_entities",
        "type": "array of LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "Entities this entity can be pasted onto in addition to the normal allowed ones."
      },
      "allow_copy_paste": {
        "name": "allow_copy_paste",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "When false copy-paste is not allowed for this entity."
      },
      "shooting_cursor_size": {
        "name": "shooting_cursor_size",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The cursor size used when shooting at this entity."
      },
      "created_smoke": {
        "name": "created_smoke",
        "mode": "[Read-only]",
        "doc": "The smoke trigger run when this entity is built or nil.",
        "type": "created_smoke"
      },
      "created_effect": {
        "name": "created_effect",
        "mode": "[Read-only]",
        "doc": "The trigger run when this entity is created or nil.",
        "type": "created_effect"
      },
      "map_color": {
        "name": "map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The map color used when charting this entity if a friendly or enemy color isn't defined or nil."
      },
      "friendly_map_color": {
        "name": "friendly_map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The friendly map color used when charting this entity."
      },
      "enemy_map_color": {
        "name": "enemy_map_color",
        "type": "Color",
        "mode": "[Read-only]",
        "doc": "The enemy map color used when charting this entity."
      },
      "build_base_evolution_requirement": {
        "name": "build_base_evolution_requirement",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The evolution requirement to build this entity as a base when expanding enemy bases."
      },
      "instruments": {
        "name": "instruments",
        "type": "array of ProgrammableSpeakerInstrument",
        "mode": "[Read-only]",
        "doc": "The instruments for this programmable speaker or nil."
      },
      "max_polyphony": {
        "name": "max_polyphony",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The maximum polyphony for this programmable speaker or nil."
      },
      "module_inventory_size": {
        "name": "module_inventory_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The module inventory size or nil if this entity doesn't suport modules."
      },
      "ingredient_count": {
        "name": "ingredient_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The max number of ingredients this crafting-machine prototype supports or nil if this isn't a crafting-machine prototype."
      },
      "crafting_speed": {
        "name": "crafting_speed",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The crafting speed of this crafting-machine prototype or nil if this isn't a crafting-machine prototype."
      }
    }
  },
  "LuaEntity": {
    "name": "LuaEntity",
    "type": "LuaEntity",
    "doc": "The primary interface for interacting with entities through the Lua API.\n Entity is everything on the map except tiles.",
    "properties": {
      "get_output_inventory": {
        "name": "get_output_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "Gets the entities output inventory if it has one. \nReturn value a reference to the entities output inventory.",
        "type": "function"
      },
      "get_module_inventory": {
        "name": "get_module_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "Return value Inventory for storing modules of this entity; nil if this entity has no module inventory.",
        "type": "function"
      },
      "get_fuel_inventory": {
        "name": "get_fuel_inventory() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "The fuel inventory for this entity or nil if this entity doesn't have a fuel inventory.",
        "type": "function"
      },
      "damage": {
        "name": "damage(damage, force, type) → float",
        "returns": "float",
        "args": {
          "damage": {
            "doc": "damage :: float: The amount of damage to be done",
            "name": "damage",
            "type": "float"
          },
          "force": {
            "doc": "force :: string or LuaForce: The force that will be doing the damage.",
            "name": "force",
            "type": "string or LuaForce"
          },
          "type": {
            "doc": "type :: string (optional): The type of damage to be done.",
            "name": "type",
            "type": "string"
          }
        },
        "doc": "Damages the entity. \nParameters\n\ndamage :: float: The amount of damage to be doneforce :: string or LuaForce: The force that will be doing the damage.type :: string (optional): The type of damage to be done.Return value the total damage actually applied after resistances.Can only be used if this is EntityWithHealth",
        "type": "function"
      },
      "destroy": {
        "name": "destroy() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Destroys the entity. \nReturn value if the entity was actually destroyed.\n\nNote: Not all entities can be destroyed - things such as rails under trains cannot be destroyed until the train is moved or destroyed.",
        "type": "function"
      },
      "set_command": {
        "name": "set_command(command)",
        "args": {
          "command": {
            "doc": "command :: Command",
            "name": "command",
            "type": "Command"
          }
        },
        "doc": "Give the entity a command. \nParameters\n\ncommand :: CommandCan only be used if this is Unit",
        "type": "function"
      },
      "has_command": {
        "name": "has_command() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Has this unit been assigned a command? \nCan only be used if this is Unit",
        "type": "function"
      },
      "die": {
        "name": "die()",
        "args": {},
        "doc": "Immediately kills the entity. Doesn't attribute the kill to any force. Doesn't care whether the entity is destroyable or damageable. Error is thrown when called on entity that doesn't have health. Unlike LuaEntity::destroy, die will trigger on_entity_diedand the entity will drop loot and corpse if it have any.",
        "type": "function"
      },
      "has_flag": {
        "name": "has_flag(flag) → boolean",
        "returns": "boolean",
        "args": {
          "flag": {
            "doc": "flag :: string: The flag to test",
            "name": "flag",
            "type": "string"
          }
        },
        "doc": "Test whether this entity's prototype has a flag set.\nParameters\n\nflag :: string: The flag to testReturn value true if the entity has the given flag set.\n\nNote: entity.has_flag(f) is a shortcut for entity.prototype.has_flag(f).",
        "type": "function"
      },
      "add_market_item": {
        "name": "add_market_item{price=…, offer=…}",
        "args": {
          "price": {
            "doc": "Table with the following fields:  * price: list of prices, every element is 2 item table, first is the item name, the second is count.\n * offer :: Modifier: The action that will take place when a player accepts the offer. Usuallly a \"give-item\" modifier.",
            "name": "price",
            "type": "Modifier"
          },
          "price=…": {
            "name": "price=…",
            "type": "price=…"
          },
          "offer=…": {
            "name": "offer=…",
            "type": "offer=…"
          }
        },
        "doc": "Offer a thing on the market. \nParameters\n\n Table with the following fields:  * price: list of prices, every element is 2 item table, first is the item name, the second is count.\n * offer :: Modifier: The action that will take place when a player accepts the offer. Usuallly a \"give-item\" modifier.\nExampleAdds market offer, 1 copper ore for 10 iron ore. market.add_market_item{price={{\"iron-ore\", 10}}, offer={type=\"give-item\", item=\"copper-ore\"}} ExampleAdds market offer, 1 copper ore for 5 iron ore and 5 stone ore. market.add_market_item{price={{\"iron-ore\", 5}, {\"stone\", 5}}, offer={type=\"give-item\", item=\"copper-ore\"}} Can only be used if this is Market",
        "type": "function"
      },
      "remove_market_item": {
        "name": "remove_market_item(offer) → boolean",
        "returns": "boolean",
        "args": {
          "offer": {
            "doc": "offer :: uint: Index of offer to remove.",
            "name": "offer",
            "type": "uint"
          }
        },
        "doc": "Remove an offer from a market. \nParameters\n\noffer :: uint: Index of offer to remove.Return value true if the offer was successfully removed; false when the given index was not valid.Can only be used if this is Market",
        "type": "function"
      },
      "get_market_items": {
        "name": "get_market_items() → array of Offer",
        "returns": "array of Offer",
        "args": {},
        "doc": "Get all offers in a market as an array. \nReturn value See LuaEntity::add_market_item for the format of an Offer.Can only be used if this is Market",
        "type": "function"
      },
      "connect_neighbour": {
        "name": "connect_neighbour(target)",
        "args": {
          "target": {
            "doc": "target :: LuaEntity or table:  *  To connect two electric poles, target has to be a LuaEntity specifying another electric pole. This will connect them with copper cable.\n *  To connect two devices with wire, this parameter is a table:  * wire :: defines.wire_type: Wire colour, either defines.wire_type.red or defines.wire_type.green.\n    * target_entity :: LuaEntity: The entity to connect the wire to\n    * source_circuit_id :: uint (optional): Mandatory if the source entity has more than one circuit connector.\n    * target_circuit_id :: uint (optional): Mandatory if the target entity has more than one circuit connector.",
            "name": "target",
            "type": "LuaEntity or table"
          }
        },
        "doc": "Connect two devices with wire or cable.\nParameters\n\ntarget :: LuaEntity or table:  *  To connect two electric poles, target has to be a LuaEntity specifying another electric pole. This will connect them with copper cable.\n *  To connect two devices with wire, this parameter is a table:  * wire :: defines.wire_type: Wire colour, either defines.wire_type.red or defines.wire_type.green.\n    * target_entity :: LuaEntity: The entity to connect the wire to\n    * source_circuit_id :: uint (optional): Mandatory if the source entity has more than one circuit connector.\n    * target_circuit_id :: uint (optional): Mandatory if the target entity has more than one circuit connector.",
        "type": "function"
      },
      "disconnect_neighbour": {
        "name": "disconnect_neighbour(target)",
        "args": {
          "target": {
            "doc": "target :: defines.wire_type or LuaEntity or table (optional):  *  To remove all copper cables, leave this parameter out: pole.disconnect_neighbour()\n *  To remove all wires of a specific colour, pass defines.wire_type.red or defines.wire_type.green.\n *  To remove a specific copper cable between two poles, target can be a LuaEntityspecifying the other pole. E.g. pole1.disconnect_neighbour(pole2).\n *  To remove a specific red or green wire, pass a table in the same format as for LuaEntity::connect_neighbour:  * wire :: defines.wire_type: Wire colour\n    * target_entity :: LuaEntity\n    * source_circuit_id :: uint (optional)\n    * target_circuit_id :: uint (optional)",
            "name": "target",
            "type": "defines.wire_type or LuaEntity or table"
          }
        },
        "doc": "Disconnect wires or cables.\nParameters\n\ntarget :: defines.wire_type or LuaEntity or table (optional):  *  To remove all copper cables, leave this parameter out: pole.disconnect_neighbour()\n *  To remove all wires of a specific colour, pass defines.wire_type.red or defines.wire_type.green.\n *  To remove a specific copper cable between two poles, target can be a LuaEntityspecifying the other pole. E.g. pole1.disconnect_neighbour(pole2).\n *  To remove a specific red or green wire, pass a table in the same format as for LuaEntity::connect_neighbour:  * wire :: defines.wire_type: Wire colour\n    * target_entity :: LuaEntity\n    * source_circuit_id :: uint (optional)\n    * target_circuit_id :: uint (optional)",
        "type": "function"
      },
      "order_deconstruction": {
        "name": "order_deconstruction(force) → boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force whose robots are supposed to do the deconstruction.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Sets the entity to be deconstructed by construction robots. \nParameters\n\nforce :: string or LuaForce: The force whose robots are supposed to do the deconstruction.Return value if the entity was marked for deconstruction.",
        "type": "function"
      },
      "cancel_deconstruction": {
        "name": "cancel_deconstruction(force)",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force who did the deconstruction order.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Cancels deconstruction if it is scheduled, does nothing otherwise. \nParameters\n\nforce :: string or LuaForce: The force who did the deconstruction order.",
        "type": "function"
      },
      "to_be_deconstructed": {
        "name": "to_be_deconstructed(force) → boolean",
        "returns": "boolean",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force which ordered the deconstruction. This parameter is is currently unused; it exists only for forward compatibility of the API.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Is this entity marked for deconstruction? \nParameters\n\nforce :: string or LuaForce: The force which ordered the deconstruction. This parameter is is currently unused; it exists only for forward compatibility of the API.",
        "type": "function"
      },
      "get_request_slot": {
        "name": "get_request_slot(slot) → SimpleItemStack",
        "returns": "SimpleItemStack",
        "args": {
          "slot": {
            "doc": "slot :: uint: The slot index.",
            "name": "slot",
            "type": "uint"
          }
        },
        "doc": "Get a logistic requester slot.\nParameters\n\nslot :: uint: The slot index.Return value Contents of the specified slot; nil if the given slot contains no request.\n\nNote: Useable only on entities that have requester slots.",
        "type": "function"
      },
      "set_request_slot": {
        "name": "set_request_slot(request, slot)",
        "args": {
          "request": {
            "doc": "request :: SimpleItemStack: What to request.",
            "name": "request",
            "type": "SimpleItemStack"
          },
          "slot": {
            "doc": "slot :: uint: The slot index.",
            "name": "slot",
            "type": "uint"
          }
        },
        "doc": "Set a logistic requester slot.\nParameters\n\nrequest :: SimpleItemStack: What to request.slot :: uint: The slot index.\n\nNote: Useable only on entities that have requester slots.",
        "type": "function"
      },
      "clear_request_slot": {
        "name": "clear_request_slot(slot)",
        "args": {
          "slot": {
            "doc": "slot :: uint: The slot index.",
            "name": "slot",
            "type": "uint"
          }
        },
        "doc": "Clear a logistic requester slot.\nParameters\n\nslot :: uint: The slot index.\n\nNote: Useable only on entities that have requester slots.",
        "type": "function"
      },
      "is_crafting": {
        "name": "is_crafting() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this machine is currently crafting.Can only be used if this is CraftingMachine",
        "type": "function"
      },
      "is_opened": {
        "name": "is_opened() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently opened.Can only be used if this is Gate",
        "type": "function"
      },
      "is_opening": {
        "name": "is_opening() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently opening.Can only be used if this is Gate",
        "type": "function"
      },
      "is_closed": {
        "name": "is_closed() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently closed.Can only be used if this is Gate",
        "type": "function"
      },
      "is_closing": {
        "name": "is_closing() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this gate is currently closingCan only be used if this is Gate",
        "type": "function"
      },
      "request_to_open": {
        "name": "request_to_open(force, extra_time)",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force that requests the gate to be open.",
            "name": "force",
            "type": "string or LuaForce"
          },
          "extra_time": {
            "doc": "extra_time :: uint (optional): Extra ticks to stay open.",
            "name": "extra_time",
            "type": "uint"
          }
        },
        "doc": "Parameters\n\nforce :: string or LuaForce: The force that requests the gate to be open.extra_time :: uint (optional): Extra ticks to stay open.Can only be used if this is Gate",
        "type": "function"
      },
      "request_to_close": {
        "name": "request_to_close(force)",
        "args": {
          "force": {
            "doc": "force :: string or LuaForce: The force that requests the gate to be closed.",
            "name": "force",
            "type": "string or LuaForce"
          }
        },
        "doc": "Parameters\n\nforce :: string or LuaForce: The force that requests the gate to be closed.Can only be used if this is Gate",
        "type": "function"
      },
      "get_transport_line": {
        "name": "get_transport_line(index) → LuaTransportLine",
        "returns": "LuaTransportLine",
        "args": {
          "index": {
            "doc": "index :: uint: Index of the requested transport line.",
            "name": "index",
            "type": "uint"
          }
        },
        "doc": "Get a transport line of a belt.\nParameters\n\nindex :: uint: Index of the requested transport line.Can only be used if this is TransportBeltConnectable",
        "type": "function"
      },
      "launch_rocket": {
        "name": "launch_rocket() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if the rocket was successfully launched. Return value of falsemeans the silo is not ready for launch.Can only be used if this is RocketSilo",
        "type": "function"
      },
      "revive": {
        "name": "revive(return_item_request_proxy) → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {
          "return_item_request_proxy": {
            "doc": "return_item_request_proxy :: boolean (optional): If true the function will return item request proxy as the third parameter.",
            "name": "return_item_request_proxy",
            "type": "boolean"
          }
        },
        "doc": "Revive a ghost. I.e. turn it from a ghost to a real entity or tile.\nParameters\n\nreturn_item_request_proxy :: boolean (optional): If true the function will return item request proxy as the third parameter.Return value Any items the new real entity collided with or nil if the ghost could not be revived.\n\nNote: If this is an entity ghost and it is successfully revived this will also return the revived entity or nil as a second return value and possibly item request proxy as the third parameter depending on value of return_item_request_proxy.",
        "type": "function"
      },
      "get_connected_rail": {
        "name": "get_connected_rail{rail_direction=…, rail_connection_direction=…} → LuaEntity",
        "returns": "LuaEntity",
        "args": {
          "rail_direction": {
            "doc": "Table with the following fields:  * rail_direction :: defines.rail_direction\n * rail_connection_direction :: defines.rail_connection_direction",
            "name": "rail_direction",
            "type": "defines.rail_direction"
          },
          "rail_direction=…": {
            "name": "rail_direction=…",
            "type": "rail_direction=…"
          },
          "rail_connection_direction=…": {
            "name": "rail_connection_direction=…",
            "type": "rail_connection_direction=…"
          }
        },
        "doc": "Parameters\n\n Table with the following fields:  * rail_direction :: defines.rail_direction\n * rail_connection_direction :: defines.rail_connection_direction\nReturn value Rail connected in the specified manner to this one.Can only be used if this is Rail",
        "type": "function"
      },
      "get_filter": {
        "name": "get_filter(uint) → string",
        "returns": "string",
        "args": {
          "uint": {
            "doc": "uint: Slot to get the filter of.",
            "name": "uint"
          }
        },
        "doc": "Get the filter for a slot in an inserter or a loader.\nParameters\n\nuint: Slot to get the filter of.Return value Prototype name of the entity being filtered; nil if the given slot has no filter.\n\nNote: The inserter/loader must allow filters.",
        "type": "function"
      },
      "set_filter": {
        "name": "set_filter(uint, string)",
        "args": {
          "uint": {
            "doc": "uint: Slot to set the filter of.",
            "name": "uint"
          },
          "string": {
            "doc": "string: Prototype name of the entity to filter.",
            "name": "string"
          }
        },
        "doc": "Set the filter for a slot in an inserter or a loader\nParameters\n\nuint: Slot to set the filter of.string: Prototype name of the entity to filter.\n\nNote: The inserter/loader must allow filters.",
        "type": "function"
      },
      "get_control_behavior": {
        "name": "get_control_behavior() → LuaControlBehavior",
        "returns": "LuaControlBehavior",
        "args": {},
        "doc": "Gets the control behavior of the entity (if any).\nReturn value The control behavior or nil.",
        "type": "function"
      },
      "get_or_create_control_behavior": {
        "name": "get_or_create_control_behavior() → LuaControlBehavior",
        "returns": "LuaControlBehavior",
        "args": {},
        "doc": "Gets (and or creates if needed) the control behavior of the entity.\nReturn value The control behavior or nil.",
        "type": "function"
      },
      "get_circuit_network": {
        "name": "get_circuit_network(wire, circuit_connector) → LuaCircuitNetwork",
        "returns": "LuaCircuitNetwork",
        "args": {
          "wire": {
            "doc": "wire :: defines.wire_type: Wire colour of the network connected to this entity.",
            "name": "wire",
            "type": "defines.wire_type"
          },
          "circuit_connector": {
            "doc": "circuit_connector :: defines.circuit_connector_id (optional): The connector to get circuit network for. Must be specified for entities with more than one circuit network connector.",
            "name": "circuit_connector",
            "type": "defines.circuit_connector_id"
          }
        },
        "doc": "Parameters\n\nwire :: defines.wire_type: Wire colour of the network connected to this entity.circuit_connector :: defines.circuit_connector_id (optional): The connector to get circuit network for. Must be specified for entities with more than one circuit network connector.Return value The circuit network or nil.",
        "type": "function"
      },
      "supports_backer_name": {
        "name": "supports_backer_name() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Return value true if this entity supports a backer name.",
        "type": "function"
      },
      "copy_settings": {
        "name": "copy_settings(entity) → dictionary string → uint",
        "returns": "dictionary string → uint",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          }
        },
        "doc": "Copies settings from the given entity onto this entity. \nParameters\n\nentity :: LuaEntityReturn value Any items removed from this entity as a result of copying the settings.",
        "type": "function"
      },
      "get_logistic_point": {
        "name": "get_logistic_point(defines.logistic_member_index) → LuaLogisticPoint or array of LuaLogisticPoint",
        "returns": "LuaLogisticPoint or array of LuaLogisticPoint",
        "args": {
          "defines.logistic_member_index": {
            "doc": "defines.logistic_member_index (optional)",
            "name": "defines.logistic_member_index"
          }
        },
        "doc": "Gets the LuaLogisticPoint specified by the given index or if not given returns all of the points this entity owns. \nParameters\n\ndefines.logistic_member_index (optional)\n\nNote: When the index is not given for most entities this will be a single entry. For some (such as the player character) this can be zero or more.",
        "type": "function"
      },
      "play_note": {
        "name": "play_note(instrument, note) → boolean",
        "returns": "boolean",
        "args": {
          "instrument": {
            "doc": "instrument :: uint",
            "name": "instrument",
            "type": "uint"
          },
          "note": {
            "doc": "note :: uint",
            "name": "note",
            "type": "uint"
          }
        },
        "doc": "Plays a note with the given instrument and note. \nParameters\n\ninstrument :: uintnote :: uintReturn value If the request was successful.Can only be used if this is ProgrammableSpeaker",
        "type": "function"
      },
      "connect_rolling_stock": {
        "name": "connect_rolling_stock(direction) → boolean",
        "returns": "boolean",
        "args": {
          "direction": {
            "doc": "direction :: defines.rail_direction",
            "name": "direction",
            "type": "defines.rail_direction"
          }
        },
        "doc": "Connects the rolling stock in the given direction. \nParameters\n\ndirection :: defines.rail_directionReturn value If any connection was made",
        "type": "function"
      },
      "disconnect_rolling_stock": {
        "name": "disconnect_rolling_stock(direction) → boolean",
        "returns": "boolean",
        "args": {
          "direction": {
            "doc": "direction :: defines.rail_direction",
            "name": "direction",
            "type": "defines.rail_direction"
          }
        },
        "doc": "Tries to disconnect this rolling stock in the given direciton. \nParameters\n\ndirection :: defines.rail_directionReturn value If anything was disconnected",
        "type": "function"
      },
      "passenger": {
        "name": "passenger",
        "type": "LuaEntity or LuaPlayer",
        "mode": "[Read-Write]",
        "doc": "Setting to nil forces the character/player out of the vehicle, setting to a new character/player forces any existing passenger out and the given character/player becomes the new passenger.\n\n\nNote: May be nil if the car contains no passenger.Can only be used if this is Vehicle"
      },
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the entity prototype. E.g. \"inserter\" or \"filter-inserter\"."
      },
      "ghost_name": {
        "name": "ghost_name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of the entity or tile contained in this ghost \nCan only be used if this is Ghost"
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the entity."
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "ghost_localised_name": {
        "name": "ghost_localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Localised name of the entity or tile contained in this ghost. \nCan only be used if this is Ghost"
      },
      "ghost_localised_description": {
        "name": "ghost_localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is Ghost"
      },
      "type": {
        "name": "type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The entity prototype type of this entity."
      },
      "ghost_type": {
        "name": "ghost_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "The prototype type of the entity or tile contained in this ghost. \nCan only be used if this is Ghost"
      },
      "active": {
        "name": "active",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Deactivating an entity will stop all its operations (car will stop moving, inserters will stop working, fish will stop moving etc).\n\n\nNote: Entities that are are not active naturally can't be set to be active (setting it to be active will do nothing)\n\nNote: Ghosts, simple smoke, and corpses can't be modified at this time.\n\nNote: It is even possible to set the player to not be active, so he can't move and perform most of the tasks."
      },
      "destructible": {
        "name": "destructible",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When the entity is not destructible it can't be damaged.\n\n\nNote: An indestructible entity can still be mined.\n\nNote: Entities that are indestructible naturally (they have no health, like smoke, resource etc) can't be set to be destructible."
      },
      "minable": {
        "name": "minable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: Not minable entities can still be destroyed.\n\nNote: Entities that are not minable naturally (like smoke, player, enemy units etc) can't be set to minable."
      },
      "rotatable": {
        "name": "rotatable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When entity is not to be rotatable (inserter, transport belt etc), it can't be rotated by player using the R key.\n\n\nNote: Entities that are not rotatable naturally (like chest or furnace) can't be set to be rotatable."
      },
      "operable": {
        "name": "operable",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Player can't open gui of this entity and he can't quick insert/input stuff in to the entity when it is not operable."
      },
      "health": {
        "name": "health",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Health of the entity. Setting health to less than 0 will set health to 0, entities with 0 health can not be attacked. Setting health to higher than max health will set health to max health.\n\n\nNote: If used on an entity that doesn't support health, this field will be nil."
      },
      "direction": {
        "name": "direction",
        "type": "defines.direction",
        "mode": "[Read-Write]",
        "doc": "The current direction this entity is facing."
      },
      "supports_direction": {
        "name": "supports_direction",
        "type": "boolean",
        "mode": "[Read-only]",
        "doc": "Whether the entity has direction. When it is false for this entity, it will always return north direction when asked for."
      },
      "orientation": {
        "name": "orientation",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The smooth orientation."
      },
      "amount": {
        "name": "amount",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Count of resource units contained. \nCan only be used if this is ResourceEntity"
      },
      "initial_amount": {
        "name": "initial_amount",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Count of initial resource units contained. \n\n\nNote: If this is not an infinite resource reading will give nil and writing will give an error.Can only be used if this is ResourceEntity"
      },
      "effectivity_modifier": {
        "name": "effectivity_modifier",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Multiplies the acceleration the vehicle can create for one unit of energy. By default is 1.\nCan only be used if this is Car"
      },
      "consumption_modifier": {
        "name": "consumption_modifier",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Multiplies the the energy consumption. \nCan only be used if this is Car"
      },
      "friction_modifier": {
        "name": "friction_modifier",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "Multiplies the car friction rate.\nExampleThis will allow the car to go much faster game.player.vehicle.friction_modifier = 0.5Can only be used if this is Car"
      },
      "speed": {
        "name": "speed",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The current speed of the car. \nCan only be used if this is Car"
      },
      "stack": {
        "name": "stack",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is ItemEntity"
      },
      "prototype": {
        "name": "prototype",
        "type": "LuaEntityPrototype",
        "mode": "[Read-only]",
        "doc": "The entity prototype of this entity."
      },
      "ghost_prototype": {
        "name": "ghost_prototype",
        "type": "LuaEntityPrototype or LuaTilePrototype",
        "mode": "[Read-only]",
        "doc": "The prototype of the entity or tile contained in this ghost. \nCan only be used if this is Ghost"
      },
      "drop_position": {
        "name": "drop_position",
        "type": "Position",
        "mode": "[Read-Write]",
        "doc": "Position where the entity puts its stuff. \n\n\nNote: Meaningful only for entities that put stuff somewhere, such as mining drills or inserters."
      },
      "pickup_position": {
        "name": "pickup_position",
        "type": "Position",
        "mode": "[Read-Write]",
        "doc": "Where the inserter will pick up items from. \nCan only be used if this is Inserter"
      },
      "drop_target": {
        "name": "drop_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity this entity is putting its stuff to or nil if there is no such entity. \n\n\nNote: Meaningful only for entities that put stuff somewhere, such as mining drills or inserters."
      },
      "pickup_target": {
        "name": "pickup_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity the inserter will attempt to pick up from. For example, this can be a transport belt or a storage chest. \nCan only be used if this is Inserter"
      },
      "selected_gun_index": {
        "name": "selected_gun_index",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Index of the currently selected weapon slot of this character. \nCan only be used if this is Character"
      },
      "energy": {
        "name": "energy",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "Energy stored in the entity (heat in furnace, energy stored in electrical devices etc.). always 0 for entities that don't have the concept of energy stored inside.\nExample game.player.print(\"Machine energy: \" .. game.player.selected.energy .. \"J\")\ngame.player.selected.energy = 3000"
      },
      "recipe": {
        "name": "recipe",
        "type": "LuaRecipe",
        "mode": "[Read-Write]",
        "doc": "Current recipe being assembled by this machine. \nCan only be used if this is CraftingMachine"
      },
      "held_stack": {
        "name": "held_stack",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The item stack currently held in an inserter's hand. \nCan only be used if this is Inserter"
      },
      "held_stack_position": {
        "name": "held_stack_position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Current position of the inserter's \"hand\". \nCan only be used if this is Inserter"
      },
      "train": {
        "name": "train",
        "type": "LuaTrain",
        "mode": "[Read-only]",
        "doc": "The train this rolling stock belongs to. \nCan only be used if this is RollingStock"
      },
      "neighbours": {
        "name": "neighbours",
        "type": "dictionary string → array of LuaEntity or array of LuaEntity or LuaEntity",
        "mode": "[Read-only]",
        "doc": "*  When called on an electric pole, this is a dictionary of all connections, indexed by the strings \"copper\", \"red\", and \"green\".\n *  When called on a pipe-connectable entity, this is an array of all entities this pipe is connected to.\n *  When called on an underground transport belt, this is the other end of the underground belt connection, or nil if none."
      },
      "fluidbox": {
        "name": "fluidbox",
        "type": "LuaFluidBox",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "backer_name": {
        "name": "backer_name",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": "The name of a backer (of Factorio) assigned to a lab or train station / stop. \n\n\nNote: Only useable on entities that support backer names. Returns nil when the entity doesn't support a backer name."
      },
      "time_to_live": {
        "name": "time_to_live",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The ticks left for a ghost before it's destroyed. Cannot be set higher than LuaForce::ghost_time_to_live of the entity's force.\nCan only be used if this is Ghost"
      },
      "color": {
        "name": "color",
        "type": "Color",
        "mode": "[Read-Write]",
        "doc": "The character or rolling stock color."
      },
      "signal_state": {
        "name": "signal_state",
        "type": "defines.signal_state",
        "mode": "[Read-only]",
        "doc": "The state of this rail signal. \nCan only be used if this is RailSignal"
      },
      "chain_signal_state": {
        "name": "chain_signal_state",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The state of this chain signal. \nCan only be used if this is RailChainSignal"
      },
      "to_be_looted": {
        "name": "to_be_looted",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Will this entity be picked up automatically when the player walks over it? \nCan only be used if this is ItemEntity"
      },
      "crafting_progress": {
        "name": "crafting_progress",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The current crafting progress, as a number in range [0, 1]. \nCan only be used if this is CraftingMachine"
      },
      "bonus_progress": {
        "name": "bonus_progress",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The current productivity bonus progress, as a number in range [0, 1]. \nCan only be used if this is CraftingMachine"
      },
      "belt_to_ground_type": {
        "name": "belt_to_ground_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "\"input\" or \"output\", depending on whether this underground belt goes down or up. \nCan only be used if this is TransportBeltToGround"
      },
      "loader_type": {
        "name": "loader_type",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "\"input\" or \"output\", depending on whether this loader puts to or gets from a container. \nCan only be used if this is Loader"
      },
      "rocket_parts": {
        "name": "rocket_parts",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Number of rocket parts in the silo. \nCan only be used if this is RocketSilo"
      },
      "logistic_network": {
        "name": "logistic_network",
        "type": "LuaLogisticNetwork",
        "mode": "[Read-only]",
        "doc": "The logistic network this entity is a part of."
      },
      "logistic_cell": {
        "name": "logistic_cell",
        "type": "LuaLogisticCell",
        "mode": "[Read-only]",
        "doc": "The logistic cell this entity is a part of. Will be nil if this entity is not a part of any logistic cell."
      },
      "item_requests": {
        "name": "item_requests",
        "type": "dictionary string → uint",
        "mode": "[Read-Write]",
        "doc": "Items this ghost will request when revived or items this item request proxy is reqeusting. Result is a dictionary mapping each item prototype name to the required count."
      },
      "player": {
        "name": "player",
        "type": "LuaPlayer",
        "mode": "[Read-only]",
        "doc": "The player connected to this character. \nCan only be used if this is Character"
      },
      "unit_group": {
        "name": "unit_group",
        "type": "LuaUnitGroup",
        "mode": "[Read-only]",
        "doc": "The unit group this unit is a member of, or nil if none. \nCan only be used if this is Unit"
      },
      "damage_dealt": {
        "name": "damage_dealt",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The damage dealt by this turret. \nCan only be used if this is Turret"
      },
      "kills": {
        "name": "kills",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "The number of units killed by this turret. \nCan only be used if this is Turret"
      },
      "last_user": {
        "name": "last_user",
        "type": "LuaPlayer",
        "mode": "[Read-Write]",
        "doc": "The player who built the entity \nCan only be used if this is EntityWithOwner"
      },
      "electric_buffer_size": {
        "name": "electric_buffer_size",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The buffer size for the electric energy source or nil if the entity doesn't have an electric energy source.\n\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_input_flow_limit": {
        "name": "electric_input_flow_limit",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The input flow limit for the electric energy source or nil if the entity doesn't have an electric energy source.\n\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_output_flow_limit": {
        "name": "electric_output_flow_limit",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The output flow limit for the electric energy source or nil if the entity doesn't have an electric energy source.\n\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_drain": {
        "name": "electric_drain",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The electric drain for the electric energy source or nil if the entity doesn't have an electric energy source.\n\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "electric_emissions": {
        "name": "electric_emissions",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The emissions size for the electric energy source or nil if the entity doesn't have an electric energy source.\n\n\nNote: Write access is limited to the ElectricEnergyInterface type"
      },
      "unit_number": {
        "name": "unit_number",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The unit number or nil if the entity doesn't have one. This is unique for every entity that has one."
      },
      "mining_progress": {
        "name": "mining_progress",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The mining progress for this mining drill or nil if this isn't a mining drill."
      },
      "bonus_mining_progress": {
        "name": "bonus_mining_progress",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The bonus mining progress for this mining drill or nil if this isn't a mining drill."
      },
      "power_production": {
        "name": "power_production",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The power production specific to the ElectricEnergyInterface entity type. \nCan only be used if this is ElectricEnergyInterface"
      },
      "power_usage": {
        "name": "power_usage",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "The power usage specific to the ElectricEnergyInterface entity type. \nCan only be used if this is ElectricEnergyInterface"
      },
      "bounding_box": {
        "name": "bounding_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": ""
      },
      "mining_target": {
        "name": "mining_target",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The mining target or nil if none \nCan only be used if this is MiningDrill"
      },
      "circuit_connected_entities": {
        "name": "circuit_connected_entities",
        "mode": "[Read-only]",
        "doc": "Entities connected to this entity via the circuit network. It is a table: \n * red :: array of LuaEntity: Entities connected via the red wire.\n * green :: array of LuaEntity: Entities connected via the green wire.",
        "type": "circuit_connected_entities"
      },
      "circuit_connection_definitions": {
        "name": "circuit_connection_definitions",
        "type": "array of CircuitConnectionDefinition",
        "mode": "[Read-only]",
        "doc": "The connection definition for entities connected to this entity via the circuit network. \n Each CircuitConnectionDefinition is a table: \n * wire :: defines.wire_type: Wire color, either defines.wire_type.red or defines.wire_type.green.\n * target_entity :: LuaEntity\n * source_circuit_id :: uint\n * target_circuit_id :: uint"
      },
      "request_slot_count": {
        "name": "request_slot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of request slots this entity has."
      },
      "filter_slot_count": {
        "name": "filter_slot_count",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The number of filter slots this inserter or loader has. 0 if not an inserter or loader."
      },
      "grid": {
        "name": "grid",
        "type": "LuaEquipmentGrid",
        "mode": "[Read-only]",
        "doc": "The equipment grid or nil if this entity doesn't have an equipment grid."
      },
      "graphics_variation": {
        "name": "graphics_variation",
        "type": "uint8",
        "mode": "[Read-Write]",
        "doc": "The graphics variation for this entity or nil if this entity doesn't use graphics varaitions."
      },
      "burner": {
        "name": "burner",
        "type": "LuaBurner",
        "mode": "[Read-only]",
        "doc": "The burner energy source for this entity or nil if there isn't one."
      },
      "shooting_target": {
        "name": "shooting_target",
        "type": "LuaEntity",
        "mode": "[Read-Write]",
        "doc": "The shooting target for this turret or nil."
      },
      "stickers": {
        "name": "stickers",
        "type": "array of LuaEntity",
        "mode": "[Read-only]",
        "doc": "The sticker entities attached to this entity."
      },
      "parameters": {
        "name": "parameters",
        "type": "ProgrammableSpeakerParameters",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is ProgrammableSpeaker"
      },
      "alert_parameters": {
        "name": "alert_parameters",
        "type": "ProgrammableSpeakerAlertParameters",
        "mode": "[Read-Write]",
        "doc": "Can only be used if this is ProgrammableSpeaker"
      },
      "electric_network_statistics": {
        "name": "electric_network_statistics",
        "type": "LuaFlowStatistics",
        "mode": "[Read-only]",
        "doc": "The electric network statitiscs for this electric pole."
      },
      "inserter_stack_size_override": {
        "name": "inserter_stack_size_override",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "Sets the stack size limit on this inserter. If the stack size is > than the force stack size limit the value is ignored. \n\n\nNote: Set to 0 to reset."
      },
      "products_finished": {
        "name": "products_finished",
        "type": "float",
        "mode": "[Read-only]",
        "doc": "Can only be used if this is CraftingMachine"
      }
    }
  },
  "LuaDecorativePrototype": {
    "name": "LuaDecorativePrototype",
    "type": "LuaDecorativePrototype",
    "doc": "Prototype of a virtual signal.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "collision_box": {
        "name": "collision_box",
        "type": "BoundingBox",
        "mode": "[Read-only]",
        "doc": "The bounding box used for collision checking."
      },
      "autoplace_specification": {
        "name": "autoplace_specification",
        "type": "AutoplaceSpecification",
        "mode": "[Read-only]",
        "doc": "Autoplace specification for this decorative prototype. nil if none."
      }
    }
  },
  "LuaDamagePrototype": {
    "name": "LuaDamagePrototype",
    "type": "LuaDamagePrototype",
    "doc": "Prototype of a damage.",
    "properties": {
      "name": {
        "name": "name",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Name of this prototype."
      },
      "order": {
        "name": "order",
        "type": "string",
        "mode": "[Read-only]",
        "doc": "Order string of this prototype."
      },
      "localised_name": {
        "name": "localised_name",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      },
      "localised_description": {
        "name": "localised_description",
        "type": "LocalisedString",
        "mode": "[Read-only]",
        "doc": ""
      }
    }
  },
  "LuaCustomTable": {
    "name": "LuaCustomTable",
    "type": "LuaCustomTable",
    "doc": "Lazily evaluated table.\n For performance reasons, we sometimes return a custom table-like type instead of a native Lua table. This custom\n type lazily constructs the necessary Lua wrappers of the corresponding C++ objects, therefore preventing their\n unnecessary construction in some cases.",
    "properties": {
      "operator []": {
        "name": "operator []",
        "mode": "[Read-Write]",
        "doc": "Access an element of this custom table.",
        "type": "operator []"
      },
      "operator #": {
        "name": "operator #",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Number of elements in this table."
      }
    }
  },
  "LuaCustomChartTag": {
    "name": "LuaCustomChartTag",
    "type": "LuaCustomChartTag",
    "doc": "A custom tag that shows on the map view.",
    "properties": {
      "destroy": {
        "name": "destroy()",
        "args": {},
        "doc": "Destroys this tag.",
        "type": "function"
      },
      "icon": {
        "name": "icon",
        "type": "SignalID",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "last_user": {
        "name": "last_user",
        "type": "LuaPlayer",
        "mode": "[Read-Write]",
        "doc": "The player who last edited this tag."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "The position of this tag."
      },
      "orientation": {
        "name": "orientation",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "The orientation of this tag."
      },
      "text": {
        "name": "text",
        "type": "string",
        "mode": "[Read-Write]",
        "doc": ""
      },
      "target": {
        "name": "target",
        "type": "LuaEntity",
        "mode": "[Read-Write]",
        "doc": "The entity target if any or nil. This is almost always empty."
      },
      "tag_number": {
        "name": "tag_number",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The unique ID for this tag on this force."
      },
      "force": {
        "name": "force",
        "type": "LuaForce",
        "mode": "[Read-only]",
        "doc": "The force this tag belongs to."
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[Read-only]",
        "doc": "The surface this tag belongs to."
      }
    }
  },
  "LuaControl": {
    "name": "LuaControl",
    "type": "LuaControl",
    "doc": "This is an abstract base class containing the common functionality between LuaPlayer and character entities\n (see LuaEntity). When accessing these members through a LuaEntity, it must refer to a character\n entity.",
    "properties": {
      "get_inventory": {
        "name": "get_inventory(inventory) → LuaInventory",
        "returns": "LuaInventory",
        "args": {
          "inventory": {
            "doc": "inventory :: defines.inventory",
            "name": "inventory",
            "type": "defines.inventory"
          }
        },
        "doc": "Get an inventory belonging to this entity. This can be either the \"main\" inventory or some auxiliary one, like the module slots or logistic trash slots.\nParameters\n\ninventory :: defines.inventoryReturn value or nil if this entity doesn't have an inventory with the given index.",
        "type": "function"
      },
      "get_quickbar": {
        "name": "get_quickbar() → LuaInventory",
        "returns": "LuaInventory",
        "args": {},
        "doc": "Get the quickbar belonging to this entity if any. This works for both the character entity (the little guy running around) and the god controller (sandbox, character-less players).\nReturn value or nil if this entity doesn't have a quickbar.",
        "type": "function"
      },
      "can_insert": {
        "name": "can_insert(items) → boolean",
        "returns": "boolean",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items that would be inserted.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Can at least some items be inserted?\nParameters\n\nitems :: SimpleItemStack: Items that would be inserted.Return value true if at least a part of the given items could be inserted into this inventory.",
        "type": "function"
      },
      "insert": {
        "name": "insert(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to insert.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Insert items into this entity. This works the same way as inserters or shift-clicking: the \"best\" inventory is chosen automatically.\nParameters\n\nitems :: SimpleItemStack: Items to insert.Return value Number of items actually inserted.",
        "type": "function"
      },
      "set_gui_arrow": {
        "name": "set_gui_arrow{type=…}",
        "args": {
          "type": {
            "doc": "Table with the following fields:  * type :: string: Where to point to. This field determines what other fields are mandatory. May be \"nowhere\", \"goal\", \"entity_info\", \"active_window\", \"entity\", \"position\", \"crafting_queue\", or \"item_stack\".\n * Additional type-specific parameters * entity * entity :: LuaEntity\n      \n      \n    * position * position :: Position\n      \n      \n    * crafting_queue * crafting_queueindex :: uint\n      \n      \n    * item_stack * inventory_index :: uint\n       * item_stack_index :: uint\n       * source :: string: May be either \"player\" or \"target\".",
            "name": "type",
            "type": "string"
          }
        },
        "doc": "Create an arrow which points at this entity. This is used in the tutorial. For examples, see control.luain the campaign missions.\nParameters\n\n Table with the following fields:  * type :: string: Where to point to. This field determines what other fields are mandatory. May be \"nowhere\", \"goal\", \"entity_info\", \"active_window\", \"entity\", \"position\", \"crafting_queue\", or \"item_stack\".\n * Additional type-specific parameters * entity * entity :: LuaEntity\n    * position * position :: Position\n    * crafting_queue * crafting_queueindex :: uint\n    * item_stack * inventory_index :: uint\n       * item_stack_index :: uint\n       * source :: string: May be either \"player\" or \"target\".",
        "type": "function"
      },
      "clear_gui_arrow": {
        "name": "clear_gui_arrow()",
        "args": {},
        "doc": "Removes the arrow created by set_gui_arrow.",
        "type": "function"
      },
      "get_item_count": {
        "name": "get_item_count(item) → uint",
        "returns": "uint",
        "args": {
          "item": {
            "doc": "item :: string (optional): Prototype name of the item to count. If not specified, count all items.",
            "name": "item",
            "type": "string"
          }
        },
        "doc": "Get the number of all or some items in this entity.\nParameters\n\nitem :: string (optional): Prototype name of the item to count. If not specified, count all items.",
        "type": "function"
      },
      "has_items_inside": {
        "name": "has_items_inside() → boolean",
        "returns": "boolean",
        "args": {},
        "doc": "Does this entity have any item inside it?",
        "type": "function"
      },
      "can_reach_entity": {
        "name": "can_reach_entity(entity) → boolean",
        "returns": "boolean",
        "args": {
          "entity": {
            "doc": "entity :: LuaEntity",
            "name": "entity",
            "type": "LuaEntity"
          }
        },
        "doc": "Can a given entity be opened or accessed?\nParameters\n\nentity :: LuaEntity",
        "type": "function"
      },
      "clear_items_inside": {
        "name": "clear_items_inside()",
        "args": {},
        "doc": "Remove all items from this entity.",
        "type": "function"
      },
      "remove_item": {
        "name": "remove_item(items) → uint",
        "returns": "uint",
        "args": {
          "items": {
            "doc": "items :: SimpleItemStack: Items to remove.",
            "name": "items",
            "type": "SimpleItemStack"
          }
        },
        "doc": "Remove items from this entity.\nParameters\n\nitems :: SimpleItemStack: Items to remove.Return value Number of items actually removed.",
        "type": "function"
      },
      "teleport": {
        "name": "teleport(position, surface) → boolean",
        "returns": "boolean",
        "args": {
          "position": {
            "doc": "position :: Position: Where to teleport to.",
            "name": "position",
            "type": "Position"
          },
          "surface": {
            "doc": "surface :: SurfaceSpecification (optional): Surface to teleport to. If not given, will teleport to the entity's current surface.",
            "name": "surface",
            "type": "SurfaceSpecification"
          }
        },
        "doc": "Teleport the entity to a given position, possibly on another surface.\nParameters\n\nposition :: Position: Where to teleport to.surface :: SurfaceSpecification (optional): Surface to teleport to. If not given, will teleport to the entity's current surface.Return value true when the entity was successfully teleported.\n\nNote: Some entities may not be teleported. For instance, walls, rail signals or entities with fluid boxes won't allow teleportation and this method will always return false when used on any such entity.",
        "type": "function"
      },
      "update_selected_entity": {
        "name": "update_selected_entity(position)",
        "args": {
          "position": {
            "doc": "position :: Position: Position of the entity to select",
            "name": "position",
            "type": "Position"
          }
        },
        "doc": "Select an entity, as if by hovering the mouse above it.\nParameters\n\nposition :: Position: Position of the entity to select",
        "type": "function"
      },
      "clear_selected_entity": {
        "name": "clear_selected_entity()",
        "args": {},
        "doc": "Unselect any selected entity.",
        "type": "function"
      },
      "disable_flashlight": {
        "name": "disable_flashlight()",
        "args": {},
        "doc": "Disable the flashlight.",
        "type": "function"
      },
      "enable_flashlight": {
        "name": "enable_flashlight()",
        "args": {},
        "doc": "Enable the flashlight.",
        "type": "function"
      },
      "get_craftable_count": {
        "name": "get_craftable_count(recipe) → uint",
        "returns": "uint",
        "args": {
          "recipe": {
            "doc": "recipe :: string or LuaRecipe: The recipe.",
            "name": "recipe",
            "type": "string or LuaRecipe"
          }
        },
        "doc": "Gets the count of the given recipe that can be crafted.\nParameters\n\nrecipe :: string or LuaRecipe: The recipe.Return value The count that can be crafted.",
        "type": "function"
      },
      "begin_crafting": {
        "name": "begin_crafting{count=…, recipe=…, silent=…} → uint",
        "returns": "uint",
        "args": {
          "count": {
            "doc": "* count :: uint: The count to craft.\n * recipe :: string or LuaRecipe: The recipe to craft.\n * silent :: boolean (optional): If false and the recipe can't be crafted the requested number of times printing the failure is skipped.",
            "name": "count",
            "type": "uint"
          },
          "count=…": {
            "name": "count=…",
            "type": "count=…"
          },
          "recipe=…": {
            "name": "recipe=…",
            "type": "recipe=…"
          },
          "silent=…": {
            "name": "silent=…",
            "type": "silent=…"
          }
        },
        "doc": "Begins crafting the given count of the given recipe\nParameters\n\n  * count :: uint: The count to craft.\n * recipe :: string or LuaRecipe: The recipe to craft.\n * silent :: boolean (optional): If false and the recipe can't be crafted the requested number of times printing the failure is skipped.\nReturn value The count that was actually started crafting.",
        "type": "function"
      },
      "cancel_crafting": {
        "name": "cancel_crafting(options)",
        "args": {
          "options": {
            "doc": "options: :  * index :: uint: The crafting queue index.\n * count :: uint: The count to cancel crafting.",
            "name": "options",
            "type": "uint"
          }
        },
        "doc": "Cancels crafting the given count of the given crafting queue index\nParameters\n\noptions: :  * index :: uint: The crafting queue index.\n * count :: uint: The count to cancel crafting.",
        "type": "function"
      },
      "surface": {
        "name": "surface",
        "type": "LuaSurface",
        "mode": "[Read-only]",
        "doc": "The surface this entity is currently on."
      },
      "position": {
        "name": "position",
        "type": "Position",
        "mode": "[Read-only]",
        "doc": "Current position of the entity."
      },
      "vehicle": {
        "name": "vehicle",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The vehicle the player is currently sitting in; nil if none."
      },
      "force": {
        "name": "force",
        "type": "string or LuaForce",
        "mode": "[Read-Write]",
        "doc": "The force of this entity. Reading will always give a LuaForce, but it is possible to assign either string or LuaForce to this attribute to change the force."
      },
      "selected": {
        "name": "selected",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The currently selected entity; nil if none."
      },
      "opened": {
        "name": "opened",
        "type": "LuaEntity or LuaItemStack or LuaEquipment or defines.gui_type",
        "mode": "[Read-Write]",
        "doc": "The GUI target the player currently has open; nil if none. \n\n\nNote: Write supports any of the types. Read will return the entity, equipment or nil."
      },
      "crafting_queue_size": {
        "name": "crafting_queue_size",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "Size of the crafting queue."
      },
      "walking_state": {
        "name": "walking_state",
        "mode": "[Read-Write]",
        "doc": "Current walking state.\n It is a table with two fields: \n * walking :: boolean: If false, the player is currently not walking; otherwise it's going somewhere\n * direction :: defines.direction: Direction where the player is walking\nExampleMake the player go north. Note that a one-shot action like this will only make the player walk for one tick. game.player.walking_state = {walking = true, direction = defines.direction.north}",
        "type": "walking_state"
      },
      "riding_state": {
        "name": "riding_state",
        "mode": "[Read-Write]",
        "doc": "Current riding state of this car or the vehicle this player is riding in.\n It is a table with two fields: \n * acceleration :: defines.riding.acceleration\n * direction :: defines.riding.direction",
        "type": "riding_state"
      },
      "mining_state": {
        "name": "mining_state",
        "mode": "[Read-Write]",
        "doc": "Current mining state.\n It is a table with two fields: \n * mining :: boolean: Whether the player is mining at all\n * position :: Position (optional): What the player is mining; not necessary when mining is false.",
        "type": "mining_state"
      },
      "shooting_state": {
        "name": "shooting_state",
        "mode": "[Read-Write]",
        "doc": "Current shooting state.\n It is a table with two fields: \n * state :: defines.shooting: The current state\n * position :: Position: The position being shot at",
        "type": "shooting_state"
      },
      "picking_state": {
        "name": "picking_state",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "Current item-picking state."
      },
      "repair_state": {
        "name": "repair_state",
        "mode": "[Read-Write]",
        "doc": "Current repair state.\n It is a table with two fields: \n * repairing :: boolean: The current state\n * position :: Position: The position being repaired",
        "type": "repair_state"
      },
      "cursor_stack": {
        "name": "cursor_stack",
        "type": "LuaItemStack",
        "mode": "[Read-only]",
        "doc": "The player's cursor stack."
      },
      "driving": {
        "name": "driving",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "true if the player is in a vehicle. Writing to this attribute puts the player in or out of a vehicle."
      },
      "crafting_queue": {
        "name": "crafting_queue",
        "type": "array of CraftingQueueItem",
        "mode": "[Read-only]",
        "doc": "Gets the current crafting queue items.\n Each CraftingQueueItem is a table: \n * index :: uint: The crafting queue index\n * recipe :: string: The recipe.\n * count :: uint: The count being crafted."
      },
      "cheat_mode": {
        "name": "cheat_mode",
        "type": "boolean",
        "mode": "[Read-Write]",
        "doc": "When true hand crafting is free and instant"
      },
      "character_crafting_speed_modifier": {
        "name": "character_crafting_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_mining_speed_modifier": {
        "name": "character_mining_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_running_speed_modifier": {
        "name": "character_running_speed_modifier",
        "type": "double",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_build_distance_bonus": {
        "name": "character_build_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_item_drop_distance_bonus": {
        "name": "character_item_drop_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_reach_distance_bonus": {
        "name": "character_reach_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_resource_reach_distance_bonus": {
        "name": "character_resource_reach_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_item_pickup_distance_bonus": {
        "name": "character_item_pickup_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_loot_pickup_distance_bonus": {
        "name": "character_loot_pickup_distance_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "quickbar_count_bonus": {
        "name": "quickbar_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_inventory_slots_bonus": {
        "name": "character_inventory_slots_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_logistic_slot_count_bonus": {
        "name": "character_logistic_slot_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_trash_slot_count_bonus": {
        "name": "character_trash_slot_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_maximum_following_robot_count_bonus": {
        "name": "character_maximum_following_robot_count_bonus",
        "type": "uint",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "character_health_bonus": {
        "name": "character_health_bonus",
        "type": "float",
        "mode": "[Read-Write]",
        "doc": "\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character)."
      },
      "auto_trash_filters": {
        "name": "auto_trash_filters",
        "type": "dictionary string → uint",
        "mode": "[Read-Write]",
        "doc": "The auto-trash filters. The keys are item prototype names, the values are the slot values.\n\n\nNote: When called on a LuaPlayer, it must be associated with a character (see LuaPlayer::character).ExampleThis will set the auto-trash slots to keep only at most 20 iron plates and 42 copper wires in the player's inventory. game.player.auto_trash_filters = {[\"iron-plate\"] = 20, [\"copper-cable\"] = 42}"
      },
      "opened_gui_type": {
        "name": "opened_gui_type",
        "mode": "[Read-only]",
        "doc": "Returns the defines.gui_type or nil.",
        "type": "opened_gui_type"
      },
      "build_distance": {
        "name": "build_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The build distance of this character or max uint when not a character or player connected to a character."
      },
      "drop_item_distance": {
        "name": "drop_item_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The item drop distance of this character or max uint when not a character or player connected to a character."
      },
      "reach_distance": {
        "name": "reach_distance",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The reach distance of this character or max uint when not a character or player connected to a character."
      },
      "item_pickup_distance": {
        "name": "item_pickup_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The item pickup distance of this character or max double when not a character or player connected to a character."
      },
      "loot_pickup_distance": {
        "name": "loot_pickup_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The loot pickup distance of this character or max double when not a character or player connected to a character."
      },
      "resource_reach_distance": {
        "name": "resource_reach_distance",
        "type": "double",
        "mode": "[Read-only]",
        "doc": "The resource reach distance of this character or max double when not a character or player connected to a character."
      }
    }
  },
  "LuaCommandProcessor": {
    "name": "LuaCommandProcessor",
    "type": "LuaCommandProcessor",
    "doc": "Custom game console commands.",
    "properties": {
      "add_command": {
        "name": "add_command(name, help, function)",
        "args": {
          "name": {
            "doc": "name :: string: Name of the command (case sensitive).",
            "name": "name",
            "type": "string"
          },
          "help": {
            "doc": "help :: LocalisedString: The localised help message.",
            "name": "help",
            "type": "LocalisedString"
          },
          "function": {
            "doc": "function :: function: The function that will be called when this command is invoked.",
            "name": "function",
            "type": "function"
          }
        },
        "doc": "Add a command.\nParameters\n\nname :: string: Name of the command (case sensitive).help :: LocalisedString: The localised help message.function :: function: The function that will be called when this command is invoked.\n\nNote: It is an error if the given command name is already registered or already exists as a game command.",
        "type": "function"
      },
      "remove_command": {
        "name": "remove_command(string) → boolean",
        "returns": "boolean",
        "args": {
          "string": {
            "name": "string",
            "type": "string"
          }
        },
        "doc": "Removes a registered command \nParameters\n\nReturn value If the command was removed. False if the command didn't exist.",
        "type": "function"
      },
      "commands": {
        "name": "commands",
        "type": "dictionary string → LocalisedString",
        "mode": "[Read-only]",
        "doc": "The script registered commands"
      },
      "game_commands": {
        "name": "game_commands",
        "type": "dictionary string → LocalisedString",
        "mode": "[Read-only]",
        "doc": "The script registered commands"
      }
    }
  },
  "LuaCircuitNetwork": {
    "name": "LuaCircuitNetwork",
    "type": "LuaCircuitNetwork",
    "doc": "A circuit network associated with a given entity, connector, and wire type.",
    "properties": {
      "get_signal": {
        "name": "get_signal(SignalID) → int",
        "returns": "int",
        "args": {
          "SignalID": {
            "doc": "SignalID: The signal to read.",
            "name": "SignalID"
          }
        },
        "doc": "Parameters\n\nSignalID: The signal to read.Return value The current value of the signal.",
        "type": "function"
      },
      "entity": {
        "name": "entity",
        "type": "LuaEntity",
        "mode": "[Read-only]",
        "doc": "The entity this circuit network reference is associated with"
      },
      "wire_type": {
        "name": "wire_type",
        "type": "defines.wire_type",
        "mode": "[Read-only]",
        "doc": "The wire type this network is associated with."
      },
      "circuit_connector_id": {
        "name": "circuit_connector_id",
        "type": "defines.circuit_connector_id",
        "mode": "[Read-only]",
        "doc": "The circuit connector ID on the associated entity this network was gotten from."
      },
      "signals": {
        "name": "signals",
        "type": "array of Signal",
        "mode": "[Read-only]",
        "doc": "The circuit network signals last tick."
      },
      "network_id": {
        "name": "network_id",
        "type": "uint",
        "mode": "[Read-only]",
        "doc": "The circuit networks ID."
      }
    }
  }
}